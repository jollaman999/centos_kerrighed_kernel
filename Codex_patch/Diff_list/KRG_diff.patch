
--- mm/swapfile.c
+++ mm/swapfile.c
@@ -512,7 +512,11 @@
 /*
  * How many references to page are currently swapped out?
  */
+#ifdef CONFIG_KRG_MM
+int page_swapcount(struct page *page)
+#else
 static inline int page_swapcount(struct page *page)
+#endif
 {
 	int count = 0;
 	struct swap_info_struct *p;
	 
@@ -1004,7 +1013,11 @@
 			if (start_mm == &init_mm)
 				shmem = shmem_unuse(entry, page);
 			else
+#ifdef CONFIG_KRG_FAF
+				retval = __unuse_mm(start_mm, entry, page);
+#else
 				retval = unuse_mm(start_mm, entry, page);
+#endif
 		}
 		if (*swap_map > 1) {
 			int set_start_mm = (*swap_map >= swcount);
@@ -1034,7 +1047,11 @@
 					set_start_mm = 1;
 					shmem = shmem_unuse(entry, page);
 				} else
+#ifdef CONFIG_KRG_FAF
+					retval = __unuse_mm(mm, entry, page);
+#else
 					retval = unuse_mm(mm, entry, page);
+#endif
 				if (set_start_mm && *swap_map < swcount) {
 					mmput(new_start_mm);
 					atomic_inc(&mm->mm_users);
--- mm/vmscan.c
+++ mm/vmscan.c
@@ -97,7 +103,11 @@
 	unsigned long (*isolate_pages)(unsigned long nr, struct list_head *dst,
 			unsigned long *scanned, int order, int mode,
 			struct zone *z, struct mem_cgroup *mem_cont,
+#ifdef CONFIG_KRG_MM
+			int active, int file, int kddm);
+#else
 			int active, int file);
+#endif
 };
 
 #define lru_to_page(_head) (list_entry((_head)->prev, struct page, lru))
@@ -540,6 +550,10 @@
 		 * We know how to handle that.
 		 */
 		lru = active + page_is_file_cache(page);
+#ifdef CONFIG_KRG_MM
+		BUG_ON(page_is_migratable(page) && page_is_file_cache(page));
+		lru += page_is_migratable(page);
+#endif
 		lru_cache_add_lru(page, lru);
 	} else {
 		/*
@@ -582,11 +596,36 @@
 	VM_BUG_ON(PageLRU(page));
 
 	lru = !!TestClearPageActive(page) + page_is_file_cache(page);
+#ifdef CONFIG_KRG_MM
+	BUG_ON(page_is_migratable(page) && page_is_file_cache(page));
+	lru += page_is_migratable(page);
+#endif
 	lru_cache_add_lru(page, lru);
 	put_page(page);
 }
 #endif /* CONFIG_UNEVICTABLE_LRU */
 
+#ifdef CONFIG_KRG_MM
+static int check_injection_flow(void)
+{
+	long i = 0, limit = RPC_MAX_PAGES;
+
+	if ((rpc_consumed_bytes() / PAGE_SIZE) < limit)
+		return 0;
+
+	if (current_is_kswapd())
+		limit = limit / 2;
+	else
+		limit = 4 * limit / 5;
+
+	while ((rpc_consumed_bytes() / PAGE_SIZE) > limit) {
+		schedule();
+		i++;
+	}
+
+	return 0;
+}
+#endif
 
 /*
  * shrink_page_list() returns the number of reclaimed pages
@@ -1011,13 +1087,21 @@
 					unsigned long *scanned, int order,
 					int mode, struct zone *z,
 					struct mem_cgroup *mem_cont,
+#ifdef CONFIG_KRG_MM
+					int active, int file, int kddm)
+#else
 					int active, int file)
+#endif
 {
 	int lru = LRU_BASE;
 	if (active)
 		lru += LRU_ACTIVE;
 	if (file)
 		lru += LRU_FILE;
+#ifdef CONFIG_KRG_MM
+	if (kddm)
+		lru += LRU_MIGR;
+#endif
 	return isolate_lru_pages(nr, &z->lru[lru].list, dst, scanned, order,
 								mode, !!file);
 }
@@ -1035,6 +1119,10 @@
 
 	list_for_each_entry(page, page_list, lru) {
 		lru = page_is_file_cache(page);
+#ifdef CONFIG_KRG_MM
+		BUG_ON(page_is_migratable(page) && page_is_file_cache(page));
+		lru += page_is_migratable(page);
+#endif
 		if (PageActive(page)) {
 			lru += LRU_ACTIVE;
 			ClearPageActive(page);
@@ -1097,7 +1185,11 @@
  */
 static unsigned long shrink_inactive_list(unsigned long max_scan,
 			struct zone *zone, struct scan_control *sc,
+#ifdef CONFIG_KRG_MM
+			int priority, int file, int kddm)
+#else
 			int priority, int file)
+#endif
 {
 	LIST_HEAD(page_list);
 	struct pagevec pvec;
@@ -1132,7 +1224,11 @@
 
 		nr_taken = sc->isolate_pages(sc->swap_cluster_max,
 			     &page_list, &nr_scan, sc->order, mode,
+#ifdef CONFIG_KRG_MM
+				zone, sc->mem_cgroup, 0, file, kddm);
+#else
 				zone, sc->mem_cgroup, 0, file);
+#endif
 		nr_active = clear_active_flags(&page_list, count);
 		__count_vm_events(PGDEACTIVATE, nr_active);
 
@@ -1221,7 +1327,11 @@
 			lru = page_lru(page);
 			add_page_to_lru_list(zone, page, lru);
 			if (PageActive(page)) {
+#ifdef CONFIG_KRG_MM
+				int file = reclaim_stat_index (page);
+#else
 				int file = !!page_is_file_cache(page);
+#endif
 				reclaim_stat->recent_rotated[file]++;
 			}
 			if (!pagevec_add(&pvec, page)) {
@@ -1272,7 +1382,11 @@
 
 
 static void shrink_active_list(unsigned long nr_pages, struct zone *zone,
+#ifdef CONFIG_KRG_MM
+		struct scan_control *sc, int priority, int file, int kddm)
+#else
 			struct scan_control *sc, int priority, int file)
+#endif
 {
 	unsigned long pgmoved;
 	int pgdeactivate = 0;
@@ -1288,7 +1402,11 @@
 	spin_lock_irq(&zone->lru_lock);
 	pgmoved = sc->isolate_pages(nr_pages, &l_hold, &pgscanned, sc->order,
 					ISOLATE_ACTIVE, zone,
+#ifdef CONFIG_KRG_MM
+					sc->mem_cgroup, 1, file, kddm);
+#else
 					sc->mem_cgroup, 1, file);
+#endif
 	/*
 	 * zone->pages_scanned is used for detect zone's oom
 	 * mem_cgroup remembers nr_scan by itself.
@@ -1296,14 +1414,25 @@
 	if (scanning_global_lru(sc)) {
 		zone->pages_scanned += pgscanned;
 	}
+#ifdef CONFIG_KRG_MM
+	reclaim_stat->recent_scanned[RECLAIM_STAT_INDEX(file, kddm)] += pgmoved;
+#else
 	reclaim_stat->recent_scanned[!!file] += pgmoved;
+#endif
 
 	if (file)
 		__mod_zone_page_state(zone, NR_ACTIVE_FILE, -pgmoved);
 	else
+#ifdef CONFIG_KRG_MM
+	if (kddm)
+		__mod_zone_page_state(zone, NR_ACTIVE_MIGR, -pgmoved);
+	else
+#endif
 		__mod_zone_page_state(zone, NR_ACTIVE_ANON, -pgmoved);
 	spin_unlock_irq(&zone->lru_lock);
 
+
+
 	pgmoved = 0;
 	while (!list_empty(&l_hold)) {
 		cond_resched();
@@ -1327,7 +1456,11 @@
 	 * Move the pages to the [file or anon] inactive list.
 	 */
 	pagevec_init(&pvec, 1);
+#ifdef CONFIG_KRG_MM
+	lru = BUILD_LRU_ID(0 /* inactive */, file, kddm);
+#else
 	lru = LRU_BASE + file * LRU_FILE;
+#endif
 
 	spin_lock_irq(&zone->lru_lock);
 	/*
@@ -1336,7 +1469,11 @@
 	 * This helps balance scan pressure between file and anonymous
 	 * pages in get_scan_ratio.
 	 */
+#ifdef CONFIG_KRG_MM
+	reclaim_stat->recent_rotated[RECLAIM_STAT_INDEX(file, kddm)] += pgmoved;
+#else
 	reclaim_stat->recent_rotated[!!file] += pgmoved;
+#endif
 
 	pgmoved = 0;
 	while (!list_empty(&l_inactive)) {
@@ -1403,21 +1540,65 @@
 	return low;
 }
 
+#ifdef CONFIG_KRG_MM
+static int inactive_kddm_is_low_global(struct zone *zone)
+{
+	unsigned long active, inactive;
+
+	active = zone_page_state(zone, NR_ACTIVE_MIGR);
+	inactive = zone_page_state(zone, NR_INACTIVE_MIGR);
+
+	if (inactive * zone->inactive_ratio < active)
+		return 1;
+
+	return 0;
+}
+
+static int inactive_kddm_is_low(struct zone *zone, struct scan_control *sc)
+{
+	int low;
+
+	if (scanning_global_lru(sc))
+		low = inactive_kddm_is_low_global(zone);
+	else
+		BUG();
+	return low;
+}
+#endif
+
 static unsigned long shrink_list(enum lru_list lru, unsigned long nr_to_scan,
 	struct zone *zone, struct scan_control *sc, int priority)
 {
 	int file = is_file_lru(lru);
 
 	if (lru == LRU_ACTIVE_FILE) {
+#ifdef CONFIG_KRG_MM
+		shrink_active_list(nr_to_scan, zone, sc, priority, file, 0);
+#else
 		shrink_active_list(nr_to_scan, zone, sc, priority, file);
+#endif
 		return 0;
 	}
 
 	if (lru == LRU_ACTIVE_ANON && inactive_anon_is_low(zone, sc)) {
+#ifdef CONFIG_KRG_MM
+		shrink_active_list(nr_to_scan, zone, sc, priority, file, 0);
+#else
 		shrink_active_list(nr_to_scan, zone, sc, priority, file);
+#endif
 		return 0;
 	}
+#ifdef CONFIG_KRG_MM
+	if (lru == LRU_ACTIVE_MIGR && inactive_kddm_is_low(zone, sc)) {
+		shrink_active_list(nr_to_scan, zone, sc, priority, 0, 1);
+		return 0;
+	}
+
+	return shrink_inactive_list(nr_to_scan, zone, sc, priority, file,
+				    is_kddm_lru(lru));
+#else
 	return shrink_inactive_list(nr_to_scan, zone, sc, priority, file);
+#endif
 }
 
 /*
@@ -1432,23 +1613,31 @@
 static void get_scan_ratio(struct zone *zone, struct scan_control *sc,
 					unsigned long *percent)
 {
+#ifdef CONFIG_KRG_MM
+	unsigned long kddm, kddm_prio, kp;
+#endif
 	unsigned long anon, file, free;
 	unsigned long anon_prio, file_prio;
 	unsigned long ap, fp;
 	struct zone_reclaim_stat *reclaim_stat = get_reclaim_stat(zone, sc);
 
+#ifndef CONFIG_KRG_MM
 	/* If we have no swap space, do not bother scanning anon pages. */
 	if (!sc->may_swap || (nr_swap_pages <= 0)) {
 		percent[0] = 0;
 		percent[1] = 100;
 		return;
 	}
+#endif
 
 	anon  = zone_nr_pages(zone, sc, LRU_ACTIVE_ANON) +
 		zone_nr_pages(zone, sc, LRU_INACTIVE_ANON);
 	file  = zone_nr_pages(zone, sc, LRU_ACTIVE_FILE) +
 		zone_nr_pages(zone, sc, LRU_INACTIVE_FILE);
-
+#ifdef CONFIG_KRG_MM
+	kddm  = zone_nr_pages(zone, sc, LRU_ACTIVE_MIGR) +
+		zone_nr_pages(zone, sc, LRU_INACTIVE_MIGR);
+#else
 	if (scanning_global_lru(sc)) {
 		free  = zone_page_state(zone, NR_FREE_PAGES);
 		/* If we have very few page cache pages,
@@ -1618,7 +1850,13 @@
 	 * rebalance the anon lru active/inactive ratio.
 	 */
 	if (inactive_anon_is_low(zone, sc))
+#ifdef CONFIG_KRG_MM
+		shrink_active_list(SWAP_CLUSTER_MAX, zone, sc, priority, 0, 0);
+	if (inactive_kddm_is_low(zone, sc))
+		shrink_active_list(SWAP_CLUSTER_MAX, zone, sc, priority, 0, 1);
+#else
 		shrink_active_list(SWAP_CLUSTER_MAX, zone, sc, priority, 0);
+#endif
 
 	throttle_vm_writeout(sc->gfp_mask);
 }
@@ -1919,7 +2157,15 @@
 			 */
 			if (inactive_anon_is_low(zone, &sc))
 				shrink_active_list(SWAP_CLUSTER_MAX, zone,
+#ifndef CONFIG_KRG_MM
 							&sc, priority, 0);
+#else
+							&sc, priority, 0, 0);
+			/* Do the same on kddm lru pages */
+			if (inactive_kddm_is_low(zone, &sc))
+				shrink_active_list(SWAP_CLUSTER_MAX, zone,
+						   &sc, priority, 0, 1);
+#endif
 
 			if (!zone_watermark_ok(zone, order, zone->pages_high,
 					       0, 0)) {
@@ -2148,6 +2394,10 @@
 {
 	return global_page_state(NR_ACTIVE_ANON)
 		+ global_page_state(NR_ACTIVE_FILE)
+#ifdef CONFIG_KRG_MM
+		+ global_page_state(NR_ACTIVE_MIGR)
+		+ global_page_state(NR_INACTIVE_MIGR)
+#endif
 		+ global_page_state(NR_INACTIVE_ANON)
 		+ global_page_state(NR_INACTIVE_FILE);
 }
--- mm/swap.c
+++ mm/swap.c
@@ -197,8 +206,12 @@
 		lru += LRU_ACTIVE;
 		add_page_to_lru_list(zone, page, lru);
 		__count_vm_event(PGACTIVATE);
-
+#ifdef CONFIG_KRG_MM
+		update_page_reclaim_stat(zone, page, !!file,
+					 page_is_migratable(page), 1);
+#else
 		update_page_reclaim_stat(zone, page, !!file, 1);
+#endif
 	}
 	spin_unlock_irq(&zone->lru_lock);
 }
--- mm/mmap.c
+++ mm/mmap.c
@@ -113,6 +120,10 @@
 int __vm_enough_memory(struct mm_struct *mm, long pages, int cap_sys_admin)
 {
 	unsigned long free, allowed;
+#ifdef CONFIG_KRG_MM
+	krg_dynamic_node_info_t *dyn_info;
+	kerrighed_node_t node;
+#endif
 
 	vm_acct_memory(pages);
 
@@ -727,7 +802,11 @@
 }
 
 /* Flags that can be inherited from an existing mapping when merging */
+#ifdef CONFIG_KRG_MM
+#define VM_MERGEABLE_FLAGS (VM_CAN_NONLINEAR|VM_KDDM)
+#else
 #define VM_MERGEABLE_FLAGS (VM_CAN_NONLINEAR)
+#endif
 
 /*
  * If the vma has a ->close operation then the driver probably needs to release
@@ -1560,6 +1685,7 @@
 				  unsigned long, unsigned long, unsigned long);
 
 	get_area = current->mm->get_unmapped_area;
+#endif
 	if (file && file->f_op && file->f_op->get_unmapped_area)
 		get_area = file->f_op->get_unmapped_area;
 	addr = get_area(file, addr, len, pgoff, flags);
@@ -1801,9 +1927,12 @@
 {
 	return expand_downwards(vma, address);
 }
-
 #ifdef CONFIG_STACK_GROWSUP
+#ifdef CONFIG_KRG_MM
+int __expand_stack(struct vm_area_struct *vma, unsigned long address)
+#else
 int expand_stack(struct vm_area_struct *vma, unsigned long address)
+#endif
 {
 	return expand_upwards(vma, address);
 }
@@ -2220,6 +2387,10 @@
 	vma->vm_page_prot = vm_get_page_prot(flags);
 	vma_link(mm, vma, prev, rb_link, rb_parent);
 out:
+#ifdef CONFIG_KRG_MM
+	if (mm->anon_vma_kddm_set)
+		krg_check_vma_link(vma);
+#endif
 	mm->total_vm += len >> PAGE_SHIFT;
 	if (flags & VM_LOCKED) {
 		if (!mlock_vma_pages_range(vma, addr, addr + len))
@@ -2418,11 +2588,26 @@
 {
 }
 
-static struct vm_operations_struct special_mapping_vmops = {
+#ifndef CONFIG_KRG_MM
+static
+#endif
+struct vm_operations_struct special_mapping_vmops = {
 	.close = special_mapping_close,
 	.fault = special_mapping_fault,
 };
 
+#ifdef CONFIG_KRG_MM
+int special_mapping_vm_ops_krgsyms_register(void)
+{
+	return krgsyms_register(KRGSYMS_VM_OPS_SPECIAL_MAPPING, &special_mapping_vmops);
+}
+
+int special_mapping_vm_ops_krgsyms_unregister(void)
+{
+	return krgsyms_unregister(KRGSYMS_VM_OPS_SPECIAL_MAPPING);
+}
+#endif
+
 /*
  * Called with mm->mmap_sem held for writing.
  * Insert a new vma covering the given region, with the given flags.
--- mm/memcontrol.c
+++ mm/memcontrol.c
@@ -621,7 +621,11 @@
 					unsigned long *scanned, int order,
 					int mode, struct zone *z,
 					struct mem_cgroup *mem_cont,
+#ifdef CONFIG_KRG_MM
+					int active, int file, int kddm)
+#else
 					int active, int file)
+#endif
 {
 	unsigned long nr_taken = 0;
 	struct page *page;
@@ -632,7 +636,12 @@
 	int nid = z->zone_pgdat->node_id;
 	int zid = zone_idx(z);
 	struct mem_cgroup_per_zone *mz;
+#ifdef CONFIG_KRG_MM
+	int lru = BUILD_LRU_ID(!!active, !!file, !!kddm);
+	BUG_ON(kddm && file);
+#else
 	int lru = LRU_FILE * !!file + !!active;
+#endif
 
 	BUG_ON(!mem_cont);
 	mz = mem_cgroup_zoneinfo(mem_cont, nid, zid);
--- mm/backing-dev.c
+++ mm/backing-dev.c
@@ -315,7 +315,11 @@
  * write congestion.  If no backing_devs are congested then just wait for the
  * next write to be completed.
  */
+#ifdef CONFIG_KRG_EPM
+static long __congestion_wait(int rw, long timeout)
+#else
 long congestion_wait(int rw, long timeout)
+#endif
 {
 	long ret;
 	DEFINE_WAIT(wait);
--- mm/page_alloc.c
+++ mm/page_alloc.c
@@ -249,10 +249,18 @@
 
 	printk(KERN_ALERT "BUG: Bad page state in process %s  pfn:%05lx\n",
 		current->comm, page_to_pfn(page));
+#ifdef CONFIG_KRG_MM
 	printk(KERN_ALERT
-		"page:%p flags:%p count:%d mapcount:%d mapping:%p index:%lx\n",
+	        "page:%p flags:%p count:%d mapcount:%d mapping:%p index:%lx kddm_count:%d obj_entry:%p\n",
+	       page, (void *)page->flags, page_count(page),
+	       page_mapcount(page), page->mapping, page->index,
+	       page_kddm_count(page), page->obj_entry);
+#else
+	printk(KERN_ALERT
+	        "page:%p flags:%p count:%d mapcount:%d mapping:%p index:%lx\n",
 		page, (void *)page->flags, page_count(page),
 		page_mapcount(page), page->mapping, page->index);
+#endif
 
 	dump_stack();
 out:
@@ -496,6 +504,10 @@
 	if (unlikely(page_mapcount(page) |
 		(page->mapping != NULL)  |
 		(page_count(page) != 0)  |
+#ifdef CONFIG_KRG_MM
+		(page->obj_entry != NULL) |
+		(page_kddm_count(page) != 0) |
+#endif
 		(page->flags & PAGE_FLAGS_CHECK_AT_FREE))) {
 		bad_page(page);
 		return 1;
@@ -1478,6 +1490,9 @@
 
 	lockdep_trace_alloc(gfp_mask);
 
+#ifdef CONFIG_KRG_MM
+	krg_notify_mem(0);
+#endif
 	might_sleep_if(wait);
 
 	if (should_fail_alloc_page(gfp_mask, order))
--- mm/memory.c
+++ mm/memory.c
@@ -61,7 +61,9 @@
 #include <asm/tlb.h>
 #include <asm/tlbflush.h>
 #include <asm/pgtable.h>
-
+#ifdef CONFIG_KRG_MM
+#include <kerrighed/page_table_tree.h>
+#endif
 #include "internal.h"
 
 #ifndef CONFIG_NEED_MULTIPLE_NODES
@@ -537,11 +539,17 @@
  * already present in the new task to be cleared in the whole range
  * covered by this vma.
  */
-
+#ifdef CONFIG_KRG_MM
+static inline void
+copy_one_pte(struct mm_struct *dst_mm, struct mm_struct *src_mm,
+		pte_t *dst_pte, pte_t *src_pte, struct vm_area_struct *vma,
+		unsigned long addr, int *rss, int anon_only)
+#else
 static inline void
 copy_one_pte(struct mm_struct *dst_mm, struct mm_struct *src_mm,
 		pte_t *dst_pte, pte_t *src_pte, struct vm_area_struct *vma,
 		unsigned long addr, int *rss)
+#endif
 {
 	unsigned long vm_flags = vma->vm_flags;
 	pte_t pte = *src_pte;
@@ -615,9 +635,15 @@
 	set_pte_at(dst_mm, addr, dst_pte, pte);
 }
 
+#ifdef CONFIG_KRG_MM
+static int copy_pte_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,
+		pmd_t *dst_pmd, pmd_t *src_pmd, struct vm_area_struct *vma,
+		unsigned long addr, unsigned long end, int anon_only)
+#else
 static int copy_pte_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,
 		pmd_t *dst_pmd, pmd_t *src_pmd, struct vm_area_struct *vma,
 		unsigned long addr, unsigned long end)
+#endif
 {
 	pte_t *src_pte, *dst_pte;
 	spinlock_t *src_ptl, *dst_ptl;
@@ -649,7 +675,12 @@
 			progress++;
 			continue;
 		}
+#ifdef CONFIG_KRG_MM
+		copy_one_pte(dst_mm, src_mm, dst_pte, src_pte, vma, addr, rss,
+			     anon_only);
+#else
 		copy_one_pte(dst_mm, src_mm, dst_pte, src_pte, vma, addr, rss);
+#endif
 		progress += 8;
 	} while (dst_pte++, src_pte++, addr += PAGE_SIZE, addr != end);
 
@@ -2088,6 +2173,31 @@
 
 	if (unlikely(anon_vma_prepare(vma)))
 		goto oom;
+
+#ifdef CONFIG_KRG_MM
+	if (need_vma_link_check && mm->anon_vma_kddm_set)
+		krg_check_vma_link(vma);
+	if (vma->vm_ops && vma->vm_ops->wppage) {
+		new_page = vma->vm_ops->wppage(vma, address & PAGE_MASK,
+					       old_page);
+		/* Check if we have called the regular SHM wppage code.
+		 * If we did so, continue with regular kernel code.
+		 */
+		if (new_page == ERR_PTR(EPERM))
+			goto continue_wppage;
+
+		if (!new_page)
+			goto oom;
+
+		if (old_page)
+			page_cache_release(old_page);
+
+		ret |= VM_FAULT_WRITE;
+		return ret;
+	}
+continue_wppage:
+#endif /* CONFIG_KRG_MM */
+
 	VM_BUG_ON(old_page == ZERO_PAGE(0));
 	new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);
 	if (!new_page)
@@ -2510,9 +2620,15 @@
  * but allow concurrent faults), and pte mapped but not yet locked.
  * We return with mmap_sem still held, but pte unmapped and unlocked.
  */
+#ifdef CONFIG_KRG_MM
+int do_swap_page(struct mm_struct *mm, struct vm_area_struct *vma,
+		 unsigned long address, pte_t *page_table, pmd_t *pmd,
+		 int write_access, pte_t orig_pte)
+#else
 static int do_swap_page(struct mm_struct *mm, struct vm_area_struct *vma,
 		unsigned long address, pte_t *page_table, pmd_t *pmd,
 		int write_access, pte_t orig_pte)
+#endif
 {
 	spinlock_t *ptl;
 	struct page *page;
@@ -2737,10 +2881,33 @@
 	vmf.flags = flags;
 	vmf.page = NULL;
 
+#ifdef CONFIG_KRG_MM
+	vmf.pte = orig_pte;
+
+	if (flags & FAULT_FLAG_WRITE
+	    && !vma->anon_vma
+	    && !(vma->vm_flags & VM_SHARED)) {
+		if (unlikely(anon_vma_prepare(vma))) {
+			anon = 1;
+			return VM_FAULT_OOM;
+		}
+		if (mm->anon_vma_kddm_set)
+			krg_check_vma_link(vma);
+	}
+#endif
 	ret = vma->vm_ops->fault(vma, &vmf);
 	if (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))
 		return ret;
 
+#ifdef CONFIG_KRG_MM
+	/*
+	 * If we are in a KDDM linked VMA, all the mapping job has been done
+	 * by the Kerrighed MM layer.
+	 */
+	if (vma->vm_flags & VM_KDDM)
+		return ret;
+#endif
+
 	/*
 	 * For consistency in subsequent calls, make the faulted page always
 	 * locked.
--- mm/mremap.c
+++ mm/mremap.c
@@ -363,7 +382,11 @@
 	if (vma->vm_flags & VM_LOCKED) {
 		unsigned long locked, lock_limit;
 		locked = mm->locked_vm << PAGE_SHIFT;
+#ifdef CONFIG_KRG_MM
+		lock_limit = _lock_limit;
+#else
 		lock_limit = current->signal->rlim[RLIMIT_MEMLOCK].rlim_cur;
+#endif
 		locked += new_len - old_len;
 		ret = -EAGAIN;
 		if (locked > lock_limit && !capable(CAP_IPC_LOCK))
@@ -376,7 +399,11 @@
 
 	if (vma->vm_flags & VM_ACCOUNT) {
 		charged = (new_len - old_len) >> PAGE_SHIFT;
+#ifdef CONFIG_KRG_MM
+		if (security_vm_enough_memory_mm(mm, charged))
+#else
 		if (security_vm_enough_memory(charged))
+#endif
 			goto out_nc;
 	}
 
@@ -419,8 +446,18 @@
 			if (vma->vm_flags & VM_MAYSHARE)
 				map_flags |= MAP_SHARED;
 
+#ifdef CONFIG_KRG_MM
+			if (*_new_addr == 0) {
+				new_addr = get_unmapped_area(vma->vm_file, 0,
+					     new_len, vma->vm_pgoff, map_flags);
+				*_new_addr = new_addr;
+			}
+			else
+				new_addr = *_new_addr;
+#else
 			new_addr = get_unmapped_area(vma->vm_file, 0, new_len,
 						vma->vm_pgoff, map_flags);
+#endif
 			if (new_addr & ~PAGE_MASK) {
 				ret = new_addr;
 				goto out;
--- mm/vmstat.c
+++ mm/vmstat.c
@@ -710,7 +710,12 @@
 		   "\n        min      %lu"
 		   "\n        low      %lu"
 		   "\n        high     %lu"
+#ifdef CONFIG_KRG_MM
+		   "\n        scanned  %lu (aa: %lu ia: %lu af: %lu if: %lu "
+		   "ak: %lu ik: %lu)"
+#else
 		   "\n        scanned  %lu (aa: %lu ia: %lu af: %lu if: %lu)"
+#endif
 		   "\n        spanned  %lu"
 		   "\n        present  %lu",
 		   zone_page_state(zone, NR_FREE_PAGES),
@@ -722,6 +727,10 @@
 		   zone->lru[LRU_INACTIVE_ANON].nr_scan,
 		   zone->lru[LRU_ACTIVE_FILE].nr_scan,
 		   zone->lru[LRU_INACTIVE_FILE].nr_scan,
+#ifdef CONFIG_KRG_MM
+		   zone->lru[LRU_ACTIVE_MIGR].nr_scan,
+		   zone->lru[LRU_INACTIVE_MIGR].nr_scan,
+#endif
 		   zone->spanned_pages,
 		   zone->present_pages);
 
--- mm/shmem.c
+++ mm/shmem.c
@@ -2551,6 +2561,14 @@
 		goto out2;
 	}
 
+#ifdef CONFIG_KRG_EPM
+	error = krgsyms_register(KRGSYMS_VM_OPS_SHMEM, &shmem_vm_ops);
+	if (error) {
+		printk(KERN_ERR "Could not register shmem_vm_ops\n");
+		goto out1_1;
+	}
+#endif
+
 	shm_mnt = vfs_kern_mount(&tmpfs_fs_type, MS_NOUSER,
 				tmpfs_fs_type.name, NULL);
 	if (IS_ERR(shm_mnt)) {
@@ -2561,6 +2579,10 @@
 	return 0;
 
 out1:
+#ifdef CONFIG_KRG_EPM
+	krgsyms_unregister(KRGSYMS_VM_OPS_SHMEM);
+out1_1:
+#endif
 	unregister_filesystem(&tmpfs_fs_type);
 out2:
 	destroy_inodecache();
--- mm/rmap.c
+++ mm/rmap.c
@@ -52,10 +52,18 @@
 #include <linux/migrate.h>
 
 #include <asm/tlbflush.h>
+#ifdef CONFIG_KRG_MM
+#include <kerrighed/page_table_tree.h>
+#include <kddm/object.h>
+#include <kddm/kddm_types.h>
+#endif
 
 #include "internal.h"
 
-static struct kmem_cache *anon_vma_cachep;
+#ifndef CONFIG_KRG_MM
+static
+#endif
+struct kmem_cache *anon_vma_cachep;
 
 static inline struct anon_vma *anon_vma_alloc(void)
 {
@@ -191,7 +199,11 @@
  * Getting a lock on a stable anon_vma from a page off the LRU is
  * tricky: page_lock_anon_vma rely on RCU to guard against the races.
  */
+#ifdef CONFIG_KRG_MM
+struct anon_vma *page_lock_anon_vma(struct page *page)
+#else
 static struct anon_vma *page_lock_anon_vma(struct page *page)
+#endif
 {
 	struct anon_vma *anon_vma;
 	unsigned long anon_mapping;
@@ -211,7 +223,11 @@
 	return NULL;
 }
 
+#ifdef CONFIG_KRG_MM
+void page_unlock_anon_vma(struct anon_vma *anon_vma)
+#else
 static void page_unlock_anon_vma(struct anon_vma *anon_vma)
+#endif
 {
 	spin_unlock(&anon_vma->lock);
 	rcu_read_unlock();
@@ -763,8 +788,13 @@
  * Subfunctions of try_to_unmap: try_to_unmap_one called
  * repeatedly from either try_to_unmap_anon or try_to_unmap_file.
  */
+#ifdef CONFIG_KRG_MM
+int try_to_unmap_one(struct page *page, struct vm_area_struct *vma,
+		     int migration)
+#else
 static int try_to_unmap_one(struct page *page, struct vm_area_struct *vma,
 				int migration)
+#endif
 {
 	struct mm_struct *mm = vma->vm_mm;
 	unsigned long address;
@@ -884,6 +963,16 @@
 		}
 		set_pte_at(mm, address, pte, swp_entry_to_pte(entry));
 		BUG_ON(pte_file(*pte));
+#ifdef CONFIG_KRG_MM
+		wait_lock_kddm_page(page);
+		if (obj_entry && mm->anon_vma_kddm_id) {
+			obj_entry->object = (void*) mk_swap_pte_page(pte);
+			set_swap_pte_obj_entry(pte, obj_entry);
+			if (atomic_dec_and_test(&page->_kddm_count))
+				page->obj_entry = NULL;
+		}
+		unlock_kddm_page(page);
+#endif
 	} else if (PAGE_MIGRATION && migration) {
 		/* Establish migration entry for a file page */
 		swp_entry_t entry;
@@ -892,6 +981,10 @@
 	} else
 		dec_mm_counter(mm, file_rss);
 
+#ifdef CONFIG_KRG_MM
+	if (obj_entry)
+		CLEAR_OBJECT_LOCKED(obj_entry);
+#endif
 
 	page_remove_rmap(page);
 	page_cache_release(page);
--- fs/binfmt_elf.c
+++ fs/binfmt_elf.c
@@ -31,6 +31,10 @@
 #include <linux/random.h>
 #include <linux/elf.h>
 #include <linux/utsname.h>
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/children.h>
+#include <kerrighed/krgsyms.h>
+#endif
 #include <asm/uaccess.h>
 #include <asm/param.h>
 #include <asm/page.h>
@@ -1341,7 +1345,11 @@
 	prstatus->pr_sigpend = p->pending.signal.sig[0];
 	prstatus->pr_sighold = p->blocked.sig[0];
 	prstatus->pr_pid = task_pid_vnr(p);
+#ifdef CONFIG_KRG_EPM
+	prstatus->pr_ppid = krg_get_real_parent_pid(p);
+#else
 	prstatus->pr_ppid = task_pid_vnr(p->real_parent);
+#endif
 	prstatus->pr_pgrp = task_pgrp_vnr(p);
 	prstatus->pr_sid = task_session_vnr(p);
 	if (thread_group_leader(p)) {
@@ -1383,7 +1391,11 @@
 	psinfo->pr_psargs[len] = 0;
 
 	psinfo->pr_pid = task_pid_vnr(p);
+#ifdef CONFIG_KRG_EPM
+	psinfo->pr_ppid = krg_get_real_parent_pid(p);
+#else
 	psinfo->pr_ppid = task_pid_vnr(p->real_parent);
+#endif
 	psinfo->pr_pgrp = task_pgrp_vnr(p);
 	psinfo->pr_sid = task_session_vnr(p);
 
--- fs/pipe.c
+++ fs/pipe.c
@@ -948,11 +960,10 @@
 	return NULL;
 }
 
-struct file *create_write_pipe(int flags)
+struct dentry *__prepare_pipe_dentry(void)
 {
 	int err;
 	struct inode *inode;
-	struct file *f;
 	struct dentry *dentry;
 	struct qstr name = { .name = "" };
 
@@ -975,25 +986,66 @@
 	dentry->d_flags &= ~DCACHE_UNHASHED;
 	d_instantiate(dentry, inode);
 
-	err = -ENFILE;
+	return dentry;
+
+err_inode:
+	free_pipe_info(inode);
+	iput(inode);
+err:
+	return ERR_PTR(err);
+}
+
+struct file *__create_write_pipe(struct dentry *dentry, int flags)
+{
+	struct file *f;
+	int err = -ENFILE;
+#ifdef CONFIG_KRG_EPM
+	struct pipe_inode_info *pipe;
+#endif
+
 	f = alloc_file(pipe_mnt, dentry, FMODE_WRITE, &write_pipefifo_fops);
 	if (!f)
-		goto err_dentry;
-	f->f_mapping = inode->i_mapping;
+		goto err;
+	f->f_mapping = dentry->d_inode->i_mapping;
 
 	f->f_flags = O_WRONLY | (flags & O_NONBLOCK);
 	f->f_version = 0;
+#ifdef CONFIG_KRG_EPM
+	pipe = dentry->d_inode->i_pipe;
+	pipe->fwrite = f;
+#endif
+
+	return f;
+
+err:
+	return ERR_PTR(err);
+}
+
+struct file *create_write_pipe(int flags)
+{
+	int err;
+	struct file *f;
+	struct dentry *dentry;
+
+	dentry = __prepare_pipe_dentry();
+	if (IS_ERR(dentry)) {
+		err = PTR_ERR(dentry);
+		goto err;
+	}
+
+	f = __create_write_pipe(dentry, flags);
+	if (IS_ERR(f)) {
+		err = PTR_ERR(f);
+		goto err_dentry;
+	}
 
 	return f;
 
  err_dentry:
-	free_pipe_info(inode);
+	free_pipe_info(dentry->d_inode);
 	dput(dentry);
 	return ERR_PTR(err);
 
- err_inode:
-	free_pipe_info(inode);
-	iput(inode);
  err:
 	return ERR_PTR(err);
 }
@@ -1005,26 +1057,39 @@
 	put_filp(f);
 }
 
-struct file *create_read_pipe(struct file *wrf, int flags)
+struct file *__create_read_pipe(struct dentry *dentry, int flags)
 {
+#ifdef CONFIG_KRG_EPM
+	struct pipe_inode_info *pipe;
+#endif
 	struct file *f = get_empty_filp();
 	if (!f)
 		return ERR_PTR(-ENFILE);
 
 	/* Grab pipe from the writer */
-	f->f_path = wrf->f_path;
-	path_get(&wrf->f_path);
-	f->f_mapping = wrf->f_path.dentry->d_inode->i_mapping;
+	f->f_path.dentry = dget(dentry);
+	f->f_path.mnt = mntget(pipe_mnt);
+
+	f->f_mapping = dentry->d_inode->i_mapping;
 
 	f->f_pos = 0;
 	f->f_flags = O_RDONLY | (flags & O_NONBLOCK);
 	f->f_op = &read_pipefifo_fops;
 	f->f_mode = FMODE_READ;
 	f->f_version = 0;
+#ifdef CONFIG_KRG_EPM
+	pipe = dentry->d_inode->i_pipe;
+	pipe->fread = f;
+#endif
 
 	return f;
 }
 
+struct file *create_read_pipe(struct file *wrf, int flags)
+{
+	return __create_read_pipe(wrf->f_path.dentry, flags);
+}
+
 int do_pipe_flags(int *fd, int flags)
 {
 	struct file *fw, *fr;
--- fs/exec.c
+++ fs/exec.c
@@ -54,6 +54,16 @@
 #include <linux/kmod.h>
 #include <linux/fsnotify.h>
 #include <linux/fs_struct.h>
+#ifdef CONFIG_KRG_CAP
+#include <kerrighed/capabilities.h>
+#endif
+#ifdef CONFIG_KRG_PROC
+#include <kerrighed/task.h>
+#include <kerrighed/krginit.h>
+#endif
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/signal.h>
+#endif
 
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
@@ -893,8 +960,19 @@
 		BUG_ON(leader->exit_state != EXIT_ZOMBIE);
 		leader->exit_state = EXIT_DEAD;
 		write_unlock_irq(&tasklist_lock);
+#ifdef CONFIG_KRG_PROC
+		/* tsk has taken leader's pid. */
+		if (obj)
+			__krg_task_unlock(tsk);
+#endif /* CONFIG_KRG_PROC */
+#ifdef CONFIG_KRG_EPM
+		krg_children_finish_de_thread(parent_children_obj, tsk);
+#endif
 
 		release_task(leader);
+#ifdef CONFIG_KRG_PROC
+		up_read(&kerrighed_init_sem);
+#endif
 	}
 
 	sig->group_exit_task = NULL;
@@ -1405,10 +1503,18 @@
 	if (retval < 0)
 		goto out;
 
+#ifdef CONFIG_KRG_MM
+	retval = krg_do_execve(current, current->mm);
+	if (retval)
+		goto out;
+#endif
 	/* execve succeeded */
 	current->fs->in_exec = 0;
 	current->in_execve = 0;
 	mutex_unlock(&current->cred_exec_mutex);
+#ifdef CONFIG_KRG_CAP
+	krg_cap_finish_exec(bprm);
+#endif
 	acct_update_integrals(current);
 	free_bprm(bprm);
 	if (displaced)
@@ -1416,6 +1522,11 @@
 	return retval;
 
 out:
+#ifdef CONFIG_KRG_EPM
+	/* Quiet the BUG_ON() in mmput() */
+	if (bprm->mm)
+		atomic_dec(&bprm->mm->mm_ltasks);
+#endif
 	if (bprm->mm)
 		mmput (bprm->mm);
 
@@ -1699,6 +1810,11 @@
 	vfork_done = tsk->vfork_done;
 	if (vfork_done) {
 		tsk->vfork_done = NULL;
+#ifdef CONFIG_KRG_EPM
+		if (tsk->remote_vfork_done)
+			krg_vfork_done(vfork_done);
+		else
+#endif
 		complete(vfork_done);
 	}
 
--- fs/file.c
+++ fs/file.c
@@ -523,8 +558,22 @@
 	return error;
 }
 
+#ifdef CONFIG_KRG_FAF
+int alloc_fd(unsigned start, unsigned flags)
+{
+	return __alloc_fd(current, start, flags);
+}
+#endif
+
 int get_unused_fd(void)
 {
 	return alloc_fd(0, 0);
 }
 EXPORT_SYMBOL(get_unused_fd);
+
+#ifdef CONFIG_KRG_FAF
+int __get_unused_fd(struct task_struct *task)
+{
+	return __alloc_fd(task, 0, 0);
+}
+#endif
--- fs/sync.c
+++ fs/sync.c
@@ -13,6 +13,9 @@
 #include <linux/pagemap.h>
 #include <linux/quotaops.h>
 #include <linux/buffer_head.h>
+#ifdef CONFIG_KRG_FAF
+#include <kerrighed/faf.h>
+#endif
 
 #define VALID_FLAGS (SYNC_FILE_RANGE_WAIT_BEFORE|SYNC_FILE_RANGE_WRITE| \
 			SYNC_FILE_RANGE_WAIT_AFTER)
--- fs/open.c
+++ fs/open.c
@@ -30,6 +30,9 @@
 #include <linux/audit.h>
 #include <linux/falloc.h>
 #include <linux/fs_struct.h>
+#ifdef CONFIG_KRG_IPC
+#include <kerrighed/faf.h>
+#endif
 
 int vfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
@@ -167,7 +170,14 @@
 	file = fget(fd);
 	if (!file)
 		goto out;
+
+#ifdef CONFIG_KRG_FAF
+	if (file->f_flags & O_FAF_CLT)
+		error = krg_faf_fstatfs(file, &tmp);
+	else
+#endif
 	error = vfs_statfs_native(file->f_path.dentry, &tmp);
+
 	if (!error && copy_to_user(buf, &tmp, sizeof(tmp)))
 		error = -EFAULT;
 	fput(file);
--- fs/binfmt_aout.c
+++ fs/binfmt_aout.c
@@ -24,6 +24,9 @@
 #include <linux/binfmts.h>
 #include <linux/personality.h>
 #include <linux/init.h>
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/krgsyms.h>
+#endif
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
--- fs/ocfs2/mmap.c
+++ fs/ocfs2/mmap.c
@@ -202,7 +202,10 @@
 	return ret;
 }
 
-static struct vm_operations_struct ocfs2_file_vm_ops = {
+#ifndef CONFIG_KRG_MM
+static
+#endif
+struct vm_operations_struct ocfs2_file_vm_ops = {
 	.fault		= ocfs2_fault,
 	.page_mkwrite	= ocfs2_page_mkwrite,
 };
--- fs/dcache.c
+++ fs/dcache.c
@@ -1915,9 +1920,19 @@
 
 	spin_lock(&vfsmount_lock);
 	prepend(&end, &buflen, "\0", 1);
+#ifdef CONFIG_KRG_DVFS
+	if (!IS_ROOT(dentry) && d_unhashed(dentry)) {
+		*deleted = true;
+		if (prepend(&end, &buflen, " (deleted)", 10) != 0)
+			goto Elong;
+	} else {
+		*deleted = false;
+	}
+#else
 	if (!IS_ROOT(dentry) && d_unhashed(dentry) &&
 		(prepend(&end, &buflen, " (deleted)", 10) != 0))
 			goto Elong;
+#endif
 
 	if (buflen < 1)
 		goto Elong;
--- fs/proc/inode.c
+++ fs/proc/inode.c
@@ -18,6 +18,9 @@
 #include <linux/module.h>
 #include <linux/smp_lock.h>
 #include <linux/sysctl.h>
+#if defined(CONFIG_KRG_PROCFS) && defined(CONFIG_KRG_PROC)
+#include <kerrighed/task.h>
+#endif
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
--- fs/proc/root.c
+++ fs/proc/root.c
@@ -57,7 +57,7 @@
 	if (flags & MS_KERNMOUNT)
 		ns = (struct pid_namespace *)data;
 	else
-		ns = current->nsproxy->pid_ns;
+		ns = task_active_pid_ns(current);
 
 	sb = sget(fs_type, proc_test_super, proc_set_super, ns);
 	if (IS_ERR(sb))
--- fs/proc/base.c
+++ fs/proc/base.c
@@ -263,7 +273,10 @@
 	return NULL;
 }
 
-static int proc_pid_cmdline(struct task_struct *task, char * buffer)
+#if !defined(CONFIG_KRG_PROCFS) || !defined(CONFIG_KRG_PROC)
+static
+#endif
+int proc_pid_cmdline(struct task_struct *task, char * buffer)
 {
 	int res = 0;
 	unsigned int len;
@@ -466,7 +492,10 @@
 
 /* The badness from the OOM killer */
 unsigned long badness(struct task_struct *p, unsigned long uptime);
-static int proc_oom_score(struct task_struct *task, char *buffer)
+#if !defined(CONFIG_KRG_PROCFS) || !defined(CONFIG_KRG_PROC)
+static
+#endif
+int proc_oom_score(struct task_struct *task, char *buffer)
 {
 	unsigned long points;
 	struct timespec uptime;
@@ -672,7 +785,10 @@
 	return allowed;
 }
 
-static int proc_setattr(struct dentry *dentry, struct iattr *attr)
+#if !defined(CONFIG_KRG_PROCFS) || !defined(CONFIG_KRG_PROC)
+static
+#endif
+int proc_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	int error;
 	struct inode *inode = dentry->d_inode;
--- fs/proc/meminfo.c
+++ fs/proc/meminfo.c
@@ -67,6 +70,10 @@
 		"Inactive(anon): %8lu kB\n"
 		"Active(file):   %8lu kB\n"
 		"Inactive(file): %8lu kB\n"
+#ifdef CONFIG_KRG_MM
+		"Active(migr):   %8lu kB\n"
+		"Inactive(migr): %8lu kB\n"
+#endif
 #ifdef CONFIG_UNEVICTABLE_LRU
 		"Unevictable:    %8lu kB\n"
 		"Mlocked:        %8lu kB\n"
@@ -106,12 +113,23 @@
 		K(i.bufferram),
 		K(cached),
 		K(total_swapcache_pages),
+#ifdef CONFIG_KRG_MM
+		K(pages[LRU_ACTIVE_ANON]   + pages[LRU_ACTIVE_FILE] +
+		  pages[LRU_ACTIVE_MIGR]),
+		K(pages[LRU_INACTIVE_ANON] + pages[LRU_INACTIVE_FILE] +
+		  pages[LRU_INACTIVE_MIGR]),
+#else
 		K(pages[LRU_ACTIVE_ANON]   + pages[LRU_ACTIVE_FILE]),
 		K(pages[LRU_INACTIVE_ANON] + pages[LRU_INACTIVE_FILE]),
+#endif
 		K(pages[LRU_ACTIVE_ANON]),
 		K(pages[LRU_INACTIVE_ANON]),
 		K(pages[LRU_ACTIVE_FILE]),
 		K(pages[LRU_INACTIVE_FILE]),
+#ifdef CONFIG_KRG_MM
+		K(pages[LRU_ACTIVE_MIGR]),
+		K(pages[LRU_INACTIVE_MIGR]),
+#endif
 #ifdef CONFIG_UNEVICTABLE_LRU
 		K(pages[LRU_UNEVICTABLE]),
 		K(global_page_state(NR_MLOCK)),
--- fs/proc/array.c
+++ fs/proc/array.c
@@ -82,6 +82,12 @@
 #include <linux/pid_namespace.h>
 #include <linux/ptrace.h>
 #include <linux/tracehook.h>
+#ifdef CONFIG_KRG_PROCFS
+#include <kerrighed/cpu_id.h>
+#endif
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/children.h>
+#endif
 
 #include <asm/pgtable.h>
 #include <asm/processor.h>
--- fs/binfmt_elf_fdpic.c
+++ fs/binfmt_elf_fdpic.c
@@ -34,6 +34,10 @@
 #include <linux/elf.h>
 #include <linux/elf-fdpic.h>
 #include <linux/elfcore.h>
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/children.h>
+#include <kerrighed/krgsyms.h>
+#endif
 
 #include <asm/uaccess.h>
 #include <asm/param.h>
@@ -1401,7 +1418,11 @@
 	prstatus->pr_sigpend = p->pending.signal.sig[0];
 	prstatus->pr_sighold = p->blocked.sig[0];
 	prstatus->pr_pid = task_pid_vnr(p);
+#ifdef CONFIG_KRG_EPM
+	prstatus->pr_ppid = krg_get_real_parent_pid(p);
+#else
 	prstatus->pr_ppid = task_pid_vnr(p->real_parent);
+#endif
 	prstatus->pr_pgrp = task_pgrp_vnr(p);
 	prstatus->pr_sid = task_session_vnr(p);
 	if (thread_group_leader(p)) {
@@ -1446,7 +1467,11 @@
 	psinfo->pr_psargs[len] = 0;
 
 	psinfo->pr_pid = task_pid_vnr(p);
+#ifdef CONFIG_KRG_EPM
+	psinfo->pr_ppid = krg_get_real_parent_pid(p);
+#else
 	psinfo->pr_ppid = task_pid_vnr(p->real_parent);
+#endif
 	psinfo->pr_pgrp = task_pgrp_vnr(p);
 	psinfo->pr_sid = task_session_vnr(p);
 
--- fs/configfs/inode.c
+++ fs/configfs/inode.c
@@ -33,10 +33,15 @@
 #include <linux/backing-dev.h>
 #include <linux/capability.h>
 #include <linux/sched.h>
+#include <linux/lockdep.h>
 
 #include <linux/configfs.h>
 #include "configfs_internal.h"
 
+#ifdef CONFIG_LOCKDEP
+static struct lock_class_key default_group_class[MAX_LOCK_DEPTH];
+#endif
+
 extern struct super_block * configfs_sb;
 
 static const struct address_space_operations configfs_aops = {
@@ -150,6 +155,38 @@
 	return inode;
 }
 
+#ifdef CONFIG_LOCKDEP
+
+static void configfs_set_inode_lock_class(struct configfs_dirent *sd,
+					  struct inode *inode)
+{
+	int depth = sd->s_depth;
+
+	if (depth > 0) {
+		if (depth <= ARRAY_SIZE(default_group_class)) {
+			lockdep_set_class(&inode->i_mutex,
+					  &default_group_class[depth - 1]);
+		} else {
+			/*
+			 * In practice the maximum level of locking depth is
+			 * already reached. Just inform about possible reasons.
+			 */
+			printk(KERN_INFO "configfs: Too many levels of inodes"
+			       " for the locking correctness validator.\n");
+			printk(KERN_INFO "Spurious warnings may appear.\n");
+		}
+	}
+}
+
+#else /* CONFIG_LOCKDEP */
+
+static void configfs_set_inode_lock_class(struct configfs_dirent *sd,
+					  struct inode *inode)
+{
+}
+
+#endif /* CONFIG_LOCKDEP */
+
 int configfs_create(struct dentry * dentry, int mode, int (*init)(struct inode *))
 {
 	int error = 0;
@@ -162,6 +199,7 @@
 					struct inode *p_inode = dentry->d_parent->d_inode;
 					p_inode->i_mtime = p_inode->i_ctime = CURRENT_TIME;
 				}
+				configfs_set_inode_lock_class(sd, inode);
 				goto Proceed;
 			}
 			else
--- fs/configfs/dir.c
+++ fs/configfs/dir.c
@@ -78,11 +78,97 @@
 	.d_delete	= configfs_d_delete,
 };
 
+#ifdef CONFIG_LOCKDEP
+
+/*
+ * Helpers to make lockdep happy with our recursive locking of default groups'
+ * inodes (see configfs_attach_group() and configfs_detach_group()).
+ * We put default groups i_mutexes in separate classes according to their depth
+ * from the youngest non-default group ancestor.
+ *
+ * For a non-default group A having default groups A/B, A/C, and A/C/D, default
+ * groups A/B and A/C will have their inode's mutex in class
+ * default_group_class[0], and default group A/C/D will be in
+ * default_group_class[1].
+ *
+ * The lock classes are declared and assigned in inode.c, according to the
+ * s_depth value.
+ * The s_depth value is initialized to -1, adjusted to >= 0 when attaching
+ * default groups, and reset to -1 when all default groups are attached. During
+ * attachment, if configfs_create() sees s_depth > 0, the lock class of the new
+ * inode's mutex is set to default_group_class[s_depth - 1].
+ */
+
+static void configfs_init_dirent_depth(struct configfs_dirent *sd)
+{
+	sd->s_depth = -1;
+}
+
+static void configfs_set_dir_dirent_depth(struct configfs_dirent *parent_sd,
+					  struct configfs_dirent *sd)
+{
+	int parent_depth = parent_sd->s_depth;
+
+	if (parent_depth >= 0)
+		sd->s_depth = parent_depth + 1;
+}
+
+static void
+configfs_adjust_dir_dirent_depth_before_populate(struct configfs_dirent *sd)
+{
+	/*
+	 * item's i_mutex class is already setup, so s_depth is now only
+	 * used to set new sub-directories s_depth, which is always done
+	 * with item's i_mutex locked.
+	 */
+	/*
+	 *  sd->s_depth == -1 iff we are a non default group.
+	 *  else (we are a default group) sd->s_depth > 0 (see
+	 *  create_dir()).
+	 */
+	if (sd->s_depth == -1)
+		/*
+		 * We are a non default group and we are going to create
+		 * default groups.
+		 */
+		sd->s_depth = 0;
+}
+
+static void
+configfs_adjust_dir_dirent_depth_after_populate(struct configfs_dirent *sd)
+{
+	/* We will not create default groups anymore. */
+	sd->s_depth = -1;
+}
+
+#else /* CONFIG_LOCKDEP */
+
+static void configfs_init_dirent_depth(struct configfs_dirent *sd)
+{
+}
+
+static void configfs_set_dir_dirent_depth(struct configfs_dirent *parent_sd,
+					  struct configfs_dirent *sd)
+{
+}
+
+static void
+configfs_adjust_dir_dirent_depth_before_populate(struct configfs_dirent *sd)
+{
+}
+
+static void
+configfs_adjust_dir_dirent_depth_after_populate(struct configfs_dirent *sd)
+{
+}
+
+#endif /* CONFIG_LOCKDEP */
+
 /*
  * Allocates a new configfs_dirent and links it to the parent configfs_dirent
  */
-static struct configfs_dirent *configfs_new_dirent(struct configfs_dirent * parent_sd,
-						void * element)
+static struct configfs_dirent *configfs_new_dirent(struct configfs_dirent *parent_sd,
+						   void *element, int type)
 {
 	struct configfs_dirent * sd;
 
@@ -94,6 +180,8 @@
 	INIT_LIST_HEAD(&sd->s_links);
 	INIT_LIST_HEAD(&sd->s_children);
 	sd->s_element = element;
+	sd->s_type = type;
+	configfs_init_dirent_depth(sd);
 	spin_lock(&configfs_dirent_lock);
 	if (parent_sd->s_type & CONFIGFS_USET_DROPPING) {
 		spin_unlock(&configfs_dirent_lock);
@@ -138,12 +226,11 @@
 {
 	struct configfs_dirent * sd;
 
-	sd = configfs_new_dirent(parent_sd, element);
+	sd = configfs_new_dirent(parent_sd, element, type);
 	if (IS_ERR(sd))
 		return PTR_ERR(sd);
 
 	sd->s_mode = mode;
-	sd->s_type = type;
 	sd->s_dentry = dentry;
 	if (dentry) {
 		dentry->d_fsdata = configfs_get(sd);
@@ -187,6 +274,7 @@
 		error = configfs_make_dirent(p->d_fsdata, d, k, mode,
 					     CONFIGFS_DIR | CONFIGFS_USET_CREATING);
 	if (!error) {
+		configfs_set_dir_dirent_depth(p->d_fsdata, d->d_fsdata);
 		error = configfs_create(d, mode, init_dir);
 		if (!error) {
 			inc_nlink(p->d_inode);
@@ -789,11 +877,13 @@
 		 * error, as rmdir() would.
 		 */
 		mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);
+		configfs_adjust_dir_dirent_depth_before_populate(sd);
 		ret = populate_groups(to_config_group(item));
 		if (ret) {
 			configfs_detach_item(item);
 			dentry->d_inode->i_flags |= S_DEAD;
 		}
+		configfs_adjust_dir_dirent_depth_after_populate(sd);
 		mutex_unlock(&dentry->d_inode->i_mutex);
 		if (ret)
 			d_delete(dentry);
@@ -916,11 +1006,11 @@
  * Note, btw, that this can be called at *any* time, even when a configfs
  * subsystem isn't registered, or when configfs is loading or unloading.
  * Just like configfs_register_subsystem().  So we take the same
- * precautions.  We pin the filesystem.  We lock each i_mutex _in_order_
- * on our way down the tree.  If we can find the target item in the
+ * precautions.  We pin the filesystem.  We lock configfs_dirent_lock.
+ * If we can find the target item in the
  * configfs tree, it must be part of the subsystem tree as well, so we
- * do not need the subsystem semaphore.  Holding the i_mutex chain locks
- * out mkdir() and rmdir(), who might be racing us.
+ * do not need the subsystem semaphore.  Holding configfs_dirent_lock helps
+ * locking out mkdir() and rmdir(), who might be racing us.
  */
 
 /*
@@ -933,17 +1023,21 @@
  * do that so we can unlock it if we find nothing.
  *
  * Here we do a depth-first search of the dentry hierarchy looking for
- * our object.  We take i_mutex on each step of the way down.  IT IS
- * ESSENTIAL THAT i_mutex LOCKING IS ORDERED.  If we come back up a branch,
- * we'll drop the i_mutex.
+ * our object.
+ * We deliberately ignore items tagged as dropping since they are virtually
+ * dead, as well as items in the middle of attachment since they virtually
+ * do not exist yet. This completes the locking out of racing mkdir() and
+ * rmdir().
+ * Note: subdirectories in the middle of attachment start with s_type =
+ * CONFIGFS_DIR|CONFIGFS_USET_CREATING set by create_dir().  When
+ * CONFIGFS_USET_CREATING is set, we ignore the item.  The actual set of
+ * s_type is in configfs_new_dirent(), which has configfs_dirent_lock.
  *
- * If the target is not found, -ENOENT is bubbled up and we have released
- * all locks.  If the target was found, the locks will be cleared by
- * configfs_depend_rollback().
+ * If the target is not found, -ENOENT is bubbled up.
  *
  * This adds a requirement that all config_items be unique!
  *
- * This is recursive because the locking traversal is tricky.  There isn't
+ * This is recursive.  There isn't
  * much on the stack, though, so folks that need this function - be careful
  * about your stack!  Patches will be accepted to make it iterative.
  */
@@ -955,13 +1049,13 @@
 
 	BUG_ON(!origin || !sd);
 
-	/* Lock this guy on the way down */
-	mutex_lock(&sd->s_dentry->d_inode->i_mutex);
 	if (sd->s_element == target)  /* Boo-yah */
 		goto out;
 
 	list_for_each_entry(child_sd, &sd->s_children, s_sibling) {
-		if (child_sd->s_type & CONFIGFS_DIR) {
+		if ((child_sd->s_type & CONFIGFS_DIR) &&
+		    !(child_sd->s_type & CONFIGFS_USET_DROPPING) &&
+		    !(child_sd->s_type & CONFIGFS_USET_CREATING)) {
 			ret = configfs_depend_prep(child_sd->s_dentry,
 						   target);
 			if (!ret)
@@ -970,33 +1064,12 @@
 	}
 
 	/* We looped all our children and didn't find target */
-	mutex_unlock(&sd->s_dentry->d_inode->i_mutex);
 	ret = -ENOENT;
 
 out:
 	return ret;
 }
 
-/*
- * This is ONLY called if configfs_depend_prep() did its job.  So we can
- * trust the entire path from item back up to origin.
- *
- * We walk backwards from item, unlocking each i_mutex.  We finish by
- * unlocking origin.
- */
-static void configfs_depend_rollback(struct dentry *origin,
-				     struct config_item *item)
-{
-	struct dentry *dentry = item->ci_dentry;
-
-	while (dentry != origin) {
-		mutex_unlock(&dentry->d_inode->i_mutex);
-		dentry = dentry->d_parent;
-	}
-
-	mutex_unlock(&origin->d_inode->i_mutex);
-}
-
 int configfs_depend_item(struct configfs_subsystem *subsys,
 			 struct config_item *target)
 {
@@ -1037,17 +1110,21 @@
 
 	/* Ok, now we can trust subsys/s_item */
 
-	/* Scan the tree, locking i_mutex recursively, return 0 if found */
+	spin_lock(&configfs_dirent_lock);
+	/* Scan the tree, return 0 if found */
 	ret = configfs_depend_prep(subsys_sd->s_dentry, target);
 	if (ret)
-		goto out_unlock_fs;
+		goto out_unlock_dirent_lock;
 
-	/* We hold all i_mutexes from the subsystem down to the target */
+	/*
+	 * We are sure that the item is not about to be removed by rmdir(), and
+	 * not in the middle of attachment by mkdir().
+	 */
 	p = target->ci_dentry->d_fsdata;
 	p->s_dependent_count += 1;
 
-	configfs_depend_rollback(subsys_sd->s_dentry, target);
-
+out_unlock_dirent_lock:
+	spin_unlock(&configfs_dirent_lock);
 out_unlock_fs:
 	mutex_unlock(&configfs_sb->s_root->d_inode->i_mutex);
 
@@ -1072,10 +1149,10 @@
 	struct configfs_dirent *sd;
 
 	/*
-	 * Since we can trust everything is pinned, we just need i_mutex
-	 * on the item.
+	 * Since we can trust everything is pinned, we just need
+	 * configfs_dirent_lock.
 	 */
-	mutex_lock(&target->ci_dentry->d_inode->i_mutex);
+	spin_lock(&configfs_dirent_lock);
 
 	sd = target->ci_dentry->d_fsdata;
 	BUG_ON(sd->s_dependent_count < 1);
@@ -1086,7 +1163,7 @@
 	 * After this unlock, we cannot trust the item to stay alive!
 	 * DO NOT REFERENCE item after this unlock.
 	 */
-	mutex_unlock(&target->ci_dentry->d_inode->i_mutex);
+	spin_unlock(&configfs_dirent_lock);
 }
 EXPORT_SYMBOL(configfs_undepend_item);
 
@@ -1286,13 +1363,6 @@
 	if (sd->s_type & CONFIGFS_USET_DEFAULT)
 		return -EPERM;
 
-	/*
-	 * Here's where we check for dependents.  We're protected by
-	 * i_mutex.
-	 */
-	if (sd->s_dependent_count)
-		return -EBUSY;
-
 	/* Get a working ref until we have the child */
 	parent_item = configfs_get_config_item(dentry->d_parent);
 	subsys = to_config_group(parent_item)->cg_subsys;
@@ -1303,6 +1373,24 @@
 		return -EINVAL;
 	}
 
+#ifdef CONFIG_KRG_SCHED
+	/* Get a working ref for the duration of this function */
+	item = configfs_get_config_item(dentry);
+
+	/* Drop reference from above, item already holds one. */
+	config_item_put(parent_item);
+
+	if (parent_item->ci_type->ct_group_ops
+	    && parent_item->ci_type->ct_group_ops->allow_drop_item) {
+		ret = parent_item->ci_type->ct_group_ops->allow_drop_item(
+			to_config_group(parent_item), item);
+		if (ret) {
+			config_item_put(item);
+			return ret;
+		}
+	}
+#endif
+
 	/* configfs_mkdir() shouldn't have allowed this */
 	BUG_ON(!subsys->su_group.cg_item.ci_type);
 	subsys_owner = subsys->su_group.cg_item.ci_type->ct_owner;
@@ -1316,15 +1404,27 @@
 
 		mutex_lock(&configfs_symlink_mutex);
 		spin_lock(&configfs_dirent_lock);
-		ret = configfs_detach_prep(dentry, &wait_mutex);
-		if (ret)
-			configfs_detach_rollback(dentry);
+		/*
+		 * Here's where we check for dependents.  We're protected by
+		 * configfs_dirent_lock.
+		 * If no dependent, atomically tag the item as dropping.
+		 */
+		ret = sd->s_dependent_count ? -EBUSY : 0;
+		if (!ret) {
+			ret = configfs_detach_prep(dentry, &wait_mutex);
+			if (ret)
+				configfs_detach_rollback(dentry);
+		}
 		spin_unlock(&configfs_dirent_lock);
 		mutex_unlock(&configfs_symlink_mutex);
 
 		if (ret) {
 			if (ret != -EAGAIN) {
+#ifdef CONFIG_KRG_SCHED
+				config_item_put(item);
+#else
 				config_item_put(parent_item);
+#endif
 				return ret;
 			}
 
@@ -1334,11 +1434,13 @@
 		}
 	} while (ret == -EAGAIN);
 
+#ifndef CONFIG_KRG_SCHED
 	/* Get a working ref for the duration of this function */
 	item = configfs_get_config_item(dentry);
 
 	/* Drop reference from above, item already holds one. */
 	config_item_put(parent_item);
+#endif
 
 	if (item->ci_type)
 		dead_item_owner = item->ci_type->ct_owner;
@@ -1429,7 +1531,7 @@
 	 */
 	err = -ENOENT;
 	if (configfs_dirent_is_ready(parent_sd)) {
-		file->private_data = configfs_new_dirent(parent_sd, NULL);
+		file->private_data = configfs_new_dirent(parent_sd, NULL, 0);
 		if (IS_ERR(file->private_data))
 			err = PTR_ERR(file->private_data);
 		else
--- fs/configfs/configfs_internal.h
+++ fs/configfs/configfs_internal.h
@@ -39,6 +39,9 @@
 	umode_t			s_mode;
 	struct dentry		* s_dentry;
 	struct iattr		* s_iattr;
+#ifdef CONFIG_LOCKDEP
+	int			s_depth;
+#endif
 };
 
 #define CONFIGFS_ROOT		0x0001
--- fs/select.c
+++ fs/select.c
@@ -25,6 +25,12 @@
 #include <linux/fs.h>
 #include <linux/rcupdate.h>
 #include <linux/hrtimer.h>
+#ifdef CONFIG_KRG_FAF
+#include <kerrighed/faf.h>
+#endif
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/krgsyms.h>
+#endif
 
 #include <asm/uaccess.h>
 
@@ -226,13 +257,33 @@
 	struct poll_wqueues *pwq = container_of(p, struct poll_wqueues, pt);
 	struct poll_table_entry *entry = poll_get_entry(pwq);
 	if (!entry)
+#ifndef CONFIG_KRG_FAF
 		return;
+#else
+	        goto check_faf;
+#endif
 	get_file(filp);
 	entry->filp = filp;
 	entry->wait_address = wait_address;
 	init_waitqueue_func_entry(&entry->wait, pollwake);
 	entry->wait.private = pwq;
 	add_wait_queue(wait_address, &entry->wait);
+#ifdef CONFIG_KRG_FAF
+check_faf:
+	if (filp->f_flags & O_FAF_CLT) {
+		if (krg_faf_poll_wait(filp, entry != NULL)) {
+			if (entry) {
+				/*
+				 * Don't call free_poll_entry() since it would
+				 * call krg_faf_poll_dequeue().
+				 */
+				remove_wait_queue(wait_address, &entry->wait);
+				fput(filp);
+				poll_put_entry(p, entry);
+			}
+		}
+	}
+#endif
 }
 
 int poll_schedule_timeout(struct poll_wqueues *pwq, int state,
--- fs/aio.c
+++ fs/aio.c
@@ -614,7 +614,10 @@
  *	(Note: this routine is intended to be called only
  *	from a kernel thread context)
  */
-static void use_mm(struct mm_struct *mm)
+#ifndef CONFIG_KRG_FAF
+static
+#endif
+void use_mm(struct mm_struct *mm)
 {
 	struct mm_struct *active_mm;
 	struct task_struct *tsk = current;
@@ -638,7 +641,10 @@
  *	(Note: this routine is intended to be called only
  *	from a kernel thread context)
  */
-static void unuse_mm(struct mm_struct *mm)
+#ifndef CONFIG_KRG_FAF
+static
+#endif
+void unuse_mm(struct mm_struct *mm)
 {
 	struct task_struct *tsk = current;
 
--- fs/nfs/inode.c
+++ fs/nfs/inode.c
@@ -37,6 +37,9 @@
 #include <linux/vfs.h>
 #include <linux/inet.h>
 #include <linux/nfs_xdr.h>
+#ifdef CONFIG_KRG_MM
+#include <kerrighed/krgsyms.h>
+#endif
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -1507,6 +1516,10 @@
 out6:
 	nfs_fscache_unregister();
 out7:
+#ifdef CONFIG_KRG_MM
+	krgsyms_unregister(KRGSYMS_VM_OPS_NFS_FILE);
+out8:
+#endif
 	return err;
 }
 
--- fs/nfs/file.c
+++ fs/nfs/file.c
@@ -48,6 +48,9 @@
 					size_t count, unsigned int flags);
 static ssize_t nfs_file_read(struct kiocb *, const struct iovec *iov,
 				unsigned long nr_segs, loff_t pos);
+static ssize_t nfs_file_splice_write(struct pipe_inode_info *pipe,
+					struct file *filp, loff_t *ppos,
+					size_t count, unsigned int flags);
 static ssize_t nfs_file_write(struct kiocb *, const struct iovec *iov,
 				unsigned long nr_segs, loff_t pos);
 static int  nfs_file_flush(struct file *, fl_owner_t id);
@@ -57,7 +60,9 @@
 static int nfs_flock(struct file *filp, int cmd, struct file_lock *fl);
 static int nfs_setlease(struct file *file, long arg, struct file_lock **fl);
 
+#ifndef CONFIG_KRG_MM
 static struct vm_operations_struct nfs_file_vm_ops;
+#endif
 
 const struct file_operations nfs_file_operations = {
 	.llseek		= nfs_file_llseek,
@@ -73,6 +78,7 @@
 	.lock		= nfs_lock,
 	.flock		= nfs_flock,
 	.splice_read	= nfs_file_splice_read,
+	.splice_write	= nfs_file_splice_write,
 	.check_flags	= nfs_check_flags,
 	.setlease	= nfs_setlease,
 };
@@ -523,7 +529,10 @@
 	return VM_FAULT_SIGBUS;
 }
 
-static struct vm_operations_struct nfs_file_vm_ops = {
+#ifndef CONFIG_KRG_MM
+static
+#endif
+struct vm_operations_struct nfs_file_vm_ops = {
 	.fault = filemap_fault,
 	.page_mkwrite = nfs_vm_page_mkwrite,
 };
@@ -587,6 +596,33 @@
 	goto out;
 }
 
+static ssize_t nfs_file_splice_write(struct pipe_inode_info *pipe,
+				     struct file *filp, loff_t *ppos,
+				     size_t count, unsigned int flags)
+{
+	struct dentry *dentry = filp->f_path.dentry;
+	struct inode *inode = dentry->d_inode;
+	ssize_t ret;
+
+	dprintk("NFS splice_write(%s/%s, %lu@%llu)\n",
+		dentry->d_parent->d_name.name, dentry->d_name.name,
+		(unsigned long) count, (unsigned long long) *ppos);
+
+	/*
+	 * The combination of splice and an O_APPEND destination is disallowed.
+	 */
+
+	nfs_add_stats(inode, NFSIOS_NORMALWRITTENBYTES, count);
+
+	ret = generic_file_splice_write(pipe, filp, ppos, count, flags);
+	if (ret >= 0 && nfs_need_sync_write(filp, inode)) {
+		int err = nfs_do_fsync(nfs_file_open_context(filp), inode);
+		if (err < 0)
+			ret = err;
+	}
+	return ret;
+}
+
 static int do_getlk(struct file *filp, int cmd, struct file_lock *fl)
 {
 	struct inode *inode = filp->f_mapping->host;
--- fs/fcntl.c
+++ fs/fcntl.c
@@ -20,6 +20,9 @@
 #include <linux/rcupdate.h>
 #include <linux/pid_namespace.h>
 #include <linux/smp_lock.h>
+#ifdef CONFIG_KRG_FAF
+#include <kerrighed/faf.h>
+#endif
 
 #include <asm/poll.h>
 #include <asm/siginfo.h>
--- Makefile
+++ Makefile
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 30
-EXTRAVERSION =
+EXTRAVERSION = -krg
 NAME = Man-Eating Seals of Antiquity
 
 # *DOCUMENTATION*
--- ipc/sem.c
+++ ipc/sem.c
@@ -86,13 +86,29 @@
 
 #include <asm/uaccess.h>
 #include "util.h"
+#ifdef CONFIG_KRG_IPC
+#include <linux/random.h>
+#include <kerrighed/pid.h>
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/action.h>
+#endif
+#include "krgsem.h"
+#endif
+
+#ifdef CONFIG_KRG_IPC
+#define assert_mutex_locked(x) BUG_ON(!mutex_is_locked(x))
+#endif
 
 #define sem_ids(ns)	((ns)->ids[IPC_SEM_IDS])
 
+#ifndef CONFIG_KRG_IPC
 #define sem_unlock(sma)		ipc_unlock(&(sma)->sem_perm)
+#endif
 #define sem_checkid(sma, semid)	ipc_checkid(&sma->sem_perm, semid)
 
+#ifndef CONFIG_KRG_IPC
 static int newary(struct ipc_namespace *, struct ipc_params *);
+#endif
 static void freeary(struct ipc_namespace *, struct kern_ipc_perm *);
 #ifdef CONFIG_PROC_FS
 static int sysvipc_sem_proc_show(struct seq_file *s, void *it);
@@ -129,6 +145,7 @@
 void sem_exit_ns(struct ipc_namespace *ns)
 {
 	free_ipcs(ns, &sem_ids(ns), freeary);
+	idr_destroy(&ns->ids[IPC_SEM_IDS].ipcs_idr);
 }
 #endif
 
@@ -144,7 +161,11 @@
  * sem_lock_(check_) routines are called in the paths where the rw_mutex
  * is not held.
  */
+#ifdef CONFIG_KRG_IPC
+struct sem_array *sem_lock(struct ipc_namespace *ns, int id)
+#else
 static inline struct sem_array *sem_lock(struct ipc_namespace *ns, int id)
+#endif
 {
 	struct kern_ipc_perm *ipcp = ipc_lock(&sem_ids(ns), id);
 
@@ -154,7 +175,10 @@
 	return container_of(ipcp, struct sem_array, sem_perm);
 }
 
-static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,
+#ifndef CONFIG_KRG_IPC
+static inline
+#endif
+struct sem_array *sem_lock_check(struct ipc_namespace *ns,
 						int id)
 {
 	struct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);
@@ -285,6 +318,20 @@
 	INIT_LIST_HEAD(&sma->list_id);
 	sma->sem_nsems = nsems;
 	sma->sem_ctime = get_seconds();
+#ifdef CONFIG_KRG_IPC
+	INIT_LIST_HEAD(&sma->remote_sem_pending);
+
+	if (is_krg_ipc(&sem_ids(ns))) {
+		retval = krg_ipc_sem_newary(ns, sma);
+		if (retval) {
+			security_sem_free(sma);
+			ipc_rcu_putref(sma);
+			return retval;
+		}
+	} else
+
+	sma->sem_perm.krgops = NULL;
+#endif
 	sem_unlock(sma);
 
 	return sma->sem_perm.id;
@@ -414,8 +461,27 @@
 	int error;
 	struct sem_queue * q;
 
+#ifdef CONFIG_KRG_IPC
+	/* the following is used to ensure that a node would not
+	   keep the sem for it */
+	int remote = 0, loop = 0;
+	if (sma->sem_perm.krgops) {
+		remote = get_random_int()%2;
+		loop = 1;
+	}
+begin:
+	if (remote)
+		q = list_entry(sma->remote_sem_pending.next, struct sem_queue, list);
+	else
+#endif
+
 	q = list_entry(sma->sem_pending.next, struct sem_queue, list);
+#ifdef CONFIG_KRG_IPC
+	while ((!remote && &q->list != &sma->sem_pending)
+	       || (remote && &q->list != &sma->remote_sem_pending)) {
+#else
 	while (&q->list != &sma->sem_pending) {
+#endif
 		error = try_atomic_semop(sma, q->sops, q->nsops,
 					 q->undo, q->pid);
 
@@ -442,6 +508,12 @@
 			 */
 			if (q->alter) {
 				list_del(&q->list);
+#ifdef CONFIG_KRG_IPC
+				if (remote)
+					n = list_entry(sma->remote_sem_pending.next,
+						       struct sem_queue, list);
+				else
+#endif
 				n = list_entry(sma->sem_pending.next,
 						struct sem_queue, list);
 			} else {
@@ -453,6 +525,11 @@
 			/* wake up the waiting thread */
 			q->status = IN_WAKEUP;
 
+#ifdef CONFIG_KRG_IPC
+			if (remote)
+				krg_ipc_sem_wakeup_process(q, error);
+			else
+#endif
 			wake_up_process(q->sleeper);
 			/* hands-off: q will disappear immediately after
 			 * writing q->status.
@@ -498,6 +582,18 @@
 			    && !(sops[i].sem_flg & IPC_NOWAIT))
 				semncnt++;
 	}
+#ifdef CONFIG_KRG_IPC
+	list_for_each_entry(q, &sma->remote_sem_pending, list) {
+		struct sembuf * sops = q->sops;
+		int nsops = q->nsops;
+		int i;
+		for (i = 0; i < nsops; i++)
+			if (sops[i].sem_num == semnum
+			    && (sops[i].sem_op < 0)
+			    && !(sops[i].sem_flg & IPC_NOWAIT))
+				semncnt++;
+	}
+#endif
 	return semncnt;
 }
 
@@ -517,6 +613,18 @@
 			    && !(sops[i].sem_flg & IPC_NOWAIT))
 				semzcnt++;
 	}
+#ifdef CONFIG_KRG_IPC
+	list_for_each_entry(q, &sma->remote_sem_pending, list) {
+		struct sembuf * sops = q->sops;
+		int nsops = q->nsops;
+		int i;
+		for (i = 0; i < nsops; i++)
+			if (sops[i].sem_num == semnum
+			    && (sops[i].sem_op == 0)
+			    && !(sops[i].sem_flg & IPC_NOWAIT))
+				semzcnt++;
+	}
+#endif
 	return semzcnt;
 }
 
@@ -530,14 +638,35 @@
  * as a writer and the spinlock for this semaphore set hold. sem_ids.rw_mutex
  * remains locked on exit.
  */
+#ifdef CONFIG_KRG_IPC
 static void freeary(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp)
 {
+	if (is_krg_ipc(&sem_ids(ns)))
+		krg_ipc_sem_freeary(ns, ipcp);
+	else
+		local_freeary(ns, ipcp);
+}
+
+void local_freeary(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp)
+#else
+static void freeary(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp)
+#endif
+{
 	struct sem_undo *un, *tu;
 	struct sem_queue *q, *tq;
 	struct sem_array *sma = container_of(ipcp, struct sem_array, sem_perm);
 
+#ifdef CONFIG_KRG_IPC
+	if (is_krg_ipc(&sem_ids(ns)))
+		BUG_ON(!list_empty(&sma->list_id));
+#endif
+
 	/* Free the existing undo structures for this semaphore set.  */
+#ifdef CONFIG_KRG_IPC
+	assert_mutex_locked(&sma->sem_perm.mutex);
+#else
 	assert_spin_locked(&sma->sem_perm.lock);
+#endif
 	list_for_each_entry_safe(un, tu, &sma->list_id, list_id) {
 		list_del(&un->list_id);
 		spin_lock(&un->ulp->lock);
@@ -556,10 +685,26 @@
 		smp_wmb();
 		q->status = -EIDRM;	/* hands-off q */
 	}
+#ifdef CONFIG_KRG_IPC
+	list_for_each_entry_safe(q, tq, &sma->remote_sem_pending, list) {
+		list_del(&q->list);
+
+		/* __freeary is called on every nodes where the semarray exists:
+		 * no need to care about remote pending processes */
+		if (q->undo)
+			kfree(q->undo);
+
+		free_semqueue(q);
+	}
+#endif
 
 	/* Remove the semaphore set from the IDR */
 	sem_rmid(ns, sma);
+#ifdef CONFIG_KRG_IPC
+	local_sem_unlock(sma);
+#else
 	sem_unlock(sma);
+#endif
 
 	ns->used_sems -= sma->sem_nsems;
 	security_sem_free(sma);
@@ -634,15 +779,32 @@
 		struct semid64_ds tbuf;
 		int id;
 
+#ifdef CONFIG_KRG_IPC
+		down_read(&sem_ids(ns).rw_mutex);
+#endif
 		if (cmd == SEM_STAT) {
 			sma = sem_lock(ns, semid);
 			if (IS_ERR(sma))
+#ifdef CONFIG_KRG_IPC
+			{
+				up_read(&sem_ids(ns).rw_mutex);
 				return PTR_ERR(sma);
+			}
+#else
+				return PTR_ERR(sma);
+#endif
 			id = sma->sem_perm.id;
 		} else {
 			sma = sem_lock_check(ns, semid);
 			if (IS_ERR(sma))
+#ifdef CONFIG_KRG_IPC
+			{
+				up_read(&sem_ids(ns).rw_mutex);
+				return PTR_ERR(sma);
+			}
+#else
 				return PTR_ERR(sma);
+#endif
 			id = 0;
 		}
 
@@ -661,6 +823,9 @@
 		tbuf.sem_ctime  = sma->sem_ctime;
 		tbuf.sem_nsems  = sma->sem_nsems;
 		sem_unlock(sma);
+#ifdef CONFIG_KRG_IPC
+		up_read(&sem_ids(ns).rw_mutex);
+#endif
 		if (copy_semid_to_user (arg.buf, &tbuf, version))
 			return -EFAULT;
 		return id;
@@ -671,6 +836,9 @@
 	return err;
 out_unlock:
 	sem_unlock(sma);
+#ifdef CONFIG_KRG_IPC
+	up_read(&sem_ids(ns).rw_mutex);
+#endif
 	return err;
 }
 
@@ -684,9 +852,19 @@
 	ushort* sem_io = fast_sem_io;
 	int nsems;
 
+#ifdef CONFIG_KRG_IPC
+	down_read(&sem_ids(ns).rw_mutex);
+#endif
 	sma = sem_lock_check(ns, semid);
 	if (IS_ERR(sma))
+#ifdef CONFIG_KRG_IPC
+	{
+		up_read(&sem_ids(ns).rw_mutex);
+		return PTR_ERR(sma);
+	}
+#else
 		return PTR_ERR(sma);
+#endif
 
 	nsems = sma->sem_nsems;
 
@@ -706,10 +884,18 @@
 		int i;
 
 		if(nsems > SEMMSL_FAST) {
+#ifndef CONFIG_KRG_IPC
 			sem_getref_and_unlock(sma);
+#endif
 
 			sem_io = ipc_alloc(sizeof(ushort)*nsems);
 			if(sem_io == NULL) {
+#ifdef CONFIG_KRG_IPC
+				err = -ENOMEM;
+				goto out_unlock;
+			}
+			BUG_ON(sma->sem_perm.deleted);
+#else
 				sem_putref(sma);
 				return -ENOMEM;
 			}
@@ -735,41 +922,65 @@
 	{
 		int i;
 		struct sem_undo *un;
-
+#ifndef CONFIG_KRG_IPC
 		sem_getref_and_unlock(sma);
+#endif
 
 		if(nsems > SEMMSL_FAST) {
 			sem_io = ipc_alloc(sizeof(ushort)*nsems);
 			if(sem_io == NULL) {
+#ifdef CONFIG_KRG_IPC
+				err = -ENOMEM;
+				goto out_unlock;
+#else
 				sem_putref(sma);
 				return -ENOMEM;
+#endif
 			}
 		}
 
 		if (copy_from_user (sem_io, arg.array, nsems*sizeof(ushort))) {
+#ifdef CONFIG_KRG_IPC
+			err = -EFAULT;
+			goto out_unlock;
+#else
 			sem_putref(sma);
 			err = -EFAULT;
 			goto out_free;
+#endif
 		}
 
 		for (i = 0; i < nsems; i++) {
 			if (sem_io[i] > SEMVMX) {
+#ifdef CONFIG_KRG_IPC
+				err = -ERANGE;
+				goto out_unlock;
+#else
 				sem_putref(sma);
 				err = -ERANGE;
 				goto out_free;
+#endif
 			}
 		}
+#ifdef CONFIG_KRG_IPC
+		BUG_ON(sma->sem_perm.deleted);
+#else
 		sem_lock_and_putref(sma);
 		if (sma->sem_perm.deleted) {
 			sem_unlock(sma);
 			err = -EIDRM;
 			goto out_free;
 		}
+#endif
 
 		for (i = 0; i < nsems; i++)
 			sma->sem_base[i].semval = sem_io[i];
 
+#ifdef CONFIG_KRG_IPC
+		assert_mutex_locked(&sma->sem_perm.mutex);
+#else
 		assert_spin_locked(&sma->sem_perm.lock);
+#endif
 		list_for_each_entry(un, &sma->list_id, list_id) {
 			for (i = 0; i < nsems; i++)
 				un->semadj[i] = 0;
@@ -810,7 +1021,12 @@
 		if (val > SEMVMX || val < 0)
 			goto out_unlock;
 
+
+#ifdef CONFIG_KRG_IPC
+		assert_mutex_locked(&sma->sem_perm.mutex);
+#else
 		assert_spin_locked(&sma->sem_perm.lock);
+#endif
 		list_for_each_entry(un, &sma->list_id, list_id)
 			un->semadj[semnum] = 0;
 
@@ -1025,20 +1244,41 @@
 
 	/* no undo structure around - allocate one. */
 	/* step 1: figure out the size of the semaphore array */
+#ifdef CONFIG_KRG_IPC
+	down_read(&sem_ids(ns).rw_mutex);
+#endif
 	sma = sem_lock_check(ns, semid);
 	if (IS_ERR(sma))
+#ifdef CONFIG_KRG_IPC
+	{
+		up_read(&sem_ids(ns).rw_mutex);
+		return ERR_PTR(PTR_ERR(sma));
+	}
+#else
 		return ERR_PTR(PTR_ERR(sma));
+#endif
 
 	nsems = sma->sem_nsems;
+
+#ifndef CONFIG_KRG_IPC
 	sem_getref_and_unlock(sma);
+#endif
 
 	/* step 2: allocate new undo structure */
 	new = kzalloc(sizeof(struct sem_undo) + sizeof(short)*nsems, GFP_KERNEL);
 	if (!new) {
+#ifdef CONFIG_KRG_IPC
+		sem_unlock(sma);
+		up_read(&sem_ids(ns).rw_mutex);
+#else
 		sem_putref(sma);
+#endif
 		return ERR_PTR(-ENOMEM);
 	}
 
+#ifdef CONFIG_KRG_IPC
+	BUG_ON(sma->sem_perm.deleted);
+#else
 	/* step 3: Acquire the lock on semaphore array */
 	sem_lock_and_putref(sma);
 	if (sma->sem_perm.deleted) {
@@ -1076,6 +1321,9 @@
 	spin_unlock(&ulp->lock);
 	rcu_read_lock();
 	sem_unlock(sma);
+#ifdef CONFIG_KRG_IPC
+	up_read(&sem_ids(ns).rw_mutex);
+#endif
 out:
 	return un;
 }
@@ -1145,11 +1398,17 @@
 	} else
 		un = NULL;
 
+#ifdef CONFIG_KRG_IPC
+	down_read(&sem_ids(ns).rw_mutex);
+#endif
 	sma = sem_lock_check(ns, semid);
 	if (IS_ERR(sma)) {
 		if (un)
 			rcu_read_unlock();
 		error = PTR_ERR(sma);
+#ifdef CONFIG_KRG_IPC
+		up_read(&sem_ids(ns).rw_mutex);
+#endif
 		goto out_free;
 	}
 
@@ -1216,6 +1485,10 @@
 	queue.undo = un;
 	queue.pid = task_tgid_vnr(current);
 	queue.alter = alter;
+#ifdef CONFIG_KRG_IPC
+	queue.semid = sma->sem_perm.id;
+	queue.node = kerrighed_node_id;
+#endif
 	if (alter)
 		list_add_tail(&queue.list, &sma->sem_pending);
 	else
@@ -1225,6 +1498,9 @@
 	queue.sleeper = current;
 	current->state = TASK_INTERRUPTIBLE;
 	sem_unlock(sma);
+#ifdef CONFIG_KRG_IPC
+	up_read(&sem_ids(ns).rw_mutex);
+#endif
 
 	if (timeout)
 		jiffies_left = schedule_timeout(jiffies_left);
@@ -1243,12 +1519,30 @@
 		goto out_free;
 	}
 
+#ifdef CONFIG_KRG_IPC
+	down_read(&sem_ids(ns).rw_mutex);
+#endif
 	sma = sem_lock(ns, semid);
 	if (IS_ERR(sma)) {
 		error = -EIDRM;
+#ifdef CONFIG_KRG_IPC
+		up_read(&sem_ids(ns).rw_mutex);
+#endif
 		goto out_free;
 	}
 
+#if defined(CONFIG_KRG_IPC) && defined(CONFIG_KRG_EPM)
+	if (krg_action_any_pending(current)) {
+#ifdef CONFIG_KRG_DEBUG
+		printk("%s:%d - action kerrighed! --> need replay!!\n",
+		       __PRETTY_FUNCTION__, __LINE__);
+#endif
+		list_del(&queue.list);
+		error = -ERESTARTSYS;
+		goto out_unlock_free;
+	}
+#endif
+
 	/*
 	 * If queue.status != -EINTR we are woken up by another process
 	 */
@@ -1266,6 +1560,9 @@
 
 out_unlock_free:
 	sem_unlock(sma);
+#ifdef CONFIG_KRG_IPC
+	up_read(&sem_ids(ns).rw_mutex);
+#endif
 out_free:
 	if(sops != fast_sops)
 		kfree(sops);
@@ -1390,7 +1750,6 @@
 		struct sem_array *sma;
 		struct sem_undo *un;
 		int semid;
-		int i;
 
 		rcu_read_lock();
 		un = list_entry(rcu_dereference(ulp->list_proc.next),
@@ -1404,64 +1763,83 @@
 		if (semid == -1)
 			break;
 
+#ifdef CONFIG_KRG_IPC
+		down_read(&sem_ids(tsk->nsproxy->ipc_ns).rw_mutex);
+#endif
 		sma = sem_lock_check(tsk->nsproxy->ipc_ns, un->semid);
 
 		/* exit_sem raced with IPC_RMID, nothing to do */
 		if (IS_ERR(sma))
+#ifdef CONFIG_KRG_IPC
+		{
+			up_read(&sem_ids(tsk->nsproxy->ipc_ns).rw_mutex);
 			continue;
+		}
+#else
+			continue;
+#endif
 
 		un = lookup_undo(ulp, semid);
 		if (un == NULL) {
 			/* exit_sem raced with IPC_RMID+semget() that created
 			 * exactly the same semid. Nothing to do.
 			 */
+#ifdef CONFIG_KRG_IPC
+			up_read(&sem_ids(tsk->nsproxy->ipc_ns).rw_mutex);
+#endif
 			sem_unlock(sma);
 			continue;
 		}
 
 		/* remove un from the linked lists */
+#ifdef CONFIG_KRG_IPC
+		assert_mutex_locked(&sma->sem_perm.mutex);
+#else
 		assert_spin_locked(&sma->sem_perm.lock);
+#endif
+
 		list_del(&un->list_id);
 
 		spin_lock(&ulp->lock);
 		list_del_rcu(&un->list_proc);
 		spin_unlock(&ulp->lock);
 
-		/* perform adjustments registered in un */
-		for (i = 0; i < sma->sem_nsems; i++) {
-			struct sem * semaphore = &sma->sem_base[i];
-			if (un->semadj[i]) {
-				semaphore->semval += un->semadj[i];
-				/*
-				 * Range checks of the new semaphore value,
-				 * not defined by sus:
-				 * - Some unices ignore the undo entirely
-				 *   (e.g. HP UX 11i 11.22, Tru64 V5.1)
-				 * - some cap the value (e.g. FreeBSD caps
-				 *   at 0, but doesn't enforce SEMVMX)
-				 *
-				 * Linux caps the semaphore value, both at 0
-				 * and at SEMVMX.
-				 *
-				 * 	Manfred <manfred@colorfullife.com>
-				 */
-				if (semaphore->semval < 0)
-					semaphore->semval = 0;
-				if (semaphore->semval > SEMVMX)
-					semaphore->semval = SEMVMX;
-				semaphore->sempid = task_tgid_vnr(current);
-			}
-		}
-		sma->sem_otime = get_seconds();
-		/* maybe some queued-up processes were waiting for this */
-		update_queue(sma);
+		__exit_sem_found(sma, un);
 		sem_unlock(sma);
-
+#ifdef CONFIG_KRG_IPC
+		up_read(&sem_ids(tsk->nsproxy->ipc_ns).rw_mutex);
+#endif
 		call_rcu(&un->rcu, free_un);
 	}
 	kfree(ulp);
 }
 
+#ifdef CONFIG_KRG_IPC
+void exit_sem(struct task_struct *tsk)
+{
+	struct ipc_namespace *ipcns;
+	struct nsproxy *ns;
+
+	ns = task_nsproxy(tsk);
+	if (!ns) { /* it happens when cleaning a failing fork */
+		if (krg_current)
+			ns = task_nsproxy(krg_current);
+		else
+			ns = task_nsproxy(current);
+	}
+
+	ipcns = ns->ipc_ns;
+
+	if (is_krg_ipc(&sem_ids(ipcns)))
+		krg_ipc_sem_exit_sem(ipcns, tsk);
+
+	/* let call __exit_sem in case process has been created
+	 * before the Kerrighed loading
+	 */
+	__exit_sem(tsk);
+}
+#endif
+
 #ifdef CONFIG_PROC_FS
 static int sysvipc_sem_proc_show(struct seq_file *s, void *it)
 {
--- ipc/util.c
+++ ipc/util.c
@@ -398,14 +537,35 @@
 	if (ids->in_use >= size)
 		return -ENOSPC;
 
+#ifdef CONFIG_KRG_IPC
+	if (requested_id != -1)
+		return ipc_reserveid(ids, new, requested_id);
+#endif
+
+#ifdef CONFIG_KRG_IPC
+	mutex_init(&new->mutex);
+#else
 	spin_lock_init(&new->lock);
+#endif
 	new->deleted = 0;
 	rcu_read_lock();
+#ifdef CONFIG_KRG_IPC
+	mutex_lock(&new->mutex);
+#else
 	spin_lock(&new->lock);
+#endif
 
+#ifdef CONFIG_KRG_IPC
+	err = krg_idr_get_new(ids, new, &id);
+#else
 	err = idr_get_new(&ids->ipcs_idr, new, &id);
+#endif
 	if (err) {
+#ifdef CONFIG_KRG_IPC
+		mutex_unlock(&new->mutex);
+#else
 		spin_unlock(&new->lock);
+#endif
 		rcu_read_unlock();
 		return err;
 	}
@@ -888,8 +1109,11 @@
  *
  * The ipc object is locked on exit.
  */
-
+#ifdef CONFIG_KRG_IPC
+struct kern_ipc_perm *local_ipc_lock(struct ipc_ids *ids, int id)
+#else
 struct kern_ipc_perm *ipc_lock(struct ipc_ids *ids, int id)
+#endif
 {
 	struct kern_ipc_perm *out;
 	int lid = ipcid_to_idx(id);
@@ -900,14 +1124,21 @@
 		rcu_read_unlock();
 		return ERR_PTR(-EINVAL);
 	}
-
+#ifdef CONFIG_KRG_IPC
+	mutex_lock(&out->mutex);
+#else
 	spin_lock(&out->lock);
+#endif
 	
 	/* ipc_rmid() may have already freed the ID while ipc_lock
 	 * was spinning: here verify that the structure is still valid
 	 */
 	if (out->deleted) {
+#ifdef CONFIG_KRG_IPC
+		mutex_unlock(&out->mutex);
+#else
 		spin_unlock(&out->lock);
+#endif
 		rcu_read_unlock();
 		return ERR_PTR(-EINVAL);
 	}
--- ipc/msg.c
+++ ipc/msg.c
@@ -134,6 +143,7 @@
 void msg_exit_ns(struct ipc_namespace *ns)
 {
 	free_ipcs(ns, &msg_ids(ns), freeque);
+	idr_destroy(&ns->ids[IPC_MSG_IDS].ipcs_idr);
 }
 #endif
 
@@ -789,25 +897,54 @@
 			goto out_unlock_free;
 		}
 		ss_add(msq, &s);
+#ifndef CONFIG_KRG_IPC
 		ipc_rcu_getref(msq);
+#endif
 		msg_unlock(msq);
+#ifdef CONFIG_KRG_IPC
+		up_read(&msg_ids(ns).rw_mutex);
+#endif
+
 		schedule();
 
+#ifdef CONFIG_KRG_IPC
+		down_read(&msg_ids(ns).rw_mutex);
+		msq = msg_lock_check(ns, msqid);
+		if (IS_ERR(msq)) {
+			err = -EIDRM;
+			goto out_free;
+		}
+#else
 		ipc_lock_by_ptr(&msq->q_perm);
 		ipc_rcu_putref(msq);
 		if (msq->q_perm.deleted) {
 			err = -EIDRM;
 			goto out_unlock_free;
 		}
+#endif
 		ss_del(&s);
 
+#if defined(CONFIG_KRG_IPC) && defined(CONFIG_KRG_EPM)
+		if (krg_action_any_pending(current)) {
+#ifdef CONFIG_KRG_DEBUG
+			printk("%s:%d - action kerrighed! --> need replay!!\n",
+			       __PRETTY_FUNCTION__, __LINE__);
+#endif
+			err = -ERESTARTSYS;
+			goto out_unlock_free;
+		}
+#endif
 		if (signal_pending(current)) {
 			err = -ERESTARTNOHAND;
 			goto out_unlock_free;
 		}
 	}
 
+#ifdef CONFIG_KRG_IPC
+	msq->q_lspid = tgid;
+#else
 	msq->q_lspid = task_tgid_vnr(current);
+#endif
 	msq->q_stime = get_seconds();
 
 	if (!pipelined_send(msq, msg)) {
--- ipc/shm.c
+++ ipc/shm.c
@@ -57,18 +61,30 @@
 };
 
 #define shm_file_data(file) (*((struct shm_file_data **)&(file)->private_data))
+#endif
 
-static const struct file_operations shm_file_operations;
-static struct vm_operations_struct shm_vm_ops;
+#ifndef CONFIG_KRG_IPC
+static
+#endif
+const struct file_operations shm_file_operations;
+#ifndef CONFIG_KRG_IPC
+static
+#endif
+struct vm_operations_struct shm_vm_ops;
 
+#ifndef CONFIG_KRG_IPC
 #define shm_ids(ns)	((ns)->ids[IPC_SHM_IDS])
 
 #define shm_unlock(shp)			\
 	ipc_unlock(&(shp)->shm_perm)
+#endif
 
+#ifndef CONFIG_KRG_IPC
 static int newseg(struct ipc_namespace *, struct ipc_params *);
+#endif
 static void shm_open(struct vm_area_struct *vma);
 static void shm_close(struct vm_area_struct *vma);
+
 static void shm_destroy (struct ipc_namespace *ns, struct shmid_kernel *shp);
 #ifdef CONFIG_PROC_FS
 static int sysvipc_shm_proc_show(struct seq_file *s, void *it);
@@ -110,6 +131,7 @@
 void shm_exit_ns(struct ipc_namespace *ns)
 {
 	free_ipcs(ns, &shm_ids(ns), do_shm_rmid);
+	idr_destroy(&ns->ids[IPC_SHM_IDS].ipcs_idr);
 }
 #endif
 
@@ -362,17 +432,26 @@
 	return ret;
 }
 
-static const struct file_operations shm_file_operations = {
+#ifndef CONFIG_KRG_IPC
+static
+#endif
+const struct file_operations shm_file_operations = {
 	.mmap		= shm_mmap,
 	.fsync		= shm_fsync,
 	.release	= shm_release,
 	.get_unmapped_area	= shm_get_unmapped_area,
 };
 
-static struct vm_operations_struct shm_vm_ops = {
+#ifndef CONFIG_KRG_IPC
+static
+#endif
+struct vm_operations_struct shm_vm_ops = {
 	.open	= shm_open,	/* callback for a new vm-area open */
 	.close	= shm_close,	/* callback for when the vm-area is released */
 	.fault	= shm_fault,
+#ifdef CONFIG_KRG_IPC
+	.wppage	= shm_wppage,
+#endif
 #if defined(CONFIG_NUMA)
 	.set_policy = shm_set_policy,
 	.get_policy = shm_get_policy,
--- ipc/util.h
+++ ipc/util.h
@@ -138,6 +155,9 @@
 void ipc_rcu_putref(void *ptr);
 
 struct kern_ipc_perm *ipc_lock(struct ipc_ids *, int);
+#ifdef CONFIG_KRG_IPC
+struct kern_ipc_perm *local_ipc_lock(struct ipc_ids *ids, int id);
+#endif
 
 void kernel_to_ipc64_perm(struct kern_ipc_perm *in, struct ipc64_perm *out);
 void ipc64_perm_to_ipc_perm(struct ipc64_perm *in, struct ipc_perm *out);
@@ -175,18 +195,58 @@
 
 static inline void ipc_lock_by_ptr(struct kern_ipc_perm *perm)
 {
+#ifdef CONFIG_KRG_IPC
+	BUG_ON(perm->krgops);
+#endif
 	rcu_read_lock();
+#ifdef CONFIG_KRG_IPC
+	mutex_lock(&perm->mutex);
+#else
 	spin_lock(&perm->lock);
+#endif
 }
 
+#ifdef CONFIG_KRG_IPC
+void ipc_unlock(struct kern_ipc_perm *perm);
+
+void local_ipc_unlock(struct kern_ipc_perm *perm);
+#else
 static inline void ipc_unlock(struct kern_ipc_perm *perm)
 {
 	spin_unlock(&perm->lock);
 	rcu_read_unlock();
 }
+#endif
 
 struct kern_ipc_perm *ipc_lock_check(struct ipc_ids *ids, int id);
 int ipcget(struct ipc_namespace *ns, struct ipc_ids *ids,
 			struct ipc_ops *ops, struct ipc_params *params);
 
+#ifdef CONFIG_KRG_IPC
+
+struct krgipc_ops {
+	struct kddm_set *map_kddm_set;
+	struct kddm_set *key_kddm_set;
+	struct kddm_set *data_kddm_set;
+
+	struct kern_ipc_perm *(*ipc_lock)(struct ipc_ids *, int);
+	void (*ipc_unlock)(struct kern_ipc_perm *);
+	struct kern_ipc_perm *(*ipc_findkey)(struct ipc_ids *, key_t);
+};
+
+int local_ipc_reserveid(struct ipc_ids* ids, struct kern_ipc_perm* new,
+                        int size);
+
+int is_krg_ipc(struct ipc_ids *ids);
+
+int krg_msg_init_ns(struct ipc_namespace *ns);
+int krg_sem_init_ns(struct ipc_namespace *ns);
+int krg_shm_init_ns(struct ipc_namespace *ns);
+
+void krg_msg_exit_ns(struct ipc_namespace *ns);
+void krg_sem_exit_ns(struct ipc_namespace *ns);
+void krg_shm_exit_ns(struct ipc_namespace *ns);
+
+#endif
+
 #endif
--- ipc/namespace.c
+++ ipc/namespace.c
@@ -14,6 +14,38 @@
 
 #include "util.h"
 
+#ifdef CONFIG_KRG_IPC
+static int krg_init_ipc_ns(struct ipc_namespace *ns)
+{
+	int err = 0;
+
+	if (!current->create_krg_ns)
+		goto exit;
+
+	err = krg_sem_init_ns(ns);
+	if (err)
+		goto err_sem;
+
+	err = krg_msg_init_ns(ns);
+	if (err)
+		goto err_msg;
+
+	err = krg_shm_init_ns(ns);
+	if (err)
+		goto err_shm;
+
+	return err;
+
+err_shm:
+	krg_msg_exit_ns(ns);
+err_msg:
+	krg_sem_exit_ns(ns);
+err_sem:
+exit:
+	return err;
+}
+#endif
+
 static struct ipc_namespace *clone_ipc_ns(struct ipc_namespace *old_ns)
 {
 	struct ipc_namespace *ns;
@@ -141,6 +182,11 @@
 	sem_exit_ns(ns);
 	msg_exit_ns(ns);
 	shm_exit_ns(ns);
+#ifdef CONFIG_KRG_IPC
+	krg_sem_exit_ns(ns);
+	krg_msg_exit_ns(ns);
+	krg_shm_exit_ns(ns);
+#endif
 	kfree(ns);
 	atomic_dec(&nr_ipc_ns);
 
--- kernel/acct.c
+++ kernel/acct.c
@@ -215,6 +215,7 @@
 static int acct_on(char *name)
 {
 	struct file *file;
+	struct vfsmount *mnt;
 	int error;
 	struct pid_namespace *ns;
 	struct bsd_acct_struct *acct = NULL;
@@ -256,11 +257,12 @@
 		acct = NULL;
 	}
 
-	mnt_pin(file->f_path.mnt);
+	mnt = file->f_path.mnt;
+	mnt_pin(mnt);
 	acct_file_reopen(ns->bacct, file, ns);
 	spin_unlock(&acct_lock);
 
-	mntput(file->f_path.mnt); /* it's pinned, now give up active reference */
+	mntput(mnt); /* it's pinned, now give up active reference */
 	kfree(acct);
 
 	return 0;
--- kernel/futex.c
+++ kernel/futex.c
@@ -55,6 +55,9 @@
 #include <linux/magic.h>
 #include <linux/pid.h>
 #include <linux/nsproxy.h>
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/krgsyms.h>
+#endif
 
 #include <asm/futex.h>
 
--- kernel/nsproxy.c
+++ kernel/nsproxy.c
@@ -21,8 +21,14 @@
 #include <linux/pid_namespace.h>
 #include <net/net_namespace.h>
 #include <linux/ipc_namespace.h>
+#ifdef CONFIG_KRG_HOTPLUG
+#include <kerrighed/namespace.h>
+#endif
 
-static struct kmem_cache *nsproxy_cachep;
+#ifndef CONFIG_KRG_EPM
+static
+#endif
+struct kmem_cache *nsproxy_cachep;
 
 struct nsproxy init_nsproxy = INIT_NSPROXY(init_nsproxy);
 
--- kernel/cgroup.c
+++ kernel/cgroup.c
@@ -46,6 +46,10 @@
 #include <linux/cgroupstats.h>
 #include <linux/hash.h>
 #include <linux/namei.h>
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/ghost.h>
+#include <kerrighed/action.h>
+#endif
 
 #include <asm/atomic.h>
 
@@ -3606,3 +3610,39 @@
 	return ret;
 }
 
+#ifdef CONFIG_KRG_EPM
+int export_cgroups(struct epm_action *action,
+		   ghost_t *ghost, struct task_struct *task)
+{
+	int err = 0;
+
+	/* TODO */
+	if (task->cgroups != &init_css_set)
+		err = -EBUSY;
+
+	return err;
+}
+
+int import_cgroups(struct epm_action *action,
+		   ghost_t *ghost, struct task_struct *task)
+{
+	/* TODO */
+	get_css_set(&init_css_set);
+	task->cgroups = &init_css_set;
+	INIT_LIST_HEAD(&task->cg_list);
+
+	return 0;
+}
+
+void unimport_cgroups(struct task_struct *task)
+{
+	/* TODO */
+	cgroup_exit(task, 0);
+}
+
+void free_ghost_cgroups(struct task_struct *ghost)
+{
+	/* TODO */
+	cgroup_exit(ghost, 0);
+}
+#endif /* CONFIG_KRG_EPM */
--- kernel/sched.c
+++ kernel/sched.c
@@ -73,6 +73,17 @@
 #include <linux/ctype.h>
 #include <linux/ftrace.h>
 #include <trace/sched.h>
+#ifdef CONFIG_KRG_PROC
+#include <net/krgrpc/rpc.h>
+#include <net/krgrpc/rpcid.h>
+#include <kerrighed/remote_syscall.h>
+#endif
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/ghost.h>
+#endif
+#ifdef CONFIG_KRG_SCHED
+#include <kerrighed/scheduler/hooks.h>
+#endif
 
 #include <asm/tlb.h>
 #include <asm/irq_regs.h>
@@ -2598,6 +2628,9 @@
 		p->sched_class->task_new(rq, p);
 		inc_nr_running(rq);
 	}
+#if defined(CONFIG_KRG_SCHED) && defined(CONFIG_MODULE_HOOK)
+	module_hook_call(&kmh_process_on, (unsigned long)p);
+#endif
 	trace_sched_wakeup_new(rq, p, 1);
 	check_preempt_curr(rq, p, 0);
 #ifdef CONFIG_SMP
@@ -5035,7 +5071,14 @@
 	unsigned long *switch_count;
 	struct rq *rq;
 	int cpu;
+#ifdef CONFIG_KRG_EPM
+	struct task_struct *krg_cur;
+#endif
 
+#ifdef CONFIG_KRG_EPM
+	krg_cur = krg_current;
+	krg_current = NULL;
+#endif
 	cpu = smp_processor_id();
 	rq = cpu_rq(cpu);
 	rcu_qsctr_inc(cpu);
@@ -5058,7 +5101,14 @@
 		if (unlikely(signal_pending_state(prev->state, prev)))
 			prev->state = TASK_RUNNING;
 		else
+#if defined(CONFIG_KRG_SCHED) && defined(CONFIG_MODULE_HOOK)
+		{
+			module_hook_call(&kmh_process_off, (unsigned long)prev);
+#endif
 			deactivate_task(rq, prev, 1);
+#if defined(CONFIG_KRG_SCHED) && defined(CONFIG_MODULE_HOOK)
+		}
+#endif
 		switch_count = &prev->nvcsw;
 	}
 
@@ -5092,6 +5142,9 @@
 
 	if (unlikely(reacquire_kernel_lock(current) < 0))
 		goto need_resched_nonpreemptible;
+#ifdef CONFIG_KRG_EPM
+	krg_current = krg_cur;
+#endif
 }
 
 asmlinkage void __sched schedule(void)
@@ -6125,9 +6258,81 @@
 			retval = p->policy;
 	}
 	read_unlock(&tasklist_lock);
+#ifdef CONFIG_KRG_PROC
+	if (!p)
+		retval = krg_sched_getscheduler(pid);
+#endif
 	return retval;
 }
 
+#ifdef CONFIG_KRG_PROC
+static
+int handle_sched_getparam(struct rpc_desc *desc, void *msg, size_t size)
+{
+	struct pid *pid;
+	struct sched_param param;
+	const struct cred *old_cred;
+	int retval, err;
+
+	pid = krg_handle_remote_syscall_begin(desc, msg, size,
+					      NULL, &old_cred);
+	if (IS_ERR(pid)) {
+		retval = PTR_ERR(pid);
+		goto out;
+	}
+
+	retval = sys_sched_getparam(pid_vnr(pid), &param);
+	if (retval)
+		goto out_end;
+
+	err = rpc_pack_type(desc, param);
+	if (err) {
+		rpc_cancel(desc);
+		retval = err;
+	}
+
+out_end:
+	krg_handle_remote_syscall_end(pid, old_cred);
+
+out:
+	return retval;
+}
+
+static int krg_sched_getparam(pid_t pid, struct sched_param *param)
+{
+	struct rpc_desc *desc;
+	int res, r;
+
+	desc = krg_remote_syscall_begin(PROC_SCHED_GETPARAM, pid, NULL, 0);
+	if (IS_ERR(desc)) {
+		r = PTR_ERR(desc);
+		goto out;
+	}
+
+	r = rpc_unpack_type(desc, res);
+	if (r)
+		goto err_cancel;
+	r = res;
+	if (r)
+		goto out_end;
+	r = rpc_unpack_type(desc, *param);
+	if (r)
+		goto err_cancel;
+
+out_end:
+	krg_remote_syscall_end(desc, pid);
+
+out:
+	return r;
+
+err_cancel:
+	if (r > 0)
+		r = -EPIPE;
+	rpc_cancel(desc);
+	goto out_end;
+}
+#endif /* CONFIG_KRG_PROC */
+
 /**
  * sys_sched_getscheduler - get the RT priority of a thread
  * @pid: the pid in question.
--- kernel/ptrace.c
+++ kernel/ptrace.c
@@ -22,7 +22,89 @@
 #include <linux/pid_namespace.h>
 #include <linux/syscalls.h>
 #include <linux/uaccess.h>
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/action.h>
+#include <kerrighed/krginit.h>
+#include <kerrighed/children.h>
+#include <kerrighed/krg_exit.h>
+#endif
+
+
+#ifdef CONFIG_KRG_EPM
+/* Helpers to make ptrace and migration mutually exclusive */
+
+int krg_ptrace_link(struct task_struct *task, struct task_struct *tracer)
+{
+	struct task_struct *parent;
+	int retval;
+
+	/* Lock to-be-ptraced task on this node */
+	retval = krg_action_disable(task, EPM_MIGRATE, 0);
+	if (retval)
+		goto bad_task;
+	/* Lock tracer on this node */
+	retval = krg_action_disable(tracer, EPM_MIGRATE, 0);
+	if (retval)
+		goto bad_tracer;
+	/* Lock parent on this node */
+	retval = -EPERM;
+	parent = task->parent;
+	if (parent == baby_sitter)
+		goto bad_parent;
+	if (!is_container_init(parent) && parent != tracer) {
+		retval = krg_action_disable(parent, EPM_MIGRATE, 0);
+		if (retval)
+			goto bad_parent;
+	}
+
+	return 0;
+
+bad_parent:
+	krg_action_enable(tracer, EPM_MIGRATE, 0);
+bad_tracer:
+	krg_action_enable(task, EPM_MIGRATE, 0);
+bad_task:
+	return retval;
+}
+
+/* Assumes at least read_lock on tasklist */
+/* Called with write_lock_irq on tasklist */
+void krg_ptrace_unlink(struct task_struct *task)
+{
+	BUG_ON(task->real_parent == baby_sitter);
+	if (!is_container_init(task->real_parent)
+	    && task->real_parent != task->parent)
+		krg_action_enable(task->real_parent, EPM_MIGRATE, 0);
+	BUG_ON(task->parent == baby_sitter);
+	krg_action_enable(task->parent, EPM_MIGRATE, 0);
+	krg_action_enable(task, EPM_MIGRATE, 0);
+}
+
+/* Assumes at least read_lock on tasklist */
+/* Called with write_lock_irq on tasklist */
+void krg_ptrace_reparent_ptraced(struct task_struct *real_parent,
+				 struct task_struct *task)
+{
+	/*
+	 * We do not support that the new real parent can migrate at
+	 * all. This will not induce new limitations as long as threads can not
+	 * migrate.
+	 */
+
+	/* Not really needed as long as zombies do not migrate... */
+	krg_action_enable(real_parent, EPM_MIGRATE, 0);
+	/* new real_parent has already been assigned. */
+	BUG_ON(task->real_parent == baby_sitter);
+	if (!is_container_init(task->real_parent)
+	    && task->real_parent != task->parent) {
+		int retval;
+
+		retval = krg_action_disable(task->real_parent, EPM_MIGRATE, 0);
+		BUG_ON(retval);
+	}
+}
 
+#endif /* CONFIG_KRG_EPM */
 
 /*
  * Initialize a new task whose father had been ptraced.
@@ -234,6 +330,16 @@
 	retval = __ptrace_may_access(task, PTRACE_MODE_ATTACH);
 	if (retval)
 		goto bad;
+#ifdef CONFIG_KRG_EPM
+	retval = krg_set_child_ptraced(parent_children_obj, task, 1);
+	if (retval)
+		goto bad;
+	retval = krg_ptrace_link(task, current);
+	if (retval) {
+		krg_set_child_ptraced(parent_children_obj, task, 0);
+		goto bad;
+	}
+#endif /* CONFIG_KRG_EPM */
 
 	/* Go */
 	task->ptrace |= PT_PTRACED;
@@ -246,6 +352,11 @@
 bad:
 	write_unlock_irqrestore(&tasklist_lock, flags);
 	task_unlock(task);
+#ifdef CONFIG_KRG_EPM
+	if (parent_children_obj)
+		krg_children_unlock(parent_children_obj);
+	up_read(&kerrighed_init_sem);
+#endif /* CONFIG_KRG_EPM */
 	mutex_unlock(&task->cred_exec_mutex);
 out:
 	return retval;
@@ -637,8 +788,19 @@
  */
 int ptrace_traceme(void)
 {
+#ifdef CONFIG_KRG_EPM
+	struct children_kddm_object *parent_children_obj;
+	pid_t real_parent_tgid;
+#endif /* CONFIG_KRG_EPM */
 	int ret = -EPERM;
 
+#ifdef CONFIG_KRG_EPM
+	down_read(&kerrighed_init_sem);
+	parent_children_obj = rcu_dereference(current->parent_children_obj);
+	if (parent_children_obj)
+		parent_children_obj =
+			krg_parent_children_writelock(current, &real_parent_tgid);
+#endif /* CONFIG_KRG_EPM */
 	/*
 	 * Are we already being traced?
 	 */
@@ -657,7 +819,23 @@
 			goto repeat;
 		}
 
+#ifdef CONFIG_KRG_EPM
+		if (current->parent == baby_sitter)
+			ret = -EPERM;
+		else
+#endif
 		ret = security_ptrace_traceme(current->parent);
+#ifdef CONFIG_KRG_EPM
+		if (!ret)
+			ret = krg_set_child_ptraced(parent_children_obj,
+						    current, 1);
+		if (!ret) {
+			ret = krg_ptrace_link(current, current->parent);
+			if (ret)
+				krg_set_child_ptraced(parent_children_obj,
+						      current, 0);
+		}
+#endif /* CONFIG_KRG_EPM */
 
 		/*
 		 * Check PF_EXITING to ensure ->real_parent has not passed
@@ -668,10 +846,26 @@
 			current->ptrace |= PT_PTRACED;
 			__ptrace_link(current, current->real_parent);
 		}
+#ifdef CONFIG_KRG_EPM
+		else if (!ret) {
+			/*
+			 * Since tracer should have been real_parent, it's ok
+			 * to call krg_ptrace_unlink() without having called
+			 * __ptrace_link() before.
+			 */
+			krg_ptrace_unlink(current);
+			krg_set_child_ptraced(parent_children_obj, current, 0);
+		}
+#endif /* CONFIG_KRG_EPM */
 
 		write_unlock_irqrestore(&tasklist_lock, flags);
 	}
 	task_unlock(current);
+#ifdef CONFIG_KRG_EPM
+	if (parent_children_obj)
+		krg_children_unlock(parent_children_obj);
+	up_read(&kerrighed_init_sem);
+#endif /* CONFIG_KRG_EPM */
 	return ret;
 }
 
--- kernel/pid_namespace.c
+++ kernel/pid_namespace.c
@@ -13,6 +13,10 @@
 #include <linux/syscalls.h>
 #include <linux/err.h>
 #include <linux/acct.h>
+#ifdef CONFIG_KRG_PROC
+#include <linux/module.h>
+#include <kerrighed/namespace.h>
+#endif
 
 #define BITS_PER_PAGE		(PAGE_SIZE*8)
 
@@ -67,7 +71,10 @@
 	return NULL;
 }
 
-static struct pid_namespace *create_pid_namespace(unsigned int level)
+#ifndef CONFIG_KRG_EPM
+static
+#endif
+struct pid_namespace *create_pid_namespace(unsigned int level)
 {
 	struct pid_namespace *ns;
 	int i;
@@ -107,6 +114,10 @@
 {
 	int i;
 
+#ifdef CONFIG_KRG_PROC
+	if (ns->krg_ns_root && ns->krg_ns_root != ns)
+		put_pid_ns(ns->krg_ns_root);
+#endif
 	for (i = 0; i < PIDMAP_ENTRIES; i++)
 		kfree(ns->pidmap[i].page);
 	kmem_cache_free(pid_ns_cachep, ns);
@@ -127,7 +138,18 @@
 
 	new_ns = create_pid_namespace(old_ns->level + 1);
 	if (!IS_ERR(new_ns))
+#ifdef CONFIG_KRG_PROC
+	{
+		new_ns->global = old_ns->global;
+		new_ns->global |= current->create_krg_ns;
+		if (old_ns->krg_ns_root)
+			get_pid_ns(old_ns->krg_ns_root);
+		new_ns->krg_ns_root = old_ns->krg_ns_root;
 		new_ns->parent = get_pid_ns(old_ns);
+	}
+#else
+		new_ns->parent = get_pid_ns(old_ns);
+#endif
 
 out_put:
 	put_pid_ns(old_ns);
--- kernel/signal.c
+++ kernel/signal.c
@@ -28,6 +28,21 @@
 #include <linux/pid_namespace.h>
 #include <linux/nsproxy.h>
 #include <trace/sched.h>
+#ifdef CONFIG_KRG_PROC
+#include <net/krgrpc/rpc.h>
+#include <net/krgrpc/rpcid.h>
+#include <kerrighed/pid.h>
+#include <kerrighed/remote_cred.h>
+#include <kerrighed/krgnodemask.h>
+#include <kerrighed/krginit.h>
+#include <kerrighed/remote_syscall.h>
+#endif
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/krg_exit.h>
+#include <kerrighed/action.h>
+#include <kerrighed/kerrighed_signal.h>
+#include <kerrighed/signal.h>
+#endif
 
 #include <asm/param.h>
 #include <asm/uaccess.h>
@@ -1734,16 +2072,20 @@
 	 * we are under tasklist_lock here so our parent is tied to
 	 * us and cannot exit and release its namespace.
 	 *
-	 * the only it can is to switch its nsproxy with sys_unshare,
-	 * bu uncharing pid namespaces is not allowed, so we'll always
-	 * see relevant namespace
+	 * The only it can is to switch its nsproxy with sys_unshare,
+	 * but we use the pid_namespace for task_pid which never changes.
 	 *
 	 * write_lock() currently calls preempt_disable() which is the
 	 * same as rcu_read_lock(), but according to Oleg, this is not
 	 * correct to rely on this
 	 */
 	rcu_read_lock();
-	info.si_pid = task_pid_nr_ns(tsk, tsk->parent->nsproxy->pid_ns);
+#ifdef CONFIG_KRG_EPM
+	if (tsk->parent == baby_sitter)
+		info.si_pid = task_pid_knr(tsk);
+	else
+#endif
+	info.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));
 	info.si_uid = __task_cred(tsk)->uid;
 	rcu_read_unlock();
 
@@ -1834,7 +2196,7 @@
 	 * see comment in do_notify_parent() abot the following 3 lines
 	 */
 	rcu_read_lock();
-	info.si_pid = task_pid_nr_ns(tsk, tsk->parent->nsproxy->pid_ns);
+	info.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));
 	info.si_uid = __task_cred(tsk)->uid;
 	rcu_read_unlock();
 
@@ -2719,12 +3089,21 @@
 	struct task_struct *t = current;
 	struct k_sigaction *k;
 	sigset_t mask;
+#ifdef CONFIG_KRG_EPM
+	unsigned long sighand_id;
+#endif
 
 	if (!valid_signal(sig) || sig < 1 || (act && sig_kernel_only(sig)))
 		return -EINVAL;
 
 	k = &t->sighand->action[sig-1];
 
+#ifdef CONFIG_KRG_EPM
+	down_read(&kerrighed_init_sem);
+	sighand_id = current->sighand->krg_objid;
+	if (sighand_id)
+		krg_sighand_writelock(sighand_id);
+#endif
 	spin_lock_irq(&current->sighand->siglock);
 	if (oact)
 		*oact = *k;
--- kernel/timer.c
+++ kernel/timer.c
@@ -37,6 +37,12 @@
 #include <linux/delay.h>
 #include <linux/tick.h>
 #include <linux/kallsyms.h>
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/children.h>
+#endif
+#ifdef CONFIG_KRG_SCHED
+#include <kerrighed/scheduler/hooks.h>
+#endif
 
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
@@ -1261,7 +1275,11 @@
 	int pid;
 
 	rcu_read_lock();
+#ifdef CONFIG_KRG_EPM
+	pid = krg_get_real_parent_tgid(current, task_active_pid_ns(current));
+#else
 	pid = task_tgid_vnr(current->real_parent);
+#endif
 	rcu_read_unlock();
 
 	return pid;
--- kernel/posix-cpu-timers.c
+++ kernel/posix-cpu-timers.c
@@ -8,6 +8,9 @@
 #include <linux/math64.h>
 #include <asm/uaccess.h>
 #include <linux/kernel_stat.h>
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/krgsyms.h>
+#endif
 
 /*
  * Called after updating RLIMIT_CPU to set timer expiration if necessary.
--- kernel/compat.c
+++ kernel/compat.c
@@ -25,6 +25,9 @@
 #include <linux/posix-timers.h>
 #include <linux/times.h>
 #include <linux/ptrace.h>
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/krgsyms.h>
+#endif
 
 #include <asm/uaccess.h>
 
--- kernel/fork.c
+++ kernel/fork.c
@@ -63,6 +63,24 @@
 #include <linux/fs_struct.h>
 #include <trace/sched.h>
 #include <linux/magic.h>
+#ifdef CONFIG_KRG_KDDM
+#include <kddm/kddm_info.h>
+#endif
+#ifdef CONFIG_KRG_HOTPLUG
+#include <kerrighed/namespace.h>
+#endif
+#ifdef CONFIG_KRG_PROC
+#include <kerrighed/task.h>
+#include <kerrighed/krginit.h>
+#endif
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/signal.h>
+#include <kerrighed/children.h>
+#include <kerrighed/application.h>
+#endif
+#ifdef CONFIG_KRG_SCHED
+#include <kerrighed/scheduler/info.h>
+#endif
 
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
@@ -99,7 +117,10 @@
 #ifndef __HAVE_ARCH_TASK_STRUCT_ALLOCATOR
 # define alloc_task_struct()	kmem_cache_alloc(task_struct_cachep, GFP_KERNEL)
 # define free_task_struct(tsk)	kmem_cache_free(task_struct_cachep, (tsk))
-static struct kmem_cache *task_struct_cachep;
+#ifndef CONFIG_KRG_EPM
+static
+#endif
+struct kmem_cache *task_struct_cachep;
 #endif
 
 #ifndef __HAVE_ARCH_THREAD_INFO_ALLOCATOR
@@ -540,6 +606,9 @@
 			spin_unlock(&mmlist_lock);
 		}
 		put_swap_token(mm);
+#ifdef CONFIG_KRG_EPM
+		BUG_ON(atomic_read(&mm->mm_ltasks) != 0);
+#endif
 		mmdrop(mm);
 	}
 }
@@ -600,10 +669,19 @@
 
 	/* Get rid of any cached register state */
 	deactivate_mm(tsk, mm);
+#ifdef CONFIG_KRG_EPM
+	if (mm)
+		atomic_dec(&mm->mm_ltasks);
+#endif
 
 	/* notify parent sleeping on vfork() */
 	if (vfork_done) {
 		tsk->vfork_done = NULL;
+#ifdef CONFIG_KRG_EPM
+		if (tsk->remote_vfork_done)
+			krg_vfork_done(vfork_done);
+		else
+#endif
 		complete(vfork_done);
 	}
 
@@ -668,6 +746,9 @@
 	return mm;
 
 free_pt:
+#ifdef CONFIG_KRG_EPM
+	atomic_dec(&mm->mm_ltasks);
+#endif
 	mmput(mm);
 
 fail_nomem:
@@ -909,9 +1038,31 @@
 {
 	struct signal_struct *sig;
 
+#ifdef CONFIG_KRG_EPM
+	if (krg_current && !in_krg_do_fork()) {
+		/*
+		 * This is a process migration or restart: signal_struct is
+		 * already setup.
+		 */
+		tsk->signal->curr_target = tsk;
+		return 0;
+	}
+
+	if (!krg_current)
+#endif
 	if (clone_flags & CLONE_THREAD) {
+#ifdef CONFIG_KRG_EPM
+		if (current->signal->kddm_obj)
+			krg_signal_writelock(current->signal);
+#endif
 		atomic_inc(&current->signal->count);
 		atomic_inc(&current->signal->live);
+#ifdef CONFIG_KRG_EPM
+		if (current->signal->kddm_obj) {
+			krg_signal_share(current->signal);
+			krg_signal_unlock(current->signal);
+		}
+#endif
 		return 0;
 	}
 
@@ -988,11 +1153,20 @@
 static void cleanup_signal(struct task_struct *tsk)
 {
 	struct signal_struct *sig = tsk->signal;
+#ifdef CONFIG_KRG_EPM
+	struct signal_struct *locked_sig;
+#endif
 
+#ifdef CONFIG_KRG_EPM
+	locked_sig = krg_signal_exit(sig);
+#endif
 	atomic_dec(&sig->live);
 
 	if (atomic_dec_and_test(&sig->count))
 		__cleanup_signal(sig);
+#ifdef CONFIG_KRG_EPM
+	krg_signal_unlock(locked_sig);
+#endif
 }
 
 static void copy_flags(unsigned long clone_flags, struct task_struct *p)
@@ -1149,6 +1341,9 @@
 	p->rcu_read_lock_nesting = 0;
 	p->rcu_flipctr_idx = 0;
 #endif /* #ifdef CONFIG_PREEMPT_RCU */
+#ifdef CONFIG_KRG_EPM
+	if (!krg_current)
+#endif
 	p->vfork_done = NULL;
 	spin_lock_init(&p->alloc_lock);
 
@@ -1226,8 +1427,23 @@
 	/* Perform scheduler related setup. Assign this task to a CPU. */
 	sched_fork(p, clone_flags);
 
+#ifdef CONFIG_KRG_CAP
+	krg_cap_fork(p, clone_flags);
+#endif /* CONFIG_KRG_CAP */
+
+#ifdef CONFIG_KRG_KDDM
+	if (!kh_copy_kddm_info)
+		p->kddm_info = NULL;
+	else if ((retval = kh_copy_kddm_info(clone_flags, p)))
+		goto bad_fork_cleanup_policy;
+#endif /* CONFIG_KRG_KDDM */
+
 	if ((retval = audit_alloc(p)))
+#ifdef CONFIG_KRG_KDDM
+		goto bad_fork_cleanup_kddm_info;
+#else
 		goto bad_fork_cleanup_policy;
+#endif /* CONFIG_KRG_KDDM */
 	/* copy all the process information */
 	if ((retval = copy_semundo(clone_flags, p)))
 		goto bad_fork_cleanup_audit;
@@ -1426,20 +1708,51 @@
 	 * thread can't slip out of an OOM kill (or normal SIGKILL).
  	 */
 	recalc_sigpending();
+#ifdef CONFIG_KRG_EPM
+	/* Only check if inside a remote clone() */
+	if (!krg_current || in_krg_do_fork())
+#endif
 	if (signal_pending(current)) {
 		spin_unlock(&current->sighand->siglock);
 		write_unlock_irq(&tasklist_lock);
 		retval = -ERESTARTNOINTR;
+#if defined(CONFIG_KRG_SCHED)
+		goto bad_fork_free_krg_sched;
+#elif defined(CONFIG_KRG_PROC)
+		goto bad_fork_free_krg_task;
+#else
 		goto bad_fork_free_graph;
+#endif
 	}
 
+#ifdef CONFIG_KRG_EPM
+	retval = krg_children_fork(p, pid, clone_flags);
+	if (retval) {
+		spin_unlock(&current->sighand->siglock);
+		write_unlock_irq(&tasklist_lock);
+#ifdef CONFIG_KRG_SCHED
+		goto bad_fork_free_krg_sched;
+#else
+		goto bad_fork_free_krg_task;
+#endif
+	}
+#endif /* CONFIG_KRG_EPM */
+#ifdef CONFIG_KRG_EPM
+	if (!krg_current || !thread_group_leader(krg_current))
+#endif
 	if (clone_flags & CLONE_THREAD) {
 		p->group_leader = current->group_leader;
 		list_add_tail_rcu(&p->thread_group, &p->group_leader->thread_group);
 	}
 
 	if (likely(p->pid)) {
+#ifdef CONFIG_KRG_EPM
+		if (p->real_parent != baby_sitter)
+#endif
 		list_add_tail(&p->sibling, &p->real_parent->children);
+#ifdef CONFIG_KRG_EPM
+		attach_pid(p, PIDTYPE_PID, pid);
+#endif
 		tracehook_finish_clone(p, clone_flags, trace);
 
 		if (thread_group_leader(p)) {
@@ -1454,20 +1767,52 @@
 			list_add_tail_rcu(&p->tasks, &init_task.tasks);
 			__get_cpu_var(process_counts)++;
 		}
+#ifndef CONFIG_KRG_EPM
 		attach_pid(p, PIDTYPE_PID, pid);
+#endif
 		nr_threads++;
 	}
+#ifdef CONFIG_KRG_PROC
+	krg_task_fill(p, clone_flags);
+#endif
 
 	total_forks++;
 	spin_unlock(&current->sighand->siglock);
 	write_unlock_irq(&tasklist_lock);
+#ifdef CONFIG_KRG_PROC
+	krg_task_commit(p);
+#endif
+#ifdef CONFIG_KRG_EPM
+	krg_children_commit_fork(p);
+#endif
 	proc_fork_connector(p);
 	cgroup_post_fork(p);
+#ifdef CONFIG_KRG_HOTPLUG
+	current->create_krg_ns = saved_create_krg_ns;
+#endif
 	return p;
 
+#ifdef CONFIG_KRG_SCHED
+bad_fork_free_krg_sched:
+	krg_sched_info_free(p);
+#endif
+#ifdef CONFIG_KRG_PROC
+bad_fork_free_krg_task:
+	krg_task_abort(p);
+#endif
+#ifdef CONFIG_KRG_EPM
+bad_fork_cleanup_children:
+	krg_children_abort_fork(p);
+bad_fork_cleanup_application:
+	if (!krg_current)
+		krg_exit_application(p);
+#endif
 bad_fork_free_graph:
 	ftrace_graph_exit_task(p);
 bad_fork_free_pid:
+#ifdef CONFIG_KRG_EPM
+	if (!krg_current)
+#endif
 	if (pid != &init_struct_pid)
 		free_pid(pid);
 bad_fork_cleanup_io:
@@ -1475,12 +1820,31 @@
 bad_fork_cleanup_namespaces:
 	exit_task_namespaces(p);
 bad_fork_cleanup_mm:
+#ifdef CONFIG_KRG_MM
+	if (p->mm && p->mm->mm_id && (clone_flags & CLONE_VM))
+#ifdef CONFIG_KRG_EPM
+		if (!krg_current)
+#endif
+			KRGFCT(kh_mm_release)(p->mm, 1);
+#endif
+#ifdef CONFIG_KRG_EPM
+	if (p->mm)
+		atomic_dec(&p->mm->mm_ltasks);
+#endif
 	if (p->mm)
 		mmput(p->mm);
 bad_fork_cleanup_signal:
+#ifdef CONFIG_KRG_EPM
+	if (!krg_current || in_krg_do_fork())
+#endif
 	cleanup_signal(p);
 bad_fork_cleanup_sighand:
+#ifdef CONFIG_KRG_EPM
+	if (!krg_current || in_krg_do_fork())
+		krg_sighand_cleanup(p->sighand);
+#else
 	__cleanup_sighand(p->sighand);
+#endif /* CONFIG_KRG_EPM */
 bad_fork_cleanup_fs:
 	exit_fs(p); /* blocking */
 bad_fork_cleanup_files:
@@ -1489,12 +1853,20 @@
 	exit_sem(p);
 bad_fork_cleanup_audit:
 	audit_free(p);
+#ifdef CONFIG_KRG_KDDM
+bad_fork_cleanup_kddm_info:
+	if (p->kddm_info)
+		kmem_cache_free(kddm_info_cachep, p->kddm_info);
+#endif
 bad_fork_cleanup_policy:
 #ifdef CONFIG_NUMA
 	mpol_put(p->mempolicy);
 bad_fork_cleanup_cgroup:
 #endif
 	cgroup_exit(p, cgroup_callbacks_done);
+#ifdef CONFIG_KRG_EPM
+	if (!krg_current)
+#endif
 	delayacct_tsk_free(p);
 	if (p->binfmt)
 		module_put(p->binfmt->module);
@@ -1507,6 +1879,9 @@
 bad_fork_free:
 	free_task(p);
 fork_out:
+#ifdef CONFIG_KRG_HOTPLUG
+	current->create_krg_ns = saved_create_krg_ns;
+#endif
 	return ERR_PTR(retval);
 }
 
@@ -1825,9 +2220,16 @@
 	struct files_struct *fd, *new_fd = NULL;
 	struct nsproxy *new_nsproxy = NULL;
 	int do_sysvsem = 0;
+#ifdef CONFIG_KRG_HOTPLUG
+	int saved_create_krg_ns;
+#endif
 
 	check_unshare_flags(&unshare_flags);
 
+#ifdef CONFIG_KRG_HOTPLUG
+	saved_create_krg_ns = current->create_krg_ns;
+	current->create_krg_ns = 0;
+#endif
 	/* Return -EINVAL for all unsupported flags */
 	err = -EINVAL;
 	if (unshare_flags & ~(CLONE_THREAD|CLONE_FS|CLONE_NEWNS|CLONE_SIGHAND|
--- kernel/exit.c
+++ kernel/exit.c
@@ -49,6 +49,24 @@
 #include <linux/fs_struct.h>
 #include <linux/init_task.h>
 #include <trace/sched.h>
+#ifdef CONFIG_KRG_KDDM
+#include <kddm/kddm_info.h>
+#endif
+#ifdef CONFIG_KRG_HOTPLUG
+#include <kerrighed/namespace.h>
+#endif
+#ifdef CONFIG_KRG_PROC
+#include <kerrighed/task.h>
+#include <kerrighed/krginit.h>
+#include <kerrighed/krg_exit.h>
+#endif
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/signal.h>
+#include <kerrighed/children.h>
+#endif
+#ifdef CONFIG_KRG_SCHED
+#include <kerrighed/scheduler/info.h>
+#endif
 
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
@@ -95,6 +116,13 @@
 	spin_lock(&sighand->siglock);
 
 	posix_cpu_timers_exit(tsk);
+#ifdef CONFIG_KRG_EPM
+	if (tsk->exit_state == EXIT_MIGRATION) {
+		BUG_ON(atomic_read(&sig->count) > 1);
+		posix_cpu_timers_exit_group(tsk);
+		sig->curr_target = NULL;
+	} else
+#endif
 	if (atomic_dec_and_test(&sig->count))
 		posix_cpu_timers_exit_group(tsk);
 	else {
@@ -143,16 +171,30 @@
 	tsk->sighand = NULL;
 	spin_unlock(&sighand->siglock);
 
+#ifdef CONFIG_KRG_EPM
+	if (tsk->exit_state == EXIT_MIGRATION)
+		krg_sighand_unpin(sighand);
+	else
+#endif
 	__cleanup_sighand(sighand);
 	clear_tsk_thread_flag(tsk,TIF_SIGPENDING);
 	if (sig) {
 		flush_sigqueue(&sig->shared_pending);
+#ifdef CONFIG_KRG_EPM
+		if (tsk->exit_state != EXIT_MIGRATION)
+#endif
 		taskstats_tgid_free(sig);
 		/*
 		 * Make sure ->signal can't go away under rq->lock,
 		 * see account_group_exec_runtime().
 		 */
 		task_rq_unlock_wait(tsk);
+#ifdef CONFIG_KRG_EPM
+		if (tsk->exit_state == EXIT_MIGRATION) {
+			krg_signal_unpin(sig);
+			return;
+		}
+#endif
 		__cleanup_signal(sig);
 	}
 }
@@ -396,6 +499,17 @@
  */
 static void reparent_to_kthreadd(void)
 {
+#ifdef CONFIG_KRG_EPM
+	struct children_kddm_object *parent_children_obj = NULL;
+	pid_t parent_tgid;
+
+	down_read(&kerrighed_init_sem);
+
+	if (rcu_dereference(current->parent_children_obj))
+		parent_children_obj = krg_parent_children_writelock(
+					current,
+					&parent_tgid);
+#endif /* CONFIG_KRG_EPM */
 	write_lock_irq(&tasklist_lock);
 
 	ptrace_unlink(current);
@@ -848,10 +974,17 @@
 static void forget_original_parent(struct task_struct *father)
 {
 	struct task_struct *p, *n, *reaper;
+#ifdef CONFIG_KRG_EPM
+	struct children_kddm_object *children_obj = NULL;
+#endif
 	LIST_HEAD(dead_children);
 
 	exit_ptrace(father);
 
+#ifdef CONFIG_KRG_EPM
+	if (rcu_dereference(father->children_obj))
+		children_obj = __krg_children_writelock(father);
+#endif
 	write_lock_irq(&tasklist_lock);
 	reaper = find_new_reaper(father);
 
@@ -912,6 +1064,9 @@
 	forget_original_parent(tsk);
 	exit_task_namespaces(tsk);
 
+#ifdef CONFIG_KRG_PROC
+	krg_cookie = krg_prepare_exit_notify(tsk);
+#endif /* CONFIG_KRG_PROC */
 	write_lock_irq(&tasklist_lock);
 	if (group_dead)
 		kill_orphaned_pgrp(tsk->group_leader, NULL);
@@ -1138,11 +1361,20 @@
 		module_put(tsk->binfmt->module);
 
 	proc_exit_connector(tsk);
+#ifdef CONFIG_KRG_EPM
+	if (!notify)
+		exit_migration(tsk);
+	else
+#endif
 	exit_notify(tsk, group_dead);
 #ifdef CONFIG_NUMA
 	mpol_put(tsk->mempolicy);
 	tsk->mempolicy = NULL;
 #endif
+#ifdef CONFIG_KRG_KDDM
+	if (tsk->kddm_info)
+		kmem_cache_free(kddm_info_cachep, tsk->kddm_info);
+#endif
 #ifdef CONFIG_FUTEX
 	/*
 	 * This must happen late, after the PID is not
@@ -1326,7 +1577,10 @@
  * the lock and this task is uninteresting.  If we return nonzero, we have
  * released the lock and the system call should return.
  */
-static int wait_task_zombie(struct task_struct *p, int options,
+#ifndef CONFIG_KRG_EPM
+static
+#endif
+int wait_task_zombie(struct task_struct *p, int options,
 			    struct siginfo __user *infop,
 			    int __user *stat_addr, struct rusage __user *ru)
 {
@@ -1377,6 +1641,10 @@
 
 	traced = ptrace_reparented(p);
 
+#ifdef CONFIG_KRG_EPM
+	/* remote call iff p->parent == baby_sitter */
+	if (p->parent != baby_sitter)
+#endif
 	if (likely(!traced)) {
 		struct signal_struct *psig;
 		struct signal_struct *sig;
@@ -1478,6 +1750,17 @@
 		retval = pid;
 
 	if (traced) {
+#ifdef CONFIG_KRG_EPM
+		struct children_kddm_object *parent_children_obj = NULL;
+		pid_t real_parent_tgid;
+		/* p may be set to NULL while we still need it */
+		struct task_struct *saved_p = p;
+
+		if (rcu_dereference(saved_p->parent_children_obj))
+			parent_children_obj =
+				krg_parent_children_writelock(saved_p,
+							      &real_parent_tgid);
+#endif
 		write_lock_irq(&tasklist_lock);
 		/* We dropped tasklist, ptracer could die and untrace */
 		ptrace_unlink(p);
@@ -1775,9 +2073,16 @@
 	return 0;
 }
 
+#ifdef CONFIG_KRG_EPM
+static
+long do_wait(enum pid_type type, struct pid *pid, pid_t upid, int options,
+	     struct siginfo __user *infop, int __user *stat_addr,
+	     struct rusage __user *ru)
+#else
 static long do_wait(enum pid_type type, struct pid *pid, int options,
 		    struct siginfo __user *infop, int __user *stat_addr,
 		    struct rusage __user *ru)
+#endif
 {
 	DECLARE_WAITQUEUE(wait, current);
 	struct task_struct *tsk;
@@ -1785,6 +2090,9 @@
 
 	trace_sched_process_wait(pid);
 
+#ifdef CONFIG_KRG_PROC
+	down_read(&kerrighed_init_sem);
+#endif
 	add_wait_queue(&current->signal->wait_chldexit,&wait);
 repeat:
 	/*
@@ -1793,9 +2101,16 @@
 	 * match our criteria, even if we are not able to reap it yet.
 	 */
 	retval = -ECHILD;
+#ifdef CONFIG_KRG_EPM
+	if (!current->children_obj)
+#endif
 	if ((type < PIDTYPE_MAX) && (!pid || hlist_empty(&pid->tasks[type])))
 		goto end;
 
+#ifdef CONFIG_KRG_EPM
+	if (current->children_obj)
+		__krg_children_readlock(current);
+#endif
 	current->state = TASK_INTERRUPTIBLE;
 	read_lock(&tasklist_lock);
 	tsk = current;
@@ -1821,11 +2136,28 @@
 		BUG_ON(tsk->signal != current->signal);
 	} while (tsk != current);
 	read_unlock(&tasklist_lock);
+#ifdef CONFIG_KRG_EPM
+	if (current->children_obj) {
+		/* Try all children, even remote ones but don't wait yet */
+		/* Releases children lock */
+		int tsk_result = krg_do_wait(current->children_obj, &retval,
+					     type, upid, options,
+					     infop, stat_addr, ru);
+		if (tsk_result)
+			retval = tsk_result;
+	}
+#endif
 
 	if (!retval && !(options & WNOHANG)) {
 		retval = -ERESTARTSYS;
 		if (!signal_pending(current)) {
+#ifdef CONFIG_KRG_PROC
+			up_read(&kerrighed_init_sem);
+#endif
 			schedule();
+#ifdef CONFIG_KRG_PROC
+			down_read(&kerrighed_init_sem);
+#endif
 			goto repeat;
 		}
 	}
@@ -1833,6 +2165,9 @@
 end:
 	current->state = TASK_RUNNING;
 	remove_wait_queue(&current->signal->wait_chldexit,&wait);
+#ifdef CONFIG_KRG_PROC
+	up_read(&kerrighed_init_sem);
+#endif
 	if (infop) {
 		if (retval > 0)
 			retval = 0;
@@ -1891,7 +2226,11 @@
 
 	if (type < PIDTYPE_MAX)
 		pid = find_get_pid(upid);
+#ifdef CONFIG_KRG_EPM
+	ret = do_wait(type, pid, upid, options, infop, NULL, ru);
+#else
 	ret = do_wait(type, pid, options, infop, NULL, ru);
+#endif
 	put_pid(pid);
 
 	/* avoid REGPARM breakage on x86: */
@@ -1923,7 +2262,17 @@
 		pid = find_get_pid(upid);
 	}
 
+#ifdef CONFIG_KRG_EPM
+	if (type == PIDTYPE_PGID) {
+		if (upid == 0)
+			upid = pid_vnr(pid);
+		else /* upid < 0 */
+			upid = -upid;
+	}
+	ret = do_wait(type, pid, upid, options | WEXITED, NULL, stat_addr, ru);
+#else
 	ret = do_wait(type, pid, options | WEXITED, NULL, stat_addr, ru);
+#endif
 	put_pid(pid);
 
 	/* avoid REGPARM breakage on x86: */
--- kernel/hrtimer.c
+++ kernel/hrtimer.c
@@ -43,6 +43,9 @@
 #include <linux/seq_file.h>
 #include <linux/err.h>
 #include <linux/debugobjects.h>
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/krgsyms.h>
+#endif
 
 #include <asm/uaccess.h>
 
--- kernel/sys.c
+++ kernel/sys.c
@@ -1318,19 +1559,82 @@
 		if (retval)
 			goto out;
 	}
+#ifdef CONFIG_KRG_PROC
+	retval = pid_nr_ns(sid, ns);
+#else
 	retval = pid_vnr(sid);
+#endif
 out:
 	rcu_read_unlock();
 	return retval;
 }
 
+#ifdef CONFIG_KRG_PROC
+static int handle_getsid(struct rpc_desc *desc, void *msg, size_t size)
+{
+	struct pid *pid;
+	const struct cred *old_cred;
+	int retval;
+
+	pid = krg_handle_remote_syscall_begin(desc, msg, size,
+					      NULL, &old_cred);
+	if (IS_ERR(pid)) {
+		retval = PTR_ERR(pid);
+		goto out;
+	}
+
+	retval = do_getsid(pid_knr(pid), ns_of_pid(pid)->krg_ns_root);
+
+	krg_handle_remote_syscall_end(pid, old_cred);
+
+out:
+	return retval;
+}
+
+static int krg_getsid(pid_t pid)
+{
+	return krg_remote_syscall_simple(PROC_GETSID, pid, NULL, 0);;
+}
+
+SYSCALL_DEFINE1(getsid, pid_t, pid)
+{
+	int retval;
+
+	retval = do_getsid(pid, task_active_pid_ns(current));
+	if (retval == -ESRCH)
+		retval = krg_getsid(pid);
+
+	return retval;
+}
+
+void remote_sys_init(void)
+{
+	rpc_register_int(PROC_GETPGID, handle_getpgid, 0);
+	rpc_register_int(PROC_GETSID, handle_getsid, 0);
+#ifdef CONFIG_KRG_EPM
+	rpc_register_int(PROC_FORWARD_SETPGID, handle_forward_setpgid, 0);
+#endif
+}
+#endif /* CONFIG_KRG_PROC */
+
 SYSCALL_DEFINE0(setsid)
 {
 	struct task_struct *group_leader = current->group_leader;
 	struct pid *sid = task_pid(group_leader);
 	pid_t session = pid_vnr(sid);
+#ifdef CONFIG_KRG_EPM
+	struct children_kddm_object *parent_children_obj = NULL;
+	pid_t real_parent_tgid;
+#endif /* CONFIG_KRG_EPM */
 	int err = -EPERM;
 
+#ifdef CONFIG_KRG_EPM
+	down_read(&kerrighed_init_sem);
+	if (rcu_dereference(current->parent_children_obj))
+		parent_children_obj =
+			krg_parent_children_writelock(current,
+						      &real_parent_tgid);
+#endif /* CONFIG_KRG_EPM */
 	write_lock_irq(&tasklist_lock);
 	/* Fail if I am already a session leader */
 	if (group_leader->signal->leader)
@@ -1350,6 +1654,14 @@
 	err = session;
 out:
 	write_unlock_irq(&tasklist_lock);
+#ifdef CONFIG_KRG_EPM
+	if (parent_children_obj) {
+		if (err >= 0)
+			krg_set_child_pgid(parent_children_obj, current);
+		krg_children_unlock(parent_children_obj);
+	}
+	up_read(&kerrighed_init_sem);
+#endif /* CONFIG_KRG_EPM */
 	return err;
 }
 
--- kernel/pid.c
+++ kernel/pid.c
@@ -36,6 +36,10 @@
 #include <linux/pid_namespace.h>
 #include <linux/init_task.h>
 #include <linux/syscalls.h>
+#ifdef CONFIG_KRG_PROC
+#include <kerrighed/pid.h>
+#include <kerrighed/krginit.h>
+#endif
 
 #define pid_hashfn(nr, ns)	\
 	hash_long((unsigned long)nr + (unsigned long)ns, pidhash_shift)
@@ -78,6 +82,10 @@
 	.last_pid = 0,
 	.level = 0,
 	.child_reaper = &init_task,
+#ifdef CONFIG_KRG_PROC
+	.krg_ns_root = NULL,
+	.global = 0,
+#endif
 };
 EXPORT_SYMBOL_GPL(init_pid_ns);
 
@@ -223,6 +272,36 @@
 	return -1;
 }
 
+#ifdef CONFIG_KRG_EPM
+int reserve_pidmap(struct pid_namespace *pid_ns, int pid)
+{
+	int offset;
+	struct pidmap *map;
+
+	pid = SHORT_PID(pid);
+	if (pid >= pid_max)
+		return -EINVAL;
+
+	offset = pid & BITS_PER_PAGE_MASK;
+	map = &pid_ns->pidmap[pid/BITS_PER_PAGE];
+	if (!map->page) {
+		/* next_pidmap() is safe if intermediate pages are missing */
+		int err = alloc_pidmap_page(map);
+		if (err)
+			return err;
+	}
+
+	/* Reserve pid in the page */
+	BUG_ON(pid != mk_pid(pid_ns, map, offset));
+	if (!test_and_set_bit(offset, map->page)) {
+		atomic_dec(&map->nr_free);
+		return 0;
+	}
+
+	return -EBUSY;
+}
+#endif /* CONFIG_KRG_EPM */
+
 int next_pidmap(struct pid_namespace *pid_ns, int last)
 {
 	int offset;
@@ -295,12 +378,28 @@
 	pid = kmem_cache_alloc(ns->pid_cachep, GFP_KERNEL);
 	if (!pid)
 		goto out;
+#ifdef CONFIG_KRG_EPM
+	pid->kddm_obj = NULL;
+	BUG_ON(req_nr && !is_krg_pid_ns_root(ns));
+#endif
 
 	tmp = ns;
 	for (i = ns->level; i >= 0; i--) {
+#ifdef CONFIG_KRG_EPM
+		if (req_nr && tmp == ns) {
+			nr = req_nr[i - tmp->level];
+		} else {
+#endif
 		nr = alloc_pidmap(tmp);
 		if (nr < 0)
 			goto out_free;
+#ifdef CONFIG_KRG_PROC
+		if (tmp->global && nr != 1)
+			nr = GLOBAL_PID(nr);
+#endif
+#ifdef CONFIG_KRG_EPM
+		}
+#endif
 
 		pid->numbers[i].nr = nr;
 		pid->numbers[i].ns = tmp;
@@ -357,7 +463,7 @@
 
 struct pid *find_vpid(int nr)
 {
-	return find_pid_ns(nr, current->nsproxy->pid_ns);
+	return find_pid_ns(nr, task_active_pid_ns(current));
 }
 EXPORT_SYMBOL_GPL(find_vpid);
 
@@ -445,7 +555,7 @@
 struct task_struct *find_task_by_vpid(pid_t vnr)
 {
 	return find_task_by_pid_type_ns(PIDTYPE_PID, vnr,
-			current->nsproxy->pid_ns);
+					task_active_pid_ns(current));
 }
 EXPORT_SYMBOL(find_task_by_vpid);
 
@@ -501,10 +611,13 @@
 	}
 	return nr;
 }
+#ifdef CONFIG_KRG_PROC
+EXPORT_SYMBOL(pid_nr_ns);
+#endif
 
 pid_t pid_vnr(struct pid *pid)
 {
-	return pid_nr_ns(pid, current->nsproxy->pid_ns);
+	return pid_nr_ns(pid, task_active_pid_ns(current));
 }
 EXPORT_SYMBOL_GPL(pid_vnr);
 
@@ -515,7 +628,7 @@
 
 	rcu_read_lock();
 	if (!ns)
-		ns = current->nsproxy->pid_ns;
+		ns = task_active_pid_ns(current);
 	if (likely(pid_alive(task))) {
 		if (type != PIDTYPE_PID)
 			task = task->group_leader;
--- arch/x86/mm/pageattr.c
+++ arch/x86/mm/pageattr.c
@@ -11,6 +11,9 @@
 #include <linux/interrupt.h>
 #include <linux/seq_file.h>
 #include <linux/debugfs.h>
+#ifdef CONFIG_KRG_PROCFS
+#include <kerrighed/dynamic_node_info_linker.h>
+#endif
 
 #include <asm/e820.h>
 #include <asm/processor.h>
--- arch/x86/Makefile
+++ arch/x86/Makefile
@@ -127,6 +127,9 @@
 # lguest paravirtualization support
 core-$(CONFIG_LGUEST_GUEST) += arch/x86/lguest/
 
+# Kerrighed SSI cluster support
+core-$(CONFIG_KERRIGHED) += arch/x86/kerrighed/
+
 core-y += arch/x86/kernel/
 core-y += arch/x86/mm/
 
--- arch/x86/kernel/process_64.c
+++ arch/x86/kernel/process_64.c
@@ -304,14 +308,28 @@
 	p->thread.usersp = me->thread.usersp;
 
 	set_tsk_thread_flag(p, TIF_FORK);
+#ifdef CONFIG_KRG_EPM
+	/*
+	 * Migration/restart could have rcx, r11, and rflags corrupted by
+	 * ret_from_fork.
+	 */
+	if (krg_current && !in_krg_do_fork())
+		set_tsk_thread_flag(p, TIF_MIGRATION);
+#endif
 
 	p->thread.fs = me->thread.fs;
 	p->thread.gs = me->thread.gs;
 
+#ifdef CONFIG_KRG_EPM
+	if (!krg_current) {
+#endif
 	savesegment(gs, p->thread.gsindex);
 	savesegment(fs, p->thread.fsindex);
 	savesegment(es, p->thread.es);
 	savesegment(ds, p->thread.ds);
+#ifdef CONFIG_KRG_EPM
+	}
+#endif
 
 	if (unlikely(test_tsk_thread_flag(me, TIF_IO_BITMAP))) {
 		p->thread.io_bitmap_ptr = kmalloc(IO_BITMAP_BYTES, GFP_KERNEL);
@@ -341,8 +359,15 @@
 
 	ds_copy_thread(p, me);
 
+#ifdef CONFIG_KRG_EPM
+	/* Do not corrupt debugctlmsr in migration/restart */
+	if (!krg_current || in_krg_do_fork()) {
+#endif
 	clear_tsk_thread_flag(p, TIF_DEBUGCTLMSR);
 	p->thread.debugctlmsr = 0;
+#ifdef CONFIG_KRG_EPM
+	}
+#endif
 
 	err = 0;
 out:
--- arch/x86/kernel/process_32.c
+++ arch/x86/kernel/process_32.c
@@ -299,8 +306,15 @@
 
 	ds_copy_thread(p, current);
 
+#ifdef CONFIG_KRG_EPM
+	/* Do not corrupt debugctlmsr in migration/restart */
+	if (!krg_current || in_krg_do_fork()) {
+#endif
 	clear_tsk_thread_flag(p, TIF_DEBUGCTLMSR);
 	p->thread.debugctlmsr = 0;
+#ifdef CONFIG_KRG_EPM
+	}
+#endif
 
 	return err;
 }
--- arch/x86/kernel/cpu/proc.c
+++ arch/x86/kernel/cpu/proc.c
@@ -13,8 +13,11 @@
 #ifdef CONFIG_SMP
 	if (c->x86_max_cores * smp_num_siblings > 1) {
 		seq_printf(m, "physical id\t: %d\n", c->phys_proc_id);
+#ifndef CONFIG_KRG_PROCFS
+		/* TODO: implement support for cpu_core_map */
 		seq_printf(m, "siblings\t: %d\n",
 			   cpumask_weight(cpu_core_mask(cpu)));
+#endif
 		seq_printf(m, "core id\t\t: %d\n", c->cpu_core_id);
 		seq_printf(m, "cpu cores\t: %d\n", c->booted_cores);
 		seq_printf(m, "apicid\t\t: %d\n", c->apicid);
--- arch/x86/include/asm/uaccess.h
+++ arch/x86/include/asm/uaccess.h
@@ -446,6 +507,8 @@
 		     : "=r" (err), ltype(x)				\
 		     : "m" (__m(addr)), "i" (errret), "0" (err))
 
+#endif /* !CONFIG_KRG_FAF */
+
 #define __get_user_size_ex(x, ptr, size)				\
 do {									\
 	__chk_user_ptr(ptr);						\
--- arch/x86/include/asm/thread_info.h
+++ arch/x86/include/asm/thread_info.h
@@ -95,6 +95,12 @@
 #define TIF_DEBUGCTLMSR		25	/* uses thread_struct.debugctlmsr */
 #define TIF_DS_AREA_MSR		26      /* uses thread_struct.ds_area_msr */
 #define TIF_SYSCALL_FTRACE	27	/* for ftrace syscall instrumentation */
+#ifdef CONFIG_KRG_FAF
+#define TIF_RUACCESS            28
+#endif
+#ifdef CONFIG_KRG_EPM
+#define TIF_MIGRATION		29
+#endif
 
 #define _TIF_SYSCALL_TRACE	(1 << TIF_SYSCALL_TRACE)
 #define _TIF_NOTIFY_RESUME	(1 << TIF_NOTIFY_RESUME)
@@ -117,6 +123,12 @@
 #define _TIF_DEBUGCTLMSR	(1 << TIF_DEBUGCTLMSR)
 #define _TIF_DS_AREA_MSR	(1 << TIF_DS_AREA_MSR)
 #define _TIF_SYSCALL_FTRACE	(1 << TIF_SYSCALL_FTRACE)
+#ifdef CONFIG_KRG_FAF
+#define _TIF_RUACCESS           (1 << TIF_RUACCESS)
+#endif
+#ifdef CONFIG_KRG_EPM
+#define _TIF_MIGRATION		(1 << TIF_MIGRATION)
+#endif
 
 /* work to do in syscall_trace_enter() */
 #define _TIF_WORK_SYSCALL_ENTRY	\
--- arch/x86/include/asm/elf.h
+++ arch/x86/include/asm/elf.h
@@ -344,4 +344,11 @@
 extern unsigned long arch_randomize_brk(struct mm_struct *mm);
 #define arch_randomize_brk arch_randomize_brk
 
+#ifdef CONFIG_KRG_MM
+struct vm_area_struct;
+
+void import_vdso_context(struct vm_area_struct *vma);
+int import_mm_struct_end(struct mm_struct *mm, struct task_struct *task);
+#endif
+
 #endif /* _ASM_X86_ELF_H */
--- arch/x86/include/asm/processor.h
+++ arch/x86/include/asm/processor.h
@@ -111,6 +111,11 @@
 	/* Index into per_cpu list: */
 	u16			cpu_index;
 #endif
+#ifdef CONFIG_KRG_PROCFS
+	int                     krg_cpu_id;
+	unsigned long           cpu_khz;
+#endif /* CONFIG_KRG_PROCFS */
+
 	unsigned int		x86_hyper_vendor;
 } __attribute__((__aligned__(SMP_CACHE_BYTES)));
 
--- arch/x86/include/asm/pgtable_64.h
+++ arch/x86/include/asm/pgtable_64.h
@@ -138,6 +138,10 @@
 extern int direct_gbpages;
 
 /* Encode and de-code a swap entry */
+#ifdef CONFIG_KRG_MM
+#define SWP_TYPE_BITS		5
+#define SWP_OFFSET_SHIFT	9
+#else
 #if _PAGE_BIT_FILE < _PAGE_BIT_PROTNONE
 #define SWP_TYPE_BITS (_PAGE_BIT_FILE - _PAGE_BIT_PRESENT - 1)
 #define SWP_OFFSET_SHIFT (_PAGE_BIT_PROTNONE + 1)
@@ -145,15 +149,27 @@
 #define SWP_TYPE_BITS (_PAGE_BIT_PROTNONE - _PAGE_BIT_PRESENT - 1)
 #define SWP_OFFSET_SHIFT (_PAGE_BIT_FILE + 1)
 #endif
+#endif /* !CONFIG_KRG_MM */
 
 #define MAX_SWAPFILES_CHECK() BUILD_BUG_ON(MAX_SWAPFILES_SHIFT > SWP_TYPE_BITS)
 
+#ifdef CONFIG_KRG_MM
+#define __swp_type(x)			(((x).val >> (_PAGE_BIT_FILE + 1)) \
+					 & ((1U << SWP_TYPE_BITS) - 1))
+#else
 #define __swp_type(x)			(((x).val >> (_PAGE_BIT_PRESENT + 1)) \
 					 & ((1U << SWP_TYPE_BITS) - 1))
+#endif
 #define __swp_offset(x)			((x).val >> SWP_OFFSET_SHIFT)
+#ifdef CONFIG_KRG_MM
+#define __swp_entry(type, offset)	((swp_entry_t) { \
+					 ((type) << (_PAGE_BIT_FILE + 1)) \
+					 | ((offset) << SWP_OFFSET_SHIFT) })
+#else
 #define __swp_entry(type, offset)	((swp_entry_t) { \
 					 ((type) << (_PAGE_BIT_PRESENT + 1)) \
 					 | ((offset) << SWP_OFFSET_SHIFT) })
+#endif
 #define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val((pte)) })
 #define __swp_entry_to_pte(x)		((pte_t) { .pte = (x).val })
 
--- arch/x86/lib/copy_user_64.S
+++ arch/x86/lib/copy_user_64.S
@@ -294,3 +322,70 @@
 	.previous
 	CFI_ENDPROC
 ENDPROC(copy_user_generic_string)
+
+#ifdef CONFIG_KRG_FAF
+ENTRY(copy_user_check_ruaccess)
+	CFI_STARTPROC
+	cmpl %edx,(%rsp)
+	leaq 8(%rsp),%rsp
+	jne copy_user_handle_tail
+	GET_THREAD_INFO(%rax)
+	testl $_TIF_RUACCESS,TI_flags(%rax)
+	jz copy_user_handle_tail
+	cmpq $-1,TI_addr_limit(%rax)
+	je copy_user_handle_tail
+	jmp krg_copy_user_generic
+	CFI_ENDPROC
+ENDPROC(copy_user_check_ruaccess)
+
+/*
+ * Inputs: rax is the address of the hook to call
+ *         the hook's arg (up to 4) are already passed in conventional order
+ * Outputs: rax is 0 if the hook was called, non zero otherwise
+ *	    if rax is 0, rdx is the hook's result.
+ *
+ * Called from inline assembly, so save all possibly clobbered registers
+ */
+ENTRY(usercopy_check_ruaccess)
+	CFI_STARTPROC
+	pushq_cfi %r8
+	CFI_REL_OFFSET r8,0
+	GET_THREAD_INFO(%r8)
+	testl $_TIF_RUACCESS,TI_flags(%r8)
+	jz back_to_local
+	cmpq $-1,TI_addr_limit(%r8)
+	je back_to_local
+	pushq_cfi %rdi
+	CFI_REL_OFFSET rdi,0
+	pushq_cfi %rsi
+	CFI_REL_OFFSET rsi,0
+	pushq_cfi %rcx
+	CFI_REL_OFFSET rcx,0
+	pushq_cfi %r9
+	CFI_REL_OFFSET r9,0
+	pushq_cfi %r10
+	CFI_REL_OFFSET r10,0
+	pushq_cfi %r11
+	CFI_REL_OFFSET r11,0
+	call *%rax
+	movq %rax,%rdx
+	xorl %eax,%eax
+	popq_cfi %r11
+	CFI_RESTORE r11
+	popq_cfi %r10
+	CFI_RESTORE r10
+	popq_cfi %r9
+	CFI_RESTORE r9
+	popq_cfi %rcx
+	CFI_RESTORE rcx
+	popq_cfi %rsi
+	CFI_RESTORE rsi
+	popq_cfi %rdi
+	CFI_RESTORE rdi
+back_to_local:
+	popq_cfi %r8
+	CFI_RESTORE r8
+	ret
+	CFI_ENDPROC
+ENDPROC(usercopy_check_ruaccess)
+#endif
--- arch/x86/lib/usercopy_32.c
+++ arch/x86/lib/usercopy_32.c
@@ -824,6 +863,11 @@
 unsigned long __copy_from_user_ll(void *to, const void __user *from,
 					unsigned long n)
 {
+#ifdef CONFIG_KRG_FAF
+	if (check_ruaccess())
+		n = krg_copy_user_generic(to, from, n, 1);
+	else
+#endif
 	if (movsl_is_ok(to, from, n))
 		__copy_user_zeroing(to, from, n);
 	else
@@ -835,6 +879,11 @@
 unsigned long __copy_from_user_ll_nozero(void *to, const void __user *from,
 					 unsigned long n)
 {
+#ifdef CONFIG_KRG_FAF
+	if (check_ruaccess())
+		n = krg_copy_user_generic(to, from, n, 0);
+	else
+#endif
 	if (movsl_is_ok(to, from, n))
 		__copy_user(to, from, n);
 	else
@@ -847,6 +896,11 @@
 unsigned long __copy_from_user_ll_nocache(void *to, const void __user *from,
 					unsigned long n)
 {
+#ifdef CONFIG_KRG_FAF
+	if (check_ruaccess())
+		n = krg_copy_user_generic(to, from, n, 1);
+	else
+#endif
 #ifdef CONFIG_X86_INTEL_USERCOPY
 	if (n > 64 && cpu_has_xmm2)
 		n = __copy_user_zeroing_intel_nocache(to, from, n);
@@ -862,6 +916,11 @@
 unsigned long __copy_from_user_ll_nocache_nozero(void *to, const void __user *from,
 					unsigned long n)
 {
+#ifdef CONFIG_KRG_FAF
+	if (check_ruaccess())
+		n = krg_copy_user_generic(to, from, n, 0);
+	else
+#endif
 #ifdef CONFIG_X86_INTEL_USERCOPY
 	if (n > 64 && cpu_has_xmm2)
 		n = __copy_user_intel_nocache(to, from, n);
--- arch/x86/configs/x86_64_defconfig
+++ arch/x86/configs/x86_64_defconfig
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.29-rc4
-# Tue Feb 24 15:44:16 2009
+# Linux kernel version: 2.6.30
+# Thu Jul  2 18:06:32 2009
 #
 CONFIG_64BIT=y
 # CONFIG_X86_32 is not set
@@ -34,6 +34,7 @@
 CONFIG_ARCH_HAS_DEFAULT_IDLE=y
 CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
 CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_HAVE_DYNAMIC_PER_CPU_AREA=y
 CONFIG_HAVE_CPUMASK_OF_CPU_MAP=y
 CONFIG_ARCH_HIBERNATION_POSSIBLE=y
 CONFIG_ARCH_SUSPEND_POSSIBLE=y
@@ -41,14 +42,14 @@
 CONFIG_ARCH_POPULATES_NODE_MAP=y
 CONFIG_AUDIT_ARCH=y
 CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
 CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
 CONFIG_GENERIC_IRQ_PROBE=y
 CONFIG_GENERIC_PENDING_IRQ=y
-CONFIG_X86_SMP=y
 CONFIG_USE_GENERIC_SMP_HELPERS=y
 CONFIG_X86_64_SMP=y
 CONFIG_X86_HT=y
-CONFIG_X86_BIOS_REBOOT=y
 CONFIG_X86_TRAMPOLINE=y
 # CONFIG_KTIME_SCALAR is not set
 CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
@@ -61,10 +62,17 @@
 CONFIG_INIT_ENV_ARG_LIMIT=32
 CONFIG_LOCALVERSION=""
 # CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 CONFIG_SYSVIPC_SYSCTL=y
 CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
 CONFIG_BSD_PROCESS_ACCT=y
 # CONFIG_BSD_PROCESS_ACCT_V3 is not set
 CONFIG_TASKSTATS=y
@@ -114,23 +122,25 @@
 CONFIG_NET_NS=y
 CONFIG_BLK_DEV_INITRD=y
 CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
 CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
 # CONFIG_EMBEDDED is not set
-CONFIG_UID16=y
 CONFIG_SYSCTL_SYSCALL=y
 CONFIG_KALLSYMS=y
 CONFIG_KALLSYMS_ALL=y
 CONFIG_KALLSYMS_EXTRA_PASS=y
+# CONFIG_STRIP_ASM_SYMS is not set
 CONFIG_HOTPLUG=y
 CONFIG_PRINTK=y
 CONFIG_BUG=y
 CONFIG_ELF_CORE=y
 CONFIG_PCSPKR_PLATFORM=y
-# CONFIG_COMPAT_BRK is not set
 CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
-CONFIG_ANON_INODES=y
 CONFIG_EPOLL=y
 CONFIG_SIGNALFD=y
 CONFIG_TIMERFD=y
@@ -140,6 +150,7 @@
 CONFIG_VM_EVENT_COUNTERS=y
 CONFIG_PCI_QUIRKS=y
 CONFIG_SLUB_DEBUG=y
+# CONFIG_COMPAT_BRK is not set
 # CONFIG_SLAB is not set
 CONFIG_SLUB=y
 # CONFIG_SLOB is not set
@@ -155,6 +166,8 @@
 CONFIG_HAVE_KPROBES=y
 CONFIG_HAVE_KRETPROBES=y
 CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+# CONFIG_SLOW_WORK is not set
 # CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
 CONFIG_SLABINFO=y
 CONFIG_RT_MUTEXES=y
@@ -167,10 +180,8 @@
 # CONFIG_MODULE_SRCVERSION_ALL is not set
 CONFIG_STOP_MACHINE=y
 CONFIG_BLOCK=y
-CONFIG_BLK_DEV_IO_TRACE=y
 CONFIG_BLK_DEV_BSG=y
 # CONFIG_BLK_DEV_INTEGRITY is not set
-CONFIG_BLOCK_COMPAT=y
 
 #
 # IO Schedulers
@@ -195,12 +206,10 @@
 CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
 CONFIG_SMP=y
 CONFIG_SPARSE_IRQ=y
-# CONFIG_NUMA_MIGRATE_IRQ_DESC is not set
-CONFIG_X86_FIND_SMP_CONFIG=y
 CONFIG_X86_MPPARSE=y
-# CONFIG_X86_ELAN is not set
-# CONFIG_X86_GENERICARCH is not set
+CONFIG_X86_EXTENDED_PLATFORM=y
 # CONFIG_X86_VSMP is not set
+# CONFIG_X86_UV is not set
 CONFIG_SCHED_OMIT_FRAME_POINTER=y
 # CONFIG_PARAVIRT_GUEST is not set
 # CONFIG_MEMTEST is not set
@@ -230,10 +239,10 @@
 # CONFIG_MCORE2 is not set
 CONFIG_GENERIC_CPU=y
 CONFIG_X86_CPU=y
-CONFIG_X86_L1_CACHE_BYTES=128
-CONFIG_X86_INTERNODE_CACHE_BYTES=128
+CONFIG_X86_L1_CACHE_BYTES=64
+CONFIG_X86_INTERNODE_CACHE_BYTES=64
 CONFIG_X86_CMPXCHG=y
-CONFIG_X86_L1_CACHE_SHIFT=7
+CONFIG_X86_L1_CACHE_SHIFT=6
 CONFIG_X86_WP_WORKS_OK=y
 CONFIG_X86_TSC=y
 CONFIG_X86_CMPXCHG64=y
@@ -242,9 +251,8 @@
 CONFIG_X86_DEBUGCTLMSR=y
 CONFIG_CPU_SUP_INTEL=y
 CONFIG_CPU_SUP_AMD=y
-CONFIG_CPU_SUP_CENTAUR_64=y
-CONFIG_X86_DS=y
-CONFIG_X86_PTRACE_BTS=y
+CONFIG_CPU_SUP_CENTAUR=y
+# CONFIG_X86_DS is not set
 CONFIG_HPET_TIMER=y
 CONFIG_HPET_EMULATE_RTC=y
 CONFIG_DMI=y
@@ -269,6 +277,7 @@
 CONFIG_X86_MCE=y
 CONFIG_X86_MCE_INTEL=y
 CONFIG_X86_MCE_AMD=y
+CONFIG_X86_MCE_THRESHOLD=y
 # CONFIG_I8K is not set
 CONFIG_MICROCODE=y
 CONFIG_MICROCODE_INTEL=y
@@ -276,6 +285,7 @@
 CONFIG_MICROCODE_OLD_INTERFACE=y
 CONFIG_X86_MSR=y
 CONFIG_X86_CPUID=y
+# CONFIG_X86_CPU_DEBUG is not set
 CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
 CONFIG_DIRECT_GBPAGES=y
 CONFIG_NUMA=y
@@ -309,6 +319,8 @@
 CONFIG_BOUNCE=y
 CONFIG_VIRT_TO_BUS=y
 CONFIG_UNEVICTABLE_LRU=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
 CONFIG_X86_CHECK_BIOS_CORRUPTION=y
 CONFIG_X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK=y
 CONFIG_X86_RESERVE_LOW_64K=y
@@ -317,6 +329,7 @@
 CONFIG_X86_PAT=y
 CONFIG_EFI=y
 CONFIG_SECCOMP=y
+# CONFIG_CC_STACKPROTECTOR is not set
 # CONFIG_HZ_100 is not set
 # CONFIG_HZ_250 is not set
 # CONFIG_HZ_300 is not set
@@ -325,11 +338,11 @@
 CONFIG_SCHED_HRTICK=y
 CONFIG_KEXEC=y
 CONFIG_CRASH_DUMP=y
+# CONFIG_KEXEC_JUMP is not set
 CONFIG_PHYSICAL_START=0x1000000
 # CONFIG_RELOCATABLE is not set
 CONFIG_PHYSICAL_ALIGN=0x200000
 CONFIG_HOTPLUG_CPU=y
-# CONFIG_COMPAT_VDSO is not set
 # CONFIG_CMDLINE_BOOL is not set
 CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
 CONFIG_HAVE_ARCH_EARLY_PFN_TO_NID=y
@@ -371,7 +385,6 @@
 CONFIG_ACPI_BLACKLIST_YEAR=0
 # CONFIG_ACPI_DEBUG is not set
 # CONFIG_ACPI_PCI_SLOT is not set
-CONFIG_ACPI_SYSTEM=y
 CONFIG_X86_PM_TIMER=y
 CONFIG_ACPI_CONTAINER=y
 # CONFIG_ACPI_SBS is not set
@@ -437,6 +450,7 @@
 # CONFIG_PCI_DEBUG is not set
 # CONFIG_PCI_STUB is not set
 CONFIG_HT_IRQ=y
+# CONFIG_PCI_IOV is not set
 CONFIG_ISA_DMA_API=y
 CONFIG_K8_NB=y
 CONFIG_PCCARD=y
@@ -468,21 +482,16 @@
 # Executable file formats / Emulations
 #
 CONFIG_BINFMT_ELF=y
-CONFIG_COMPAT_BINFMT_ELF=y
 CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
 # CONFIG_HAVE_AOUT is not set
 CONFIG_BINFMT_MISC=y
-CONFIG_IA32_EMULATION=y
-# CONFIG_IA32_AOUT is not set
-CONFIG_COMPAT=y
-CONFIG_COMPAT_FOR_U64_ALIGNMENT=y
-CONFIG_SYSVIPC_COMPAT=y
+# CONFIG_IA32_EMULATION is not set
+# CONFIG_COMPAT_FOR_U64_ALIGNMENT is not set
 CONFIG_NET=y
 
 #
 # Networking options
 #
-CONFIG_COMPAT_NET_DEV_OPS=y
 CONFIG_PACKET=y
 CONFIG_PACKET_MMAP=y
 CONFIG_UNIX=y
@@ -647,6 +663,7 @@
 # CONFIG_LAPB is not set
 # CONFIG_ECONET is not set
 # CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
 CONFIG_NET_SCHED=y
 
 #
@@ -704,6 +721,7 @@
 #
 # CONFIG_NET_PKTGEN is not set
 # CONFIG_NET_TCPPROBE is not set
+# CONFIG_NET_DROP_MONITOR is not set
 CONFIG_HAMRADIO=y
 
 #
@@ -714,12 +732,10 @@
 # CONFIG_IRDA is not set
 # CONFIG_BT is not set
 # CONFIG_AF_RXRPC is not set
-# CONFIG_PHONET is not set
 CONFIG_FIB_RULES=y
 CONFIG_WIRELESS=y
 CONFIG_CFG80211=y
 # CONFIG_CFG80211_REG_DEBUG is not set
-CONFIG_NL80211=y
 CONFIG_WIRELESS_OLD_REGULATORY=y
 CONFIG_WIRELESS_EXT=y
 CONFIG_WIRELESS_EXT_SYSFS=y
@@ -843,9 +906,8 @@
 # CONFIG_TIFM_CORE is not set
 # CONFIG_ICS932S401 is not set
 # CONFIG_ENCLOSURE_SERVICES is not set
-# CONFIG_SGI_XP is not set
 # CONFIG_HP_ILO is not set
-# CONFIG_SGI_GRU is not set
+# CONFIG_ISL29003 is not set
 # CONFIG_C2PORT is not set
 
 #
@@ -899,6 +961,7 @@
 # CONFIG_SCSI_LOWLEVEL is not set
 # CONFIG_SCSI_LOWLEVEL_PCMCIA is not set
 # CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
 CONFIG_ATA=y
 # CONFIG_ATA_NONSTANDARD is not set
 CONFIG_ATA_ACPI=y
@@ -995,6 +1058,7 @@
 CONFIG_MACINTOSH_DRIVERS=y
 CONFIG_MAC_EMUMOUSEBTN=y
 CONFIG_NETDEVICES=y
+CONFIG_COMPAT_NET_DEV_OPS=y
 # CONFIG_IFB is not set
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
@@ -1032,6 +1096,8 @@
 CONFIG_NET_VENDOR_3COM=y
 # CONFIG_VORTEX is not set
 # CONFIG_TYPHOON is not set
+# CONFIG_ETHOC is not set
+# CONFIG_DNET is not set
 CONFIG_NET_TULIP=y
 # CONFIG_DE2104X is not set
 # CONFIG_TULIP is not set
@@ -1081,6 +1147,7 @@
 # CONFIG_E1000E is not set
 # CONFIG_IP1000 is not set
 # CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
 # CONFIG_NS83820 is not set
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
@@ -1095,6 +1162,7 @@
 # CONFIG_QLA3XXX is not set
 # CONFIG_ATL1 is not set
 # CONFIG_ATL1E is not set
+# CONFIG_ATL1C is not set
 # CONFIG_JME is not set
 CONFIG_NETDEV_10000=y
 # CONFIG_CHELSIO_T1 is not set
@@ -1104,6 +1172,7 @@
 # CONFIG_IXGBE is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
+# CONFIG_VXGE is not set
 # CONFIG_MYRI10GE is not set
 # CONFIG_NETXEN_NIC is not set
 # CONFIG_NIU is not set
@@ -1113,6 +1182,7 @@
 # CONFIG_BNX2X is not set
 # CONFIG_QLGE is not set
 # CONFIG_SFC is not set
+# CONFIG_BE2NET is not set
 CONFIG_TR=y
 # CONFIG_IBMOL is not set
 # CONFIG_3C359 is not set
@@ -1127,8 +1197,8 @@
 # CONFIG_LIBERTAS is not set
 # CONFIG_LIBERTAS_THINFIRM is not set
 # CONFIG_AIRO is not set
-# CONFIG_HERMES is not set
 # CONFIG_ATMEL is not set
+# CONFIG_AT76C50X_USB is not set
 # CONFIG_AIRO_CS is not set
 # CONFIG_PCMCIA_WL3501 is not set
 # CONFIG_PRISM54 is not set
@@ -1138,21 +1208,21 @@
 # CONFIG_RTL8187 is not set
 # CONFIG_ADM8211 is not set
 # CONFIG_MAC80211_HWSIM is not set
+# CONFIG_MWL8K is not set
 # CONFIG_P54_COMMON is not set
 CONFIG_ATH5K=y
 # CONFIG_ATH5K_DEBUG is not set
 # CONFIG_ATH9K is not set
+# CONFIG_AR9170_USB is not set
 # CONFIG_IPW2100 is not set
 # CONFIG_IPW2200 is not set
-# CONFIG_IWLCORE is not set
-# CONFIG_IWLWIFI_LEDS is not set
-# CONFIG_IWLAGN is not set
-# CONFIG_IWL3945 is not set
+# CONFIG_IWLWIFI is not set
 # CONFIG_HOSTAP is not set
 # CONFIG_B43 is not set
 # CONFIG_B43LEGACY is not set
 # CONFIG_ZD1211RW is not set
 # CONFIG_RT2X00 is not set
+# CONFIG_HERMES is not set
 
 #
 # Enable WiMAX (Networking options) to see the WiMAX drivers
@@ -1263,6 +1333,8 @@
 # CONFIG_TABLET_USB_KBTAB is not set
 # CONFIG_TABLET_USB_WACOM is not set
 CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
 # CONFIG_TOUCHSCREEN_FUJITSU is not set
 # CONFIG_TOUCHSCREEN_GUNZE is not set
 # CONFIG_TOUCHSCREEN_ELO is not set
@@ -1356,6 +1428,7 @@
 # CONFIG_LEGACY_PTYS is not set
 # CONFIG_IPMI_HANDLER is not set
 CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
 # CONFIG_HW_RANDOM_INTEL is not set
 # CONFIG_HW_RANDOM_AMD is not set
 CONFIG_NVRAM=y
@@ -1437,7 +1510,6 @@
 # CONFIG_SENSORS_PCF8574 is not set
 # CONFIG_PCF8575 is not set
 # CONFIG_SENSORS_PCA9539 is not set
-# CONFIG_SENSORS_PCF8591 is not set
 # CONFIG_SENSORS_MAX6875 is not set
 # CONFIG_SENSORS_TSL2550 is not set
 # CONFIG_I2C_DEBUG_CORE is not set
@@ -1471,6 +1543,7 @@
 # CONFIG_SENSORS_ADT7475 is not set
 # CONFIG_SENSORS_K8TEMP is not set
 # CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATK0110 is not set
 # CONFIG_SENSORS_ATXP1 is not set
 # CONFIG_SENSORS_DS1621 is not set
 # CONFIG_SENSORS_I5K_AMB is not set
@@ -1480,6 +1553,7 @@
 # CONFIG_SENSORS_FSCHER is not set
 # CONFIG_SENSORS_FSCPOS is not set
 # CONFIG_SENSORS_FSCHMD is not set
+# CONFIG_SENSORS_G760A is not set
 # CONFIG_SENSORS_GL518SM is not set
 # CONFIG_SENSORS_GL520SM is not set
 # CONFIG_SENSORS_CORETEMP is not set
@@ -1495,11 +1569,14 @@
 # CONFIG_SENSORS_LM90 is not set
 # CONFIG_SENSORS_LM92 is not set
 # CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4215 is not set
 # CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LM95241 is not set
 # CONFIG_SENSORS_MAX1619 is not set
 # CONFIG_SENSORS_MAX6650 is not set
 # CONFIG_SENSORS_PC87360 is not set
 # CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
 # CONFIG_SENSORS_SIS5595 is not set
 # CONFIG_SENSORS_DME1737 is not set
 # CONFIG_SENSORS_SMSC47M1 is not set
@@ -1690,6 +1767,7 @@
 # CONFIG_FB_VIRTUAL is not set
 # CONFIG_FB_METRONOME is not set
 # CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
 CONFIG_BACKLIGHT_LCD_SUPPORT=y
 # CONFIG_LCD_CLASS_DEVICE is not set
 CONFIG_BACKLIGHT_CLASS_DEVICE=y
@@ -1780,6 +1863,8 @@
 # CONFIG_SND_INDIGO is not set
 # CONFIG_SND_INDIGOIO is not set
 # CONFIG_SND_INDIGODJ is not set
+# CONFIG_SND_INDIGOIOX is not set
+# CONFIG_SND_INDIGODJX is not set
 # CONFIG_SND_EMU10K1 is not set
 # CONFIG_SND_EMU10K1X is not set
 # CONFIG_SND_ENS1370 is not set
@@ -1852,15 +1937,17 @@
 #
 # Special HID drivers
 #
-CONFIG_HID_COMPAT=y
 CONFIG_HID_A4TECH=y
 CONFIG_HID_APPLE=y
 CONFIG_HID_BELKIN=y
 CONFIG_HID_CHERRY=y
 CONFIG_HID_CHICONY=y
 CONFIG_HID_CYPRESS=y
+# CONFIG_DRAGONRISE_FF is not set
 CONFIG_HID_EZKEY=y
+CONFIG_HID_KYE=y
 CONFIG_HID_GYRATION=y
+CONFIG_HID_KENSINGTON=y
 CONFIG_HID_LOGITECH=y
 CONFIG_LOGITECH_FF=y
 # CONFIG_LOGIRUMBLEPAD2_FF is not set
@@ -1926,11 +2013,11 @@
 # CONFIG_USB_TMC is not set
 
 #
-# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
 #
 
 #
-# see USB_STORAGE Help for more information
+# also be needed; see USB_STORAGE Help for more info
 #
 CONFIG_USB_STORAGE=y
 # CONFIG_USB_STORAGE_DEBUG is not set
@@ -1972,7 +2059,6 @@
 # CONFIG_USB_LED is not set
 # CONFIG_USB_CYPRESS_CY7C63 is not set
 # CONFIG_USB_CYTHERM is not set
-# CONFIG_USB_PHIDGET is not set
 # CONFIG_USB_IDMOUSE is not set
 # CONFIG_USB_FTDI_ELAN is not set
 # CONFIG_USB_APPLEDISPLAY is not set
@@ -1988,6 +2074,7 @@
 #
 # OTG and related infrastructure
 #
+# CONFIG_NOP_USB_XCEIV is not set
 # CONFIG_UWB is not set
 # CONFIG_MMC is not set
 # CONFIG_MEMSTICK is not set
@@ -1999,8 +2086,10 @@
 #
 # CONFIG_LEDS_ALIX2 is not set
 # CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_LP5521 is not set
 # CONFIG_LEDS_CLEVO_MAIL is not set
 # CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_BD2802 is not set
 
 #
 # LED Triggers
@@ -2010,6 +2099,10 @@
 # CONFIG_LEDS_TRIGGER_HEARTBEAT is not set
 # CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
 # CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
 # CONFIG_ACCESSIBILITY is not set
 # CONFIG_INFINIBAND is not set
 CONFIG_EDAC=y
@@ -2078,6 +2171,7 @@
 # DMA Devices
 #
 # CONFIG_INTEL_IOATDMA is not set
+# CONFIG_AUXDISPLAY is not set
 # CONFIG_UIO is not set
 # CONFIG_STAGING is not set
 CONFIG_X86_PLATFORM_DEVICES=y
@@ -2111,6 +2205,7 @@
 #
 # CONFIG_EXT2_FS is not set
 CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
 CONFIG_EXT3_FS_XATTR=y
 CONFIG_EXT3_FS_POSIX_ACL=y
 CONFIG_EXT3_FS_SECURITY=y
@@ -2196,6 +2295,7 @@
 # CONFIG_ROMFS_FS is not set
 # CONFIG_SYSV_FS is not set
 # CONFIG_UFS_FS is not set
+# CONFIG_NILFS2_FS is not set
 CONFIG_NETWORK_FILESYSTEMS=y
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
@@ -2209,7 +2309,6 @@
 CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 CONFIG_SUNRPC_GSS=y
-# CONFIG_SUNRPC_REGISTER_V4 is not set
 CONFIG_RPCSEC_GSS_KRB5=y
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
 # CONFIG_SMB_FS is not set
@@ -2296,6 +2395,7 @@
 CONFIG_DEBUG_KERNEL=y
 # CONFIG_DEBUG_SHIRQ is not set
 # CONFIG_DETECT_SOFTLOCKUP is not set
+# CONFIG_DETECT_HUNG_TASK is not set
 # CONFIG_SCHED_DEBUG is not set
 CONFIG_SCHEDSTATS=y
 CONFIG_TIMER_STATS=y
@@ -2311,6 +2411,7 @@
 # CONFIG_LOCK_STAT is not set
 # CONFIG_DEBUG_SPINLOCK_SLEEP is not set
 # CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
 # CONFIG_DEBUG_KOBJECT is not set
 CONFIG_DEBUG_BUGVERBOSE=y
 # CONFIG_DEBUG_INFO is not set
@@ -2333,13 +2434,18 @@
 # CONFIG_FAULT_INJECTION is not set
 # CONFIG_LATENCYTOP is not set
 CONFIG_SYSCTL_SYSCALL_CHECK=y
+# CONFIG_DEBUG_PAGEALLOC is not set
 CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_NOP_TRACER=y
 CONFIG_HAVE_FUNCTION_TRACER=y
 CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
 CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST=y
 CONFIG_HAVE_DYNAMIC_FTRACE=y
 CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
-CONFIG_HAVE_HW_BRANCH_TRACER=y
+CONFIG_HAVE_FTRACE_SYSCALLS=y
+CONFIG_RING_BUFFER=y
+CONFIG_TRACING=y
+CONFIG_TRACING_SUPPORT=y
 
 #
 # Tracers
@@ -2349,13 +2455,20 @@
 # CONFIG_SYSPROF_TRACER is not set
 # CONFIG_SCHED_TRACER is not set
 # CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_EVENT_TRACER is not set
+# CONFIG_FTRACE_SYSCALLS is not set
 # CONFIG_BOOT_TRACER is not set
 # CONFIG_TRACE_BRANCH_PROFILING is not set
 # CONFIG_POWER_TRACER is not set
 # CONFIG_STACK_TRACER is not set
-# CONFIG_HW_BRANCH_TRACER is not set
+# CONFIG_KMEMTRACE is not set
+# CONFIG_WORKQUEUE_TRACER is not set
+CONFIG_BLK_DEV_IO_TRACE=y
+# CONFIG_FTRACE_STARTUP_TEST is not set
+# CONFIG_MMIOTRACE is not set
 CONFIG_PROVIDE_OHCI1394_DMA_INIT=y
-# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
 # CONFIG_SAMPLES is not set
 CONFIG_HAVE_ARCH_KGDB=y
 # CONFIG_KGDB is not set
@@ -2365,14 +2478,13 @@
 CONFIG_EARLY_PRINTK_DBGP=y
 CONFIG_DEBUG_STACKOVERFLOW=y
 CONFIG_DEBUG_STACK_USAGE=y
-# CONFIG_DEBUG_PAGEALLOC is not set
 # CONFIG_DEBUG_PER_CPU_MAPS is not set
 # CONFIG_X86_PTDUMP is not set
 CONFIG_DEBUG_RODATA=y
 # CONFIG_DEBUG_RODATA_TEST is not set
 CONFIG_DEBUG_NX_TEST=m
 # CONFIG_IOMMU_DEBUG is not set
-# CONFIG_MMIOTRACE is not set
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
 CONFIG_IO_DELAY_TYPE_0X80=0
 CONFIG_IO_DELAY_TYPE_0XED=1
 CONFIG_IO_DELAY_TYPE_UDELAY=2
@@ -2389,25 +2501,11 @@
 #
 # Security options
 #
-CONFIG_KEYS=y
-CONFIG_KEYS_DEBUG_PROC_KEYS=y
-CONFIG_SECURITY=y
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
 # CONFIG_SECURITYFS is not set
-CONFIG_SECURITY_NETWORK=y
-# CONFIG_SECURITY_NETWORK_XFRM is not set
-# CONFIG_SECURITY_PATH is not set
 CONFIG_SECURITY_FILE_CAPABILITIES=y
-# CONFIG_SECURITY_ROOTPLUG is not set
-CONFIG_SECURITY_DEFAULT_MMAP_MIN_ADDR=65536
-CONFIG_SECURITY_SELINUX=y
-CONFIG_SECURITY_SELINUX_BOOTPARAM=y
-CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE=1
-CONFIG_SECURITY_SELINUX_DISABLE=y
-CONFIG_SECURITY_SELINUX_DEVELOP=y
-CONFIG_SECURITY_SELINUX_AVC_STATS=y
-CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE=1
-# CONFIG_SECURITY_SELINUX_POLICYDB_VERSION_MAX is not set
-# CONFIG_SECURITY_SMACK is not set
+# CONFIG_IMA is not set
 CONFIG_CRYPTO=y
 
 #
@@ -2423,10 +2521,12 @@
 CONFIG_CRYPTO_HASH=y
 CONFIG_CRYPTO_HASH2=y
 CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
 CONFIG_CRYPTO_MANAGER=y
 CONFIG_CRYPTO_MANAGER2=y
 # CONFIG_CRYPTO_GF128MUL is not set
 # CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
 # CONFIG_CRYPTO_CRYPTD is not set
 CONFIG_CRYPTO_AUTHENC=y
 # CONFIG_CRYPTO_TEST is not set
@@ -2478,6 +2578,7 @@
 #
 CONFIG_CRYPTO_AES=y
 # CONFIG_CRYPTO_AES_X86_64 is not set
+# CONFIG_CRYPTO_AES_NI_INTEL is not set
 # CONFIG_CRYPTO_ANUBIS is not set
 CONFIG_CRYPTO_ARC4=y
 # CONFIG_CRYPTO_BLOWFISH is not set
@@ -2499,6 +2600,7 @@
 # Compression
 #
 # CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
 # CONFIG_CRYPTO_LZO is not set
 
 #
@@ -2508,10 +2610,12 @@
 CONFIG_CRYPTO_HW=y
 # CONFIG_CRYPTO_DEV_HIFN_795X is not set
 CONFIG_HAVE_KVM=y
+CONFIG_HAVE_KVM_IRQCHIP=y
 CONFIG_VIRTUALIZATION=y
 # CONFIG_KVM is not set
 # CONFIG_VIRTIO_PCI is not set
 # CONFIG_VIRTIO_BALLOON is not set
+CONFIG_BINARY_PRINTF=y
 
 #
 # Library routines
@@ -2528,7 +2632,11 @@
 # CONFIG_CRC7 is not set
 # CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
-CONFIG_PLIST=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
 CONFIG_HAS_IOMEM=y
 CONFIG_HAS_IOPORT=y
 CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
+CONFIG_MODULE_HOOK=y
--- arch/x86/configs/i386_defconfig
+++ arch/x86/configs/i386_defconfig
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.29-rc4
-# Tue Feb 24 15:50:58 2009
+# Linux kernel version: 2.6.30
+# Thu Jul  2 17:52:27 2009
 #
 # CONFIG_64BIT is not set
 CONFIG_X86_32=y
@@ -33,6 +33,7 @@
 CONFIG_ARCH_HAS_DEFAULT_IDLE=y
 CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
 CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_HAVE_DYNAMIC_PER_CPU_AREA=y
 # CONFIG_HAVE_CPUMASK_OF_CPU_MAP is not set
 CONFIG_ARCH_HIBERNATION_POSSIBLE=y
 CONFIG_ARCH_SUSPEND_POSSIBLE=y
@@ -40,15 +41,16 @@
 CONFIG_ARCH_POPULATES_NODE_MAP=y
 # CONFIG_AUDIT_ARCH is not set
 CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
 CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
 CONFIG_GENERIC_IRQ_PROBE=y
 CONFIG_GENERIC_PENDING_IRQ=y
-CONFIG_X86_SMP=y
 CONFIG_USE_GENERIC_SMP_HELPERS=y
 CONFIG_X86_32_SMP=y
 CONFIG_X86_HT=y
-CONFIG_X86_BIOS_REBOOT=y
 CONFIG_X86_TRAMPOLINE=y
+CONFIG_X86_32_LAZY_GS=y
 CONFIG_KTIME_SCALAR=y
 CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
 
@@ -60,10 +62,17 @@
 CONFIG_INIT_ENV_ARG_LIMIT=32
 CONFIG_LOCALVERSION=""
 # CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 CONFIG_SYSVIPC_SYSCTL=y
 CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
 CONFIG_BSD_PROCESS_ACCT=y
 # CONFIG_BSD_PROCESS_ACCT_V3 is not set
 CONFIG_TASKSTATS=y
@@ -113,23 +122,26 @@
 CONFIG_NET_NS=y
 CONFIG_BLK_DEV_INITRD=y
 CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
 CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
 # CONFIG_EMBEDDED is not set
 CONFIG_UID16=y
 CONFIG_SYSCTL_SYSCALL=y
 CONFIG_KALLSYMS=y
 CONFIG_KALLSYMS_ALL=y
 CONFIG_KALLSYMS_EXTRA_PASS=y
+# CONFIG_STRIP_ASM_SYMS is not set
 CONFIG_HOTPLUG=y
 CONFIG_PRINTK=y
 CONFIG_BUG=y
 CONFIG_ELF_CORE=y
 CONFIG_PCSPKR_PLATFORM=y
-# CONFIG_COMPAT_BRK is not set
 CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
-CONFIG_ANON_INODES=y
 CONFIG_EPOLL=y
 CONFIG_SIGNALFD=y
 CONFIG_TIMERFD=y
@@ -139,6 +151,7 @@
 CONFIG_VM_EVENT_COUNTERS=y
 CONFIG_PCI_QUIRKS=y
 CONFIG_SLUB_DEBUG=y
+# CONFIG_COMPAT_BRK is not set
 # CONFIG_SLAB is not set
 CONFIG_SLUB=y
 # CONFIG_SLOB is not set
@@ -154,6 +167,8 @@
 CONFIG_HAVE_KPROBES=y
 CONFIG_HAVE_KRETPROBES=y
 CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+# CONFIG_SLOW_WORK is not set
 CONFIG_HAVE_GENERIC_DMA_COHERENT=y
 CONFIG_SLABINFO=y
 CONFIG_RT_MUTEXES=y
@@ -167,7 +182,6 @@
 CONFIG_STOP_MACHINE=y
 CONFIG_BLOCK=y
 # CONFIG_LBD is not set
-CONFIG_BLK_DEV_IO_TRACE=y
 CONFIG_BLK_DEV_BSG=y
 # CONFIG_BLK_DEV_INTEGRITY is not set
 
@@ -194,12 +208,12 @@
 CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
 CONFIG_SMP=y
 CONFIG_SPARSE_IRQ=y
-CONFIG_X86_FIND_SMP_CONFIG=y
 CONFIG_X86_MPPARSE=y
+# CONFIG_X86_BIGSMP is not set
+CONFIG_X86_EXTENDED_PLATFORM=y
 # CONFIG_X86_ELAN is not set
-# CONFIG_X86_GENERICARCH is not set
-# CONFIG_X86_VSMP is not set
 # CONFIG_X86_RDC321X is not set
+# CONFIG_X86_32_NON_STANDARD is not set
 CONFIG_SCHED_OMIT_FRAME_POINTER=y
 # CONFIG_PARAVIRT_GUEST is not set
 # CONFIG_MEMTEST is not set
@@ -230,8 +244,10 @@
 # CONFIG_GENERIC_CPU is not set
 CONFIG_X86_GENERIC=y
 CONFIG_X86_CPU=y
+CONFIG_X86_L1_CACHE_BYTES=64
+CONFIG_X86_INTERNODE_CACHE_BYTES=64
 CONFIG_X86_CMPXCHG=y
-CONFIG_X86_L1_CACHE_SHIFT=7
+CONFIG_X86_L1_CACHE_SHIFT=5
 CONFIG_X86_XADD=y
 # CONFIG_X86_PPRO_FENCE is not set
 CONFIG_X86_WP_WORKS_OK=y
@@ -247,21 +263,20 @@
 CONFIG_CPU_SUP_INTEL=y
 CONFIG_CPU_SUP_CYRIX_32=y
 CONFIG_CPU_SUP_AMD=y
-CONFIG_CPU_SUP_CENTAUR_32=y
+CONFIG_CPU_SUP_CENTAUR=y
 CONFIG_CPU_SUP_TRANSMETA_32=y
 CONFIG_CPU_SUP_UMC_32=y
-CONFIG_X86_DS=y
-CONFIG_X86_PTRACE_BTS=y
+# CONFIG_X86_DS is not set
 CONFIG_HPET_TIMER=y
 CONFIG_HPET_EMULATE_RTC=y
 CONFIG_DMI=y
 # CONFIG_IOMMU_HELPER is not set
 # CONFIG_IOMMU_API is not set
-CONFIG_NR_CPUS=64
+CONFIG_NR_CPUS=8
 CONFIG_SCHED_SMT=y
 CONFIG_SCHED_MC=y
-# CONFIG_PREEMPT_NONE is not set
-CONFIG_PREEMPT_VOLUNTARY=y
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 CONFIG_X86_LOCAL_APIC=y
 CONFIG_X86_IO_APIC=y
@@ -279,6 +294,7 @@
 CONFIG_MICROCODE_OLD_INTERFACE=y
 CONFIG_X86_MSR=y
 CONFIG_X86_CPUID=y
+# CONFIG_X86_CPU_DEBUG is not set
 # CONFIG_NOHIGHMEM is not set
 CONFIG_HIGHMEM4G=y
 # CONFIG_HIGHMEM64G is not set
@@ -302,6 +318,8 @@
 CONFIG_BOUNCE=y
 CONFIG_VIRT_TO_BUS=y
 CONFIG_UNEVICTABLE_LRU=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
 CONFIG_HIGHPTE=y
 CONFIG_X86_CHECK_BIOS_CORRUPTION=y
 CONFIG_X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK=y
@@ -312,6 +330,7 @@
 CONFIG_X86_PAT=y
 CONFIG_EFI=y
 CONFIG_SECCOMP=y
+# CONFIG_CC_STACKPROTECTOR is not set
 # CONFIG_HZ_100 is not set
 # CONFIG_HZ_250 is not set
 # CONFIG_HZ_300 is not set
@@ -364,7 +384,6 @@
 CONFIG_ACPI_BLACKLIST_YEAR=0
 # CONFIG_ACPI_DEBUG is not set
 # CONFIG_ACPI_PCI_SLOT is not set
-CONFIG_ACPI_SYSTEM=y
 CONFIG_X86_PM_TIMER=y
 CONFIG_ACPI_CONTAINER=y
 # CONFIG_ACPI_SBS is not set
@@ -426,6 +445,7 @@
 CONFIG_PCI_DIRECT=y
 CONFIG_PCI_MMCONFIG=y
 CONFIG_PCI_DOMAINS=y
+# CONFIG_DMAR is not set
 CONFIG_PCIEPORTBUS=y
 # CONFIG_HOTPLUG_PCI_PCIE is not set
 CONFIG_PCIEAER=y
@@ -436,6 +456,7 @@
 # CONFIG_PCI_DEBUG is not set
 # CONFIG_PCI_STUB is not set
 CONFIG_HT_IRQ=y
+# CONFIG_PCI_IOV is not set
 CONFIG_ISA_DMA_API=y
 # CONFIG_ISA is not set
 # CONFIG_MCA is not set
@@ -482,7 +503,6 @@
 #
 # Networking options
 #
-CONFIG_COMPAT_NET_DEV_OPS=y
 CONFIG_PACKET=y
 CONFIG_PACKET_MMAP=y
 CONFIG_UNIX=y
@@ -647,6 +674,7 @@
 # CONFIG_LAPB is not set
 # CONFIG_ECONET is not set
 # CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
 CONFIG_NET_SCHED=y
 
 #
@@ -704,6 +732,7 @@
 #
 # CONFIG_NET_PKTGEN is not set
 # CONFIG_NET_TCPPROBE is not set
+# CONFIG_NET_DROP_MONITOR is not set
 CONFIG_HAMRADIO=y
 
 #
@@ -714,12 +743,10 @@
 # CONFIG_IRDA is not set
 # CONFIG_BT is not set
 # CONFIG_AF_RXRPC is not set
-# CONFIG_PHONET is not set
 CONFIG_FIB_RULES=y
 CONFIG_WIRELESS=y
 CONFIG_CFG80211=y
 # CONFIG_CFG80211_REG_DEBUG is not set
-CONFIG_NL80211=y
 CONFIG_WIRELESS_OLD_REGULATORY=y
 CONFIG_WIRELESS_EXT=y
 CONFIG_WIRELESS_EXT_SYSFS=y
@@ -844,6 +918,7 @@
 # CONFIG_ICS932S401 is not set
 # CONFIG_ENCLOSURE_SERVICES is not set
 # CONFIG_HP_ILO is not set
+# CONFIG_ISL29003 is not set
 # CONFIG_C2PORT is not set
 
 #
@@ -897,6 +972,7 @@
 # CONFIG_SCSI_LOWLEVEL is not set
 # CONFIG_SCSI_LOWLEVEL_PCMCIA is not set
 # CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
 CONFIG_ATA=y
 # CONFIG_ATA_NONSTANDARD is not set
 CONFIG_ATA_ACPI=y
@@ -995,6 +1071,7 @@
 CONFIG_MACINTOSH_DRIVERS=y
 CONFIG_MAC_EMUMOUSEBTN=y
 CONFIG_NETDEVICES=y
+CONFIG_COMPAT_NET_DEV_OPS=y
 # CONFIG_IFB is not set
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
@@ -1032,6 +1109,8 @@
 CONFIG_NET_VENDOR_3COM=y
 # CONFIG_VORTEX is not set
 # CONFIG_TYPHOON is not set
+# CONFIG_ETHOC is not set
+# CONFIG_DNET is not set
 CONFIG_NET_TULIP=y
 # CONFIG_DE2104X is not set
 # CONFIG_TULIP is not set
@@ -1081,6 +1160,7 @@
 CONFIG_E1000E=y
 # CONFIG_IP1000 is not set
 # CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
 # CONFIG_NS83820 is not set
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
@@ -1095,6 +1175,7 @@
 # CONFIG_QLA3XXX is not set
 # CONFIG_ATL1 is not set
 # CONFIG_ATL1E is not set
+# CONFIG_ATL1C is not set
 # CONFIG_JME is not set
 CONFIG_NETDEV_10000=y
 # CONFIG_CHELSIO_T1 is not set
@@ -1104,6 +1185,7 @@
 # CONFIG_IXGBE is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
+# CONFIG_VXGE is not set
 # CONFIG_MYRI10GE is not set
 # CONFIG_NETXEN_NIC is not set
 # CONFIG_NIU is not set
@@ -1113,6 +1195,7 @@
 # CONFIG_BNX2X is not set
 # CONFIG_QLGE is not set
 # CONFIG_SFC is not set
+# CONFIG_BE2NET is not set
 CONFIG_TR=y
 # CONFIG_IBMOL is not set
 # CONFIG_IBMLS is not set
@@ -1128,8 +1211,8 @@
 # CONFIG_LIBERTAS is not set
 # CONFIG_LIBERTAS_THINFIRM is not set
 # CONFIG_AIRO is not set
-# CONFIG_HERMES is not set
 # CONFIG_ATMEL is not set
+# CONFIG_AT76C50X_USB is not set
 # CONFIG_AIRO_CS is not set
 # CONFIG_PCMCIA_WL3501 is not set
 # CONFIG_PRISM54 is not set
@@ -1139,21 +1222,21 @@
 # CONFIG_RTL8187 is not set
 # CONFIG_ADM8211 is not set
 # CONFIG_MAC80211_HWSIM is not set
+# CONFIG_MWL8K is not set
 # CONFIG_P54_COMMON is not set
 CONFIG_ATH5K=y
 # CONFIG_ATH5K_DEBUG is not set
 # CONFIG_ATH9K is not set
+# CONFIG_AR9170_USB is not set
 # CONFIG_IPW2100 is not set
 # CONFIG_IPW2200 is not set
-# CONFIG_IWLCORE is not set
-# CONFIG_IWLWIFI_LEDS is not set
-# CONFIG_IWLAGN is not set
-# CONFIG_IWL3945 is not set
+# CONFIG_IWLWIFI is not set
 # CONFIG_HOSTAP is not set
 # CONFIG_B43 is not set
 # CONFIG_B43LEGACY is not set
 # CONFIG_ZD1211RW is not set
 # CONFIG_RT2X00 is not set
+# CONFIG_HERMES is not set
 
 #
 # Enable WiMAX (Networking options) to see the WiMAX drivers
@@ -1264,6 +1347,8 @@
 # CONFIG_TABLET_USB_KBTAB is not set
 # CONFIG_TABLET_USB_WACOM is not set
 CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
 # CONFIG_TOUCHSCREEN_FUJITSU is not set
 # CONFIG_TOUCHSCREEN_GUNZE is not set
 # CONFIG_TOUCHSCREEN_ELO is not set
@@ -1358,6 +1443,7 @@
 # CONFIG_LEGACY_PTYS is not set
 # CONFIG_IPMI_HANDLER is not set
 CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
 CONFIG_HW_RANDOM_INTEL=y
 CONFIG_HW_RANDOM_AMD=y
 CONFIG_HW_RANDOM_GEODE=y
@@ -1445,7 +1531,6 @@
 # CONFIG_SENSORS_PCF8574 is not set
 # CONFIG_PCF8575 is not set
 # CONFIG_SENSORS_PCA9539 is not set
-# CONFIG_SENSORS_PCF8591 is not set
 # CONFIG_SENSORS_MAX6875 is not set
 # CONFIG_SENSORS_TSL2550 is not set
 # CONFIG_I2C_DEBUG_CORE is not set
@@ -1479,6 +1564,7 @@
 # CONFIG_SENSORS_ADT7475 is not set
 # CONFIG_SENSORS_K8TEMP is not set
 # CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATK0110 is not set
 # CONFIG_SENSORS_ATXP1 is not set
 # CONFIG_SENSORS_DS1621 is not set
 # CONFIG_SENSORS_I5K_AMB is not set
@@ -1488,6 +1574,7 @@
 # CONFIG_SENSORS_FSCHER is not set
 # CONFIG_SENSORS_FSCPOS is not set
 # CONFIG_SENSORS_FSCHMD is not set
+# CONFIG_SENSORS_G760A is not set
 # CONFIG_SENSORS_GL518SM is not set
 # CONFIG_SENSORS_GL520SM is not set
 # CONFIG_SENSORS_CORETEMP is not set
@@ -1503,11 +1590,14 @@
 # CONFIG_SENSORS_LM90 is not set
 # CONFIG_SENSORS_LM92 is not set
 # CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4215 is not set
 # CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LM95241 is not set
 # CONFIG_SENSORS_MAX1619 is not set
 # CONFIG_SENSORS_MAX6650 is not set
 # CONFIG_SENSORS_PC87360 is not set
 # CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
 # CONFIG_SENSORS_SIS5595 is not set
 # CONFIG_SENSORS_DME1737 is not set
 # CONFIG_SENSORS_SMSC47M1 is not set
@@ -1698,7 +1788,6 @@
 # CONFIG_FB_3DFX is not set
 # CONFIG_FB_VOODOO1 is not set
 # CONFIG_FB_VT8623 is not set
-# CONFIG_FB_CYBLA is not set
 # CONFIG_FB_TRIDENT is not set
 # CONFIG_FB_ARK is not set
 # CONFIG_FB_PM3 is not set
@@ -1707,6 +1796,7 @@
 # CONFIG_FB_VIRTUAL is not set
 # CONFIG_FB_METRONOME is not set
 # CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
 CONFIG_BACKLIGHT_LCD_SUPPORT=y
 # CONFIG_LCD_CLASS_DEVICE is not set
 CONFIG_BACKLIGHT_CLASS_DEVICE=y
@@ -1798,6 +1893,8 @@
 # CONFIG_SND_INDIGO is not set
 # CONFIG_SND_INDIGOIO is not set
 # CONFIG_SND_INDIGODJ is not set
+# CONFIG_SND_INDIGOIOX is not set
+# CONFIG_SND_INDIGODJX is not set
 # CONFIG_SND_EMU10K1 is not set
 # CONFIG_SND_EMU10K1X is not set
 # CONFIG_SND_ENS1370 is not set
@@ -1871,15 +1968,17 @@
 #
 # Special HID drivers
 #
-CONFIG_HID_COMPAT=y
 CONFIG_HID_A4TECH=y
 CONFIG_HID_APPLE=y
 CONFIG_HID_BELKIN=y
 CONFIG_HID_CHERRY=y
 CONFIG_HID_CHICONY=y
 CONFIG_HID_CYPRESS=y
+# CONFIG_DRAGONRISE_FF is not set
 CONFIG_HID_EZKEY=y
+CONFIG_HID_KYE=y
 CONFIG_HID_GYRATION=y
+CONFIG_HID_KENSINGTON=y
 CONFIG_HID_LOGITECH=y
 CONFIG_LOGITECH_FF=y
 # CONFIG_LOGIRUMBLEPAD2_FF is not set
@@ -1945,11 +2044,11 @@
 # CONFIG_USB_TMC is not set
 
 #
-# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
 #
 
 #
-# see USB_STORAGE Help for more information
+# also be needed; see USB_STORAGE Help for more info
 #
 CONFIG_USB_STORAGE=y
 # CONFIG_USB_STORAGE_DEBUG is not set
@@ -1991,7 +2090,6 @@
 # CONFIG_USB_LED is not set
 # CONFIG_USB_CYPRESS_CY7C63 is not set
 # CONFIG_USB_CYTHERM is not set
-# CONFIG_USB_PHIDGET is not set
 # CONFIG_USB_IDMOUSE is not set
 # CONFIG_USB_FTDI_ELAN is not set
 # CONFIG_USB_APPLEDISPLAY is not set
@@ -2007,6 +2105,7 @@
 #
 # OTG and related infrastructure
 #
+# CONFIG_NOP_USB_XCEIV is not set
 # CONFIG_UWB is not set
 # CONFIG_MMC is not set
 # CONFIG_MEMSTICK is not set
@@ -2018,8 +2117,10 @@
 #
 # CONFIG_LEDS_ALIX2 is not set
 # CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_LP5521 is not set
 # CONFIG_LEDS_CLEVO_MAIL is not set
 # CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_BD2802 is not set
 
 #
 # LED Triggers
@@ -2029,6 +2130,10 @@
 # CONFIG_LEDS_TRIGGER_HEARTBEAT is not set
 # CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
 # CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
 # CONFIG_ACCESSIBILITY is not set
 # CONFIG_INFINIBAND is not set
 CONFIG_EDAC=y
@@ -2097,6 +2202,7 @@
 # DMA Devices
 #
 # CONFIG_INTEL_IOATDMA is not set
+# CONFIG_AUXDISPLAY is not set
 # CONFIG_UIO is not set
 # CONFIG_STAGING is not set
 CONFIG_X86_PLATFORM_DEVICES=y
@@ -2131,6 +2237,7 @@
 #
 # CONFIG_EXT2_FS is not set
 CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
 CONFIG_EXT3_FS_XATTR=y
 CONFIG_EXT3_FS_POSIX_ACL=y
 CONFIG_EXT3_FS_SECURITY=y
@@ -2215,6 +2326,7 @@
 # CONFIG_ROMFS_FS is not set
 # CONFIG_SYSV_FS is not set
 # CONFIG_UFS_FS is not set
+# CONFIG_NILFS2_FS is not set
 CONFIG_NETWORK_FILESYSTEMS=y
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
@@ -2228,7 +2340,6 @@
 CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 CONFIG_SUNRPC_GSS=y
-# CONFIG_SUNRPC_REGISTER_V4 is not set
 CONFIG_RPCSEC_GSS_KRB5=y
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
 # CONFIG_SMB_FS is not set
@@ -2315,6 +2426,7 @@
 CONFIG_DEBUG_KERNEL=y
 # CONFIG_DEBUG_SHIRQ is not set
 # CONFIG_DETECT_SOFTLOCKUP is not set
+# CONFIG_DETECT_HUNG_TASK is not set
 # CONFIG_SCHED_DEBUG is not set
 CONFIG_SCHEDSTATS=y
 CONFIG_TIMER_STATS=y
@@ -2330,6 +2442,7 @@
 # CONFIG_LOCK_STAT is not set
 # CONFIG_DEBUG_SPINLOCK_SLEEP is not set
 # CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
 # CONFIG_DEBUG_KOBJECT is not set
 # CONFIG_DEBUG_HIGHMEM is not set
 CONFIG_DEBUG_BUGVERBOSE=y
@@ -2353,13 +2466,18 @@
 # CONFIG_FAULT_INJECTION is not set
 # CONFIG_LATENCYTOP is not set
 CONFIG_SYSCTL_SYSCALL_CHECK=y
+# CONFIG_DEBUG_PAGEALLOC is not set
 CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_NOP_TRACER=y
 CONFIG_HAVE_FUNCTION_TRACER=y
 CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
 CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST=y
 CONFIG_HAVE_DYNAMIC_FTRACE=y
 CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
-CONFIG_HAVE_HW_BRANCH_TRACER=y
+CONFIG_HAVE_FTRACE_SYSCALLS=y
+CONFIG_RING_BUFFER=y
+CONFIG_TRACING=y
+CONFIG_TRACING_SUPPORT=y
 
 #
 # Tracers
@@ -2369,13 +2487,20 @@
 # CONFIG_SYSPROF_TRACER is not set
 # CONFIG_SCHED_TRACER is not set
 # CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_EVENT_TRACER is not set
+# CONFIG_FTRACE_SYSCALLS is not set
 # CONFIG_BOOT_TRACER is not set
 # CONFIG_TRACE_BRANCH_PROFILING is not set
 # CONFIG_POWER_TRACER is not set
 # CONFIG_STACK_TRACER is not set
-# CONFIG_HW_BRANCH_TRACER is not set
+# CONFIG_KMEMTRACE is not set
+# CONFIG_WORKQUEUE_TRACER is not set
+CONFIG_BLK_DEV_IO_TRACE=y
+# CONFIG_FTRACE_STARTUP_TEST is not set
+# CONFIG_MMIOTRACE is not set
 CONFIG_PROVIDE_OHCI1394_DMA_INIT=y
-# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
 # CONFIG_SAMPLES is not set
 CONFIG_HAVE_ARCH_KGDB=y
 # CONFIG_KGDB is not set
@@ -2385,7 +2510,6 @@
 CONFIG_EARLY_PRINTK_DBGP=y
 CONFIG_DEBUG_STACKOVERFLOW=y
 CONFIG_DEBUG_STACK_USAGE=y
-# CONFIG_DEBUG_PAGEALLOC is not set
 # CONFIG_DEBUG_PER_CPU_MAPS is not set
 # CONFIG_X86_PTDUMP is not set
 CONFIG_DEBUG_RODATA=y
@@ -2393,7 +2517,7 @@
 CONFIG_DEBUG_NX_TEST=m
 # CONFIG_4KSTACKS is not set
 CONFIG_DOUBLEFAULT=y
-# CONFIG_MMIOTRACE is not set
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
 CONFIG_IO_DELAY_TYPE_0X80=0
 CONFIG_IO_DELAY_TYPE_0XED=1
 CONFIG_IO_DELAY_TYPE_UDELAY=2
@@ -2410,25 +2534,11 @@
 #
 # Security options
 #
-CONFIG_KEYS=y
-CONFIG_KEYS_DEBUG_PROC_KEYS=y
-CONFIG_SECURITY=y
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
 # CONFIG_SECURITYFS is not set
-CONFIG_SECURITY_NETWORK=y
-# CONFIG_SECURITY_NETWORK_XFRM is not set
-# CONFIG_SECURITY_PATH is not set
 CONFIG_SECURITY_FILE_CAPABILITIES=y
-# CONFIG_SECURITY_ROOTPLUG is not set
-CONFIG_SECURITY_DEFAULT_MMAP_MIN_ADDR=65536
-CONFIG_SECURITY_SELINUX=y
-CONFIG_SECURITY_SELINUX_BOOTPARAM=y
-CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE=1
-CONFIG_SECURITY_SELINUX_DISABLE=y
-CONFIG_SECURITY_SELINUX_DEVELOP=y
-CONFIG_SECURITY_SELINUX_AVC_STATS=y
-CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE=1
-# CONFIG_SECURITY_SELINUX_POLICYDB_VERSION_MAX is not set
-# CONFIG_SECURITY_SMACK is not set
+# CONFIG_IMA is not set
 CONFIG_CRYPTO=y
 
 #
@@ -2444,10 +2554,12 @@
 CONFIG_CRYPTO_HASH=y
 CONFIG_CRYPTO_HASH2=y
 CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
 CONFIG_CRYPTO_MANAGER=y
 CONFIG_CRYPTO_MANAGER2=y
 # CONFIG_CRYPTO_GF128MUL is not set
 # CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
 # CONFIG_CRYPTO_CRYPTD is not set
 CONFIG_CRYPTO_AUTHENC=y
 # CONFIG_CRYPTO_TEST is not set
@@ -2520,6 +2632,7 @@
 # Compression
 #
 # CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
 # CONFIG_CRYPTO_LZO is not set
 
 #
@@ -2531,11 +2644,13 @@
 # CONFIG_CRYPTO_DEV_GEODE is not set
 # CONFIG_CRYPTO_DEV_HIFN_795X is not set
 CONFIG_HAVE_KVM=y
+CONFIG_HAVE_KVM_IRQCHIP=y
 CONFIG_VIRTUALIZATION=y
 # CONFIG_KVM is not set
 # CONFIG_LGUEST is not set
 # CONFIG_VIRTIO_PCI is not set
 # CONFIG_VIRTIO_BALLOON is not set
+CONFIG_BINARY_PRINTF=y
 
 #
 # Library routines
@@ -2553,7 +2668,11 @@
 # CONFIG_LIBCRC32C is not set
 CONFIG_AUDIT_GENERIC=y
 CONFIG_ZLIB_INFLATE=y
-CONFIG_PLIST=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
 CONFIG_HAS_IOMEM=y
 CONFIG_HAS_IOPORT=y
 CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
+CONFIG_MODULE_HOOK=y
--- include/linux/mmzone.h
+++ include/linux/mmzone.h
@@ -86,6 +86,10 @@
 	NR_ACTIVE_ANON,		/*  "     "     "   "       "         */
 	NR_INACTIVE_FILE,	/*  "     "     "   "       "         */
 	NR_ACTIVE_FILE,		/*  "     "     "   "       "         */
+#ifdef CONFIG_KRG_MM
+	NR_INACTIVE_MIGR,
+	NR_ACTIVE_MIGR,
+#endif
 #ifdef CONFIG_UNEVICTABLE_LRU
 	NR_UNEVICTABLE,		/*  "     "     "   "       "         */
 	NR_MLOCK,		/* mlock()ed pages found and moved off LRU */
@@ -129,12 +133,17 @@
 #define LRU_BASE 0
 #define LRU_ACTIVE 1
 #define LRU_FILE 2
+#define LRU_MIGR 4
 
 enum lru_list {
 	LRU_INACTIVE_ANON = LRU_BASE,
 	LRU_ACTIVE_ANON = LRU_BASE + LRU_ACTIVE,
 	LRU_INACTIVE_FILE = LRU_BASE + LRU_FILE,
 	LRU_ACTIVE_FILE = LRU_BASE + LRU_FILE + LRU_ACTIVE,
+#ifdef CONFIG_KRG_MM
+	LRU_INACTIVE_MIGR = LRU_BASE + LRU_MIGR,
+	LRU_ACTIVE_MIGR = LRU_BASE + LRU_MIGR + LRU_ACTIVE,
+#endif
 #ifdef CONFIG_UNEVICTABLE_LRU
 	LRU_UNEVICTABLE,
 #else
@@ -288,8 +313,14 @@
 	 *
 	 * The anon LRU stats live in [0], file LRU stats in [1]
 	 */
+#ifdef CONFIG_KRG_MM
+	/* The KDDM migratable LRU stats live in [2] */
+	unsigned long		recent_rotated[3];
+	unsigned long		recent_scanned[3];
+#else
 	unsigned long		recent_rotated[2];
 	unsigned long		recent_scanned[2];
+#endif
 };
 
 struct zone {
--- include/linux/rmap.h
+++ include/linux/rmap.h
@@ -85,6 +85,12 @@
  */
 int page_referenced(struct page *, int is_locked, struct mem_cgroup *cnt);
 int try_to_unmap(struct page *, int ignore_refs);
+#ifdef CONFIG_KRG_MM
+int try_to_unmap_one(struct page *page, struct vm_area_struct *vma,
+		     int migration);
+struct anon_vma *page_lock_anon_vma(struct page *page);
+void page_unlock_anon_vma(struct anon_vma *anon_vma);
+#endif
 
 /*
  * Called from mm/filemap_xip.c to unmap empty zero page
--- include/linux/magic.h
+++ include/linux/magic.h
@@ -50,4 +50,7 @@
 #define INOTIFYFS_SUPER_MAGIC	0x2BAD1DEA
 
 #define STACK_END_MAGIC		0x57AC6E9D
+#ifdef CONFIG_KRG_DVFS
+#define OCFS2_SUPER_MAGIC		0x7461636f
+#endif
 #endif /* __LINUX_MAGIC_H__ */
--- include/linux/file.h
+++ include/linux/file.h
@@ -39,9 +42,25 @@
 extern void put_filp(struct file *);
 extern int alloc_fd(unsigned start, unsigned flags);
 extern int get_unused_fd(void);
+#ifdef CONFIG_KRG_FAF
+int __get_unused_fd(struct task_struct *task);
+#endif
 #define get_unused_fd_flags(flags) alloc_fd(0, (flags))
+#ifdef CONFIG_KRG_FAF
+extern void __put_unused_fd(struct files_struct *files, unsigned int fd);
+#endif
 extern void put_unused_fd(unsigned int fd);
-
+#ifdef CONFIG_KRG_FAF
+extern void __fd_install(struct files_struct *files,
+			 unsigned int fd, struct file *file);
+#endif
 extern void fd_install(unsigned int fd, struct file *file);
 
+#ifdef CONFIG_KRG_DVFS
+struct fdtable;
+int count_open_files(struct fdtable *fdt);
+
+struct fdtable * alloc_fdtable(unsigned int nr);
+#endif
+
 #endif /* __LINUX_FILE_H */
--- include/linux/sem.h
+++ include/linux/sem.h
@@ -102,6 +107,9 @@
 	struct list_head	sem_pending;	/* pending operations to be processed */
 	struct list_head	list_id;	/* undo requests on this array */
 	unsigned long		sem_nsems;	/* no. of semaphores in array */
+#ifdef CONFIG_KRG_IPC
+	struct list_head        remote_sem_pending;
+#endif
 };
 
 /* One queue for each sleeping process in the system. */
@@ -114,12 +122,20 @@
 	struct sembuf		*sops;	 /* array of pending operations */
 	int			nsops;	 /* number of operations */
 	int			alter;   /* does the operation alter the array? */
+#ifdef CONFIG_KRG_IPC
+	int                     semid;
+	kerrighed_node_t        node;
+#endif
 };
 
 /* Each task has a list of undo requests. They are executed automatically
  * when the process exits.
  */
 struct sem_undo {
+#ifdef CONFIG_KRG_IPC
+	unique_id_t             proc_list_id;
+	/* list_proc is useless in KRG code */
+#endif
 	struct list_head	list_proc;	/* per-process list: all undos from one process. */
 						/* rcu protected */
 	struct rcu_head		rcu;		/* rcu struct for sem_undo() */
--- include/linux/mm_inline.h
+++ include/linux/mm_inline.h
@@ -63,6 +73,11 @@
 			__ClearPageActive(page);
 			l += LRU_ACTIVE;
 		}
+#ifdef CONFIG_KRG_MM
+		if (PageMigratable(page))
+			l += LRU_MIGR;
+		else
+#endif
 		l += page_is_file_cache(page);
 	}
 	__dec_zone_state(zone, NR_LRU_BASE + l);
@@ -85,10 +100,26 @@
 	else {
 		if (PageActive(page))
 			lru += LRU_ACTIVE;
+#ifdef CONFIG_KRG_MM
+		if (PageMigratable(page))
+			lru += LRU_MIGR;
+		else
+#endif
 		lru += page_is_file_cache(page);
 	}
 
 	return lru;
 }
 
+#define BUILD_LRU_ID(active,file,kddm) (LRU_BASE + LRU_MIGR * kddm + LRU_FILE * file + active)
+
+#ifdef CONFIG_KRG_MM
+#define RECLAIM_STAT_INDEX(file,kddm) ((!!file) + 2 * (!!kddm))
+static inline int reclaim_stat_index(struct page *page)
+{
+	return RECLAIM_STAT_INDEX(page_is_file_cache(page),
+				  page_is_migratable(page));
+}
+#endif
+
 #endif
--- include/linux/sched.h
+++ include/linux/sched.h
@@ -88,6 +88,12 @@
 #include <linux/kobject.h>
 #include <linux/latencytop.h>
 #include <linux/cred.h>
+#ifdef CONFIG_KRG_CAP
+#include <kerrighed/capabilities.h>
+#endif
+#ifdef CONFIG_KRG_EPM
+#include <kddm/kddm_types.h>
+#endif
 
 #include <asm/processor.h>
 
@@ -185,6 +191,10 @@
 /* in tsk->state again */
 #define TASK_DEAD		64
 #define TASK_WAKEKILL		128
+#ifdef CONFIG_KRG_EPM
+/* in tsk->exit_state */
+#define EXIT_MIGRATION		256
+#endif
 
 /* Convenience macros for the sake of set_task_state */
 #define TASK_KILLABLE		(TASK_WAKEKILL | TASK_UNINTERRUPTIBLE)
@@ -1189,6 +1207,12 @@
 	unsigned did_exec:1;
 	unsigned in_execve:1;	/* Tell the LSMs that the process is doing an
 				 * execve */
+#ifdef CONFIG_KRG_HOTPLUG
+	unsigned create_krg_ns:1;
+#endif
+#ifdef CONFIG_KRG_EPM
+	unsigned remote_vfork_done:1;
+#endif
 	pid_t pid;
 	pid_t tgid;
 
--- include/linux/splice.h
+++ include/linux/splice.h
@@ -83,4 +83,17 @@
 extern ssize_t splice_direct_to_actor(struct file *, struct splice_desc *,
 				      splice_direct_actor *);
 
+#ifdef CONFIG_KRG_EPM
+extern long do_splice_from(struct pipe_inode_info *pipe, struct file *out,
+			   loff_t *ppos, size_t len, unsigned int flags);
+
+extern long do_splice_to(struct file *in, loff_t *ppos,
+			 struct pipe_inode_info *pipe, size_t len,
+			 unsigned int flags);
+
+extern int link_pipe(struct pipe_inode_info *ipipe,
+		     struct pipe_inode_info *opipe,
+		     size_t len, unsigned int flags);
+#endif
+
 #endif
--- include/linux/ptrace.h
+++ include/linux/ptrace.h
@@ -78,6 +78,9 @@
 
 #include <linux/compiler.h>		/* For unlikely.  */
 #include <linux/sched.h>		/* For struct task_struct.  */
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/children.h>
+#endif
 
 
 extern long arch_ptrace(struct task_struct *child, long request, long addr, long data);
@@ -102,16 +105,40 @@
 extern int __ptrace_may_access(struct task_struct *task, unsigned int mode);
 /* Returns true on success, false on denial. */
 extern bool ptrace_may_access(struct task_struct *task, unsigned int mode);
+#ifdef CONFIG_KRG_EPM
+extern
+int krg_ptrace_link(struct task_struct *task, struct task_struct *tracer);
+extern void krg_ptrace_unlink(struct task_struct *task);
+extern void krg_ptrace_reparent_ptraced(struct task_struct *real_parent,
+					struct task_struct *task);
+#endif /* CONFIG_KRG_EPM */
 
 static inline int ptrace_reparented(struct task_struct *child)
 {
+#ifdef CONFIG_KRG_EPM
+/*
+ * if (child->parent == baby_sitter || child->real_parent == baby_sitter)
+ *		return child->task_obj->parent != child->task_obj->real_parent;
+ */
+#endif
 	return child->real_parent != child->parent;
 }
 static inline void ptrace_link(struct task_struct *child,
 			       struct task_struct *new_parent)
 {
+#ifdef CONFIG_KRG_EPM
+	if (unlikely(child->ptrace)) {
+		int ret = krg_ptrace_link(child, new_parent);
+		BUG_ON(ret);
+		ret = krg_set_child_ptraced(child->parent_children_obj,
+					    child, 1);
+		BUG_ON(ret);
+		__ptrace_link(child, new_parent);
+	}
+#else
 	if (unlikely(child->ptrace))
 		__ptrace_link(child, new_parent);
+#endif
 }
 static inline void ptrace_unlink(struct task_struct *child)
 {
--- include/linux/pid.h
+++ include/linux/pid.h
@@ -125,8 +131,22 @@
 extern struct pid *find_ge_pid(int nr, struct pid_namespace *);
 int next_pidmap(struct pid_namespace *pid_ns, int last);
 
+#ifndef CONFIG_KRG_EPM
 extern struct pid *alloc_pid(struct pid_namespace *ns);
+#endif
 extern void free_pid(struct pid *pid);
+#ifdef CONFIG_KRG_EPM
+extern struct pid *__alloc_pid(struct pid_namespace *ns, const int *req_nr);
+extern int reserve_pidmap(struct pid_namespace *ns, int nr);
+extern void __free_pidmap(struct upid *upid);
+struct pidmap;
+extern int alloc_pidmap_page(struct pidmap *map);
+
+static inline struct pid *alloc_pid(struct pid_namespace *ns)
+{
+	return __alloc_pid(ns, NULL);
+}
+#endif /* CONFIG_KRG_EPM */
 
 /*
  * ns_of_pid() returns the pid namespace in which the specified pid was
--- include/linux/tracehook.h
+++ include/linux/tracehook.h
@@ -501,6 +501,11 @@
 static inline int tracehook_notify_death(struct task_struct *task,
 					 void **death_cookie, int group_dead)
 {
+#ifdef CONFIG_KRG_EPM
+	/* Remote ptracers are not supported yet. */
+	BUG_ON(task->ptrace && (task->parent == baby_sitter
+				|| task->real_parent == baby_sitter));
+#endif
 	if (task_detached(task))
 		return task->ptrace ? SIGCHLD : DEATH_REAP;
 
--- include/linux/mm.h
+++ include/linux/mm.h
@@ -1256,7 +1310,23 @@
 unsigned long max_sane_readahead(unsigned long nr);
 
 /* Do stack extension */
+#ifdef CONFIG_KRG_MM
+extern int krg_expand_stack(struct vm_area_struct *vma, unsigned long address);
+extern int __expand_stack(struct vm_area_struct *vma, unsigned long address);
+static inline int expand_stack(struct vm_area_struct *vma,
+			       unsigned long address)
+{
+	int err;
+
+	err = __expand_stack(vma, address);
+	if (!err && vma->vm_mm->anon_vma_kddm_set)
+		krg_expand_stack(vma, address);
+
+	return err;
+}
+#else
 extern int expand_stack(struct vm_area_struct *vma, unsigned long address);
+#endif
 #ifdef CONFIG_IA64
 extern int expand_upwards(struct vm_area_struct *vma, unsigned long address);
 #endif
@@ -1376,5 +1446,10 @@
 extern void *alloc_locked_buffer(size_t size);
 extern void free_locked_buffer(void *buffer, size_t size);
 extern void release_locked_buffer(void *buffer, size_t size);
+
+#ifdef CONFIG_KRG_MM
+#include <kerrighed/mm.h>
+#endif
+
 #endif /* __KERNEL__ */
 #endif /* _LINUX_MM_H */
--- include/linux/signal.h
+++ include/linux/signal.h
@@ -235,6 +235,12 @@
 extern int next_signal(struct sigpending *pending, sigset_t *mask);
 extern int group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p);
 extern int __group_send_sig_info(int, struct siginfo *, struct task_struct *);
+#ifdef CONFIG_KRG_PROC
+extern
+int krg_group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p,
+			    pid_t session);
+extern int __krg_group_send_sig_info(int, struct siginfo *, struct task_struct *);
+#endif
 extern long do_sigpending(void __user *, unsigned long);
 extern int sigprocmask(int, sigset_t *, sigset_t *);
 extern int show_unhandled_signals;
--- include/linux/vmstat.h
+++ include/linux/vmstat.h
@@ -171,6 +171,10 @@
 {
 	return (zone_page_state(zone, NR_ACTIVE_ANON)
 		+ zone_page_state(zone, NR_ACTIVE_FILE)
+#ifdef CONFIG_KRG_MM
+		+ zone_page_state(zone, NR_ACTIVE_MIGR)
+		+ zone_page_state(zone, NR_INACTIVE_MIGR)
+#endif
 		+ zone_page_state(zone, NR_INACTIVE_ANON)
 		+ zone_page_state(zone, NR_INACTIVE_FILE));
 }
--- include/linux/memcontrol.h
+++ include/linux/memcontrol.h
@@ -64,7 +64,11 @@
 					unsigned long *scanned, int order,
 					int mode, struct zone *z,
 					struct mem_cgroup *mem_cont,
+#ifdef CONFIG_KRG_MM
+					int active, int file, int kddm);
+#else
 					int active, int file);
+#endif
 extern void mem_cgroup_out_of_memory(struct mem_cgroup *mem, gfp_t gfp_mask);
 int task_in_mem_cgroup(struct task_struct *task, const struct mem_cgroup *mem);
 
--- include/linux/ipc_namespace.h
+++ include/linux/ipc_namespace.h
@@ -61,7 +67,6 @@
 	unsigned int    mq_queues_max;   /* initialized to DFLT_QUEUESMAX */
 	unsigned int    mq_msg_max;      /* initialized to DFLT_MSGMAX */
 	unsigned int    mq_msgsize_max;  /* initialized to DFLT_MSGSIZEMAX */
-
 };
 
 extern struct ipc_namespace init_ipc_ns;
--- include/linux/mm_types.h
+++ include/linux/mm_types.h
@@ -271,6 +290,13 @@
 
 	struct core_state *core_state; /* coredumping support */
 
+#ifdef CONFIG_KRG_MM
+	struct kddm_set * anon_vma_kddm_set;
+	unique_id_t anon_vma_kddm_id;
+	krgnodemask_t copyset;		/* Nodes owning a copy of the struct */
+	unique_id_t mm_id;
+#endif
+
 	/* aio bits */
 	spinlock_t		ioctx_lock;
 	struct hlist_head	ioctx_list;
--- include/linux/fs.h
+++ include/linux/fs.h
@@ -231,6 +231,9 @@
 #define S_NOCMTIME	128	/* Do not update file c/mtime */
 #define S_SWAPFILE	256	/* Do not truncate: swapon got its bmaps */
 #define S_PRIVATE	512	/* Inode is fs-internal */
+#ifdef CONFIG_KRG_FAF
+#define S_IFAF          1024
+#endif
 
 /*
  * Note that nosuid etc flags are inode-specific: setting some file-system
@@ -758,6 +764,9 @@
 
 	__u32			i_generation;
 
+#ifdef CONFIG_KRG_DVFS
+	unsigned long           i_objid;
+#endif
 #ifdef CONFIG_DNOTIFY
 	unsigned long		i_dnotify_mask; /* Directory notify events */
 	struct dnotify_struct	*i_dnotify; /* for directory notifications */
--- include/linux/init_task.h
+++ include/linux/init_task.h
@@ -11,14 +11,33 @@
 #include <linux/user_namespace.h>
 #include <linux/securebits.h>
 #include <net/net_namespace.h>
+#ifdef CONFIG_KRG_CAP
+#include <kerrighed/capabilities.h>
+#endif
 
 extern struct files_struct init_files;
 extern struct fs_struct init_fs;
 
+#ifdef CONFIG_KRG_EPM
+#define INIT_MM_EPM						\
+	.mm_ltasks      = ATOMIC_INIT(1),
+#else
+#define INIT_MM_EPM
+#endif
+
+#ifdef CONFIG_KRG_MM
+#define INIT_MM_MM                                              \
+        .mm_tasks       = ATOMIC_INIT(1),
+#else
+#define INIT_MM_MM
+#endif
+
 #define INIT_MM(name) \
 {			 					\
 	.mm_rb		= RB_ROOT,				\
 	.pgd		= swapper_pg_dir, 			\
+	INIT_MM_MM						\
+	INIT_MM_EPM						\
 	.mm_users	= ATOMIC_INIT(2), 			\
 	.mm_count	= ATOMIC_INIT(1), 			\
 	.mmap_sem	= __RWSEM_INITIALIZER(name.mmap_sem),	\
@@ -191,6 +227,8 @@
 	INIT_TRACE_IRQFLAGS						\
 	INIT_LOCKDEP							\
 	INIT_FTRACE_GRAPH						\
+	INIT_KRG_CAP							\
+	INIT_KDDM							\
 }
 
 
--- Documentation/hwmon/coretemp
+++ Documentation/hwmon/coretemp
@@ -4,7 +4,7 @@
 Supported chips:
   * All Intel Core family
     Prefix: 'coretemp'
-    CPUID: family 0x6, models 0xe, 0xf, 0x16, 0x17
+    CPUID: family 0x6, models 0xe, 0xf, 0x16, 0x17, 0x1c (Atom)
     Datasheet: Intel 64 and IA-32 Architectures Software Developer's Manual
                Volume 3A: System Programming Guide
                http://softwarecommunity.intel.com/Wiki/Mobility/720.htm
--- net/socket.c
+++ net/socket.c
@@ -95,6 +95,9 @@
 
 #include <net/sock.h>
 #include <linux/netfilter.h>
+#ifdef CONFIG_KRG_FAF
+#include <kerrighed/faf.h>
+#endif
 
 static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
 static ssize_t sock_aio_read(struct kiocb *iocb, const struct iovec *iov,
@@ -1754,11 +1839,17 @@
 	struct msghdr msg;
 	struct iovec iov;
 	int fput_needed;
+#ifdef CONFIG_KRG_FAF
+	struct file *faf_file;
 
+	sock = sockfd_lookup_light(fd, &err, &fput_needed, &faf_file);
+	if (!sock && !faf_file)
+		goto out;
+#else
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
 	if (!sock)
 		goto out;
-
+#endif
 	iov.iov_base = buff;
 	iov.iov_len = len;
 	msg.msg_name = NULL;
@@ -1823,10 +1926,17 @@
 	struct sockaddr_storage address;
 	int err, err2;
 	int fput_needed;
+#ifdef CONFIG_KRG_FAF
+	struct file * faf_file;
 
+	sock = sockfd_lookup_light(fd, &err, &fput_needed, &faf_file);
+	if (!sock && !faf_file)
+		goto out;
+#else
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
 	if (!sock)
 		goto out;
+#endif
 
 	msg.msg_control = NULL;
 	msg.msg_controllen = 0;
@@ -2044,6 +2227,9 @@
 	struct msghdr msg_sys;
 	int err, ctl_len, iov_size, total_len;
 	int fput_needed;
+#ifdef CONFIG_KRG_FAF
+	struct file *faf_file;
+#endif
 
 	err = -EFAULT;
 	if (MSG_CMSG_COMPAT & flags) {
@@ -2053,9 +2239,18 @@
 	else if (copy_from_user(&msg_sys, msg, sizeof(struct msghdr)))
 		return -EFAULT;
 
+#ifdef CONFIG_KRG_FAF
+	sock = sockfd_lookup_light(fd, &err, &fput_needed, &faf_file);
+	if (!sock && !faf_file)
+		goto out;
+	err = -ENOSYS;
+	if (faf_file && (flags & MSG_CMSG_COMPAT))
+		goto out_put;
+#else
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
 	if (!sock)
 		goto out;
+#endif
 
 	/* do not move before msg_sys is valid */
 	err = -EMSGSIZE;
@@ -2066,7 +2261,11 @@
 	err = -ENOMEM;
 	iov_size = msg_sys.msg_iovlen * sizeof(struct iovec);
 	if (msg_sys.msg_iovlen > UIO_FASTIOV) {
+#ifdef CONFIG_KRG_FAF
+		iov = faf_sock_kmalloc(sock->sk, iov_size, GFP_KERNEL, faf_file);
+#else
 		iov = sock_kmalloc(sock->sk, iov_size, GFP_KERNEL);
+#endif
 		if (!iov)
 			goto out_put;
 	}
@@ -2099,7 +2298,12 @@
 		ctl_len = msg_sys.msg_controllen;
 	} else if (ctl_len) {
 		if (ctl_len > sizeof(ctl)) {
+#ifdef CONFIG_KRG_FAF
+			ctl_buf = faf_sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL,
+						   faf_file);
+#else
 			ctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);
+#endif
 			if (ctl_buf == NULL)
 				goto out_freeiov;
 		}
@@ -2116,17 +2320,36 @@
 	}
 	msg_sys.msg_flags = flags;
 
+#ifdef CONFIG_KRG_FAF
+	if (faf_file) {
+		err = krg_faf_sendmsg(faf_file, &msg_sys, total_len);
+		goto out_freectl;
+	}
+#endif
 	if (sock->file->f_flags & O_NONBLOCK)
 		msg_sys.msg_flags |= MSG_DONTWAIT;
 	err = sock_sendmsg(sock, &msg_sys, total_len);
 
 out_freectl:
 	if (ctl_buf != ctl)
+#ifdef CONFIG_KRG_FAF
+		faf_sock_kfree_s(sock->sk, ctl_buf, ctl_len, faf_file);
+#else
 		sock_kfree_s(sock->sk, ctl_buf, ctl_len);
+#endif
 out_freeiov:
 	if (iov != iovstack)
+#ifdef CONFIG_KRG_FAF
+		faf_sock_kfree_s(sock->sk, iov, iov_size, faf_file);
+#else
 		sock_kfree_s(sock->sk, iov, iov_size);
+#endif
 out_put:
+#ifdef CONFIG_KRG_FAF
+	if (faf_file)
+		fput_light(faf_file, fput_needed);
+	else
+#endif
 	fput_light(sock->file, fput_needed);
 out:
 	return err;
@@ -2166,9 +2392,18 @@
 	else if (copy_from_user(&msg_sys, msg, sizeof(struct msghdr)))
 		return -EFAULT;
 
+#ifdef CONFIG_KRG_FAF
+	sock = sockfd_lookup_light(fd, &err, &fput_needed, &faf_file);
+	if (!sock && !faf_file)
+		goto out;
+	err = -ENOSYS;
+	if (faf_file && (flags & MSG_CMSG_COMPAT))
+		goto out_put;
+#else
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
 	if (!sock)
 		goto out;
+#endif
 
 	err = -EMSGSIZE;
 	if (msg_sys.msg_iovlen > UIO_MAXIOV)
@@ -2178,7 +2413,11 @@
 	err = -ENOMEM;
 	iov_size = msg_sys.msg_iovlen * sizeof(struct iovec);
 	if (msg_sys.msg_iovlen > UIO_FASTIOV) {
+#ifdef CONFIG_KRG_FAF
+		iov = faf_sock_kmalloc(sock->sk, iov_size, GFP_KERNEL, faf_file);
+#else
 		iov = sock_kmalloc(sock->sk, iov_size, GFP_KERNEL);
+#endif
 		if (!iov)
 			goto out_put;
 	}
@@ -2205,9 +2444,18 @@
 	cmsg_ptr = (unsigned long)msg_sys.msg_control;
 	msg_sys.msg_flags = flags & (MSG_CMSG_CLOEXEC|MSG_CMSG_COMPAT);
 
+#ifdef CONFIG_KRG_FAF
+	if (faf_file) {
+		err = krg_faf_recvmsg(faf_file, &msg_sys, total_len, flags);
+		goto check_err;
+	}
+#endif
 	if (sock->file->f_flags & O_NONBLOCK)
 		flags |= MSG_DONTWAIT;
 	err = sock_recvmsg(sock, &msg_sys, total_len, flags);
+#ifdef CONFIG_KRG_FAF
+check_err:
+#endif
 	if (err < 0)
 		goto out_freeiov;
 	len = err;
@@ -2235,8 +2483,17 @@
 
 out_freeiov:
 	if (iov != iovstack)
+#ifdef CONFIG_KRG_FAF
+		faf_sock_kfree_s(sock->sk, iov, iov_size, faf_file);
+#else
 		sock_kfree_s(sock->sk, iov, iov_size);
+#endif
 out_put:
+#ifdef CONFIG_KRG_FAF
+	if (faf_file)
+		fput_light(faf_file, fput_needed);
+	else
+#endif
 	fput_light(sock->file, fput_needed);
 out:
 	return err;
--- net/tipc/socket.c
+++ /dev/null
@@ -1,1892 +0,0 @@
-/*
- * net/tipc/socket.c: TIPC socket API
- *
- * Copyright (c) 2001-2007, Ericsson AB
- * Copyright (c) 2004-2008, Wind River Systems
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the names of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/net.h>
-#include <linux/socket.h>
-#include <linux/errno.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <linux/poll.h>
-#include <linux/fcntl.h>
-#include <asm/string.h>
-#include <asm/atomic.h>
-#include <net/sock.h>
-
-#include <linux/tipc.h>
-#include <linux/tipc_config.h>
-#include <net/tipc/tipc_msg.h>
-#include <net/tipc/tipc_port.h>
-
-#include "core.h"
-
-#define SS_LISTENING	-1	/* socket is listening */
-#define SS_READY	-2	/* socket is connectionless */
-
-#define OVERLOAD_LIMIT_BASE	5000
-#define CONN_TIMEOUT_DEFAULT	8000	/* default connect timeout = 8s */
-
-struct tipc_sock {
-	struct sock sk;
-	struct tipc_port *p;
-	struct tipc_portid peer_name;
-};
-
-#define tipc_sk(sk) ((struct tipc_sock *)(sk))
-#define tipc_sk_port(sk) ((struct tipc_port *)(tipc_sk(sk)->p))
-
-static int backlog_rcv(struct sock *sk, struct sk_buff *skb);
-static u32 dispatch(struct tipc_port *tport, struct sk_buff *buf);
-static void wakeupdispatch(struct tipc_port *tport);
-
-static const struct proto_ops packet_ops;
-static const struct proto_ops stream_ops;
-static const struct proto_ops msg_ops;
-
-static struct proto tipc_proto;
-
-static int sockets_enabled = 0;
-
-static atomic_t tipc_queue_size = ATOMIC_INIT(0);
-
-/*
- * Revised TIPC socket locking policy:
- *
- * Most socket operations take the standard socket lock when they start
- * and hold it until they finish (or until they need to sleep).  Acquiring
- * this lock grants the owner exclusive access to the fields of the socket
- * data structures, with the exception of the backlog queue.  A few socket
- * operations can be done without taking the socket lock because they only
- * read socket information that never changes during the life of the socket.
- *
- * Socket operations may acquire the lock for the associated TIPC port if they
- * need to perform an operation on the port.  If any routine needs to acquire
- * both the socket lock and the port lock it must take the socket lock first
- * to avoid the risk of deadlock.
- *
- * The dispatcher handling incoming messages cannot grab the socket lock in
- * the standard fashion, since invoked it runs at the BH level and cannot block.
- * Instead, it checks to see if the socket lock is currently owned by someone,
- * and either handles the message itself or adds it to the socket's backlog
- * queue; in the latter case the queued message is processed once the process
- * owning the socket lock releases it.
- *
- * NOTE: Releasing the socket lock while an operation is sleeping overcomes
- * the problem of a blocked socket operation preventing any other operations
- * from occurring.  However, applications must be careful if they have
- * multiple threads trying to send (or receive) on the same socket, as these
- * operations might interfere with each other.  For example, doing a connect
- * and a receive at the same time might allow the receive to consume the
- * ACK message meant for the connect.  While additional work could be done
- * to try and overcome this, it doesn't seem to be worthwhile at the present.
- *
- * NOTE: Releasing the socket lock while an operation is sleeping also ensures
- * that another operation that must be performed in a non-blocking manner is
- * not delayed for very long because the lock has already been taken.
- *
- * NOTE: This code assumes that certain fields of a port/socket pair are
- * constant over its lifetime; such fields can be examined without taking
- * the socket lock and/or port lock, and do not need to be re-read even
- * after resuming processing after waiting.  These fields include:
- *   - socket type
- *   - pointer to socket sk structure (aka tipc_sock structure)
- *   - pointer to port structure
- *   - port reference
- */
-
-/**
- * advance_rx_queue - discard first buffer in socket receive queue
- *
- * Caller must hold socket lock
- */
-
-static void advance_rx_queue(struct sock *sk)
-{
-	buf_discard(__skb_dequeue(&sk->sk_receive_queue));
-	atomic_dec(&tipc_queue_size);
-}
-
-/**
- * discard_rx_queue - discard all buffers in socket receive queue
- *
- * Caller must hold socket lock
- */
-
-static void discard_rx_queue(struct sock *sk)
-{
-	struct sk_buff *buf;
-
-	while ((buf = __skb_dequeue(&sk->sk_receive_queue))) {
-		atomic_dec(&tipc_queue_size);
-		buf_discard(buf);
-	}
-}
-
-/**
- * reject_rx_queue - reject all buffers in socket receive queue
- *
- * Caller must hold socket lock
- */
-
-static void reject_rx_queue(struct sock *sk)
-{
-	struct sk_buff *buf;
-
-	while ((buf = __skb_dequeue(&sk->sk_receive_queue))) {
-		tipc_reject_msg(buf, TIPC_ERR_NO_PORT);
-		atomic_dec(&tipc_queue_size);
-	}
-}
-
-/**
- * tipc_create - create a TIPC socket
- * @net: network namespace (must be default network)
- * @sock: pre-allocated socket structure
- * @protocol: protocol indicator (must be 0)
- *
- * This routine creates additional data structures used by the TIPC socket,
- * initializes them, and links them together.
- *
- * Returns 0 on success, errno otherwise
- */
-
-static int tipc_create(struct net *net, struct socket *sock, int protocol)
-{
-	const struct proto_ops *ops;
-	socket_state state;
-	struct sock *sk;
-	struct tipc_port *tp_ptr;
-
-	/* Validate arguments */
-
-	if (net != &init_net)
-		return -EAFNOSUPPORT;
-
-	if (unlikely(protocol != 0))
-		return -EPROTONOSUPPORT;
-
-	switch (sock->type) {
-	case SOCK_STREAM:
-		ops = &stream_ops;
-		state = SS_UNCONNECTED;
-		break;
-	case SOCK_SEQPACKET:
-		ops = &packet_ops;
-		state = SS_UNCONNECTED;
-		break;
-	case SOCK_DGRAM:
-	case SOCK_RDM:
-		ops = &msg_ops;
-		state = SS_READY;
-		break;
-	default:
-		return -EPROTOTYPE;
-	}
-
-	/* Allocate socket's protocol area */
-
-	sk = sk_alloc(net, AF_TIPC, GFP_KERNEL, &tipc_proto);
-	if (sk == NULL)
-		return -ENOMEM;
-
-	/* Allocate TIPC port for socket to use */
-
-	tp_ptr = tipc_createport_raw(sk, &dispatch, &wakeupdispatch,
-				     TIPC_LOW_IMPORTANCE);
-	if (unlikely(!tp_ptr)) {
-		sk_free(sk);
-		return -ENOMEM;
-	}
-
-	/* Finish initializing socket data structures */
-
-	sock->ops = ops;
-	sock->state = state;
-
-	sock_init_data(sock, sk);
-	sk->sk_rcvtimeo = msecs_to_jiffies(CONN_TIMEOUT_DEFAULT);
-	sk->sk_backlog_rcv = backlog_rcv;
-	tipc_sk(sk)->p = tp_ptr;
-
-	spin_unlock_bh(tp_ptr->lock);
-
-	if (sock->state == SS_READY) {
-		tipc_set_portunreturnable(tp_ptr->ref, 1);
-		if (sock->type == SOCK_DGRAM)
-			tipc_set_portunreliable(tp_ptr->ref, 1);
-	}
-
-	atomic_inc(&tipc_user_count);
-	return 0;
-}
-
-/**
- * release - destroy a TIPC socket
- * @sock: socket to destroy
- *
- * This routine cleans up any messages that are still queued on the socket.
- * For DGRAM and RDM socket types, all queued messages are rejected.
- * For SEQPACKET and STREAM socket types, the first message is rejected
- * and any others are discarded.  (If the first message on a STREAM socket
- * is partially-read, it is discarded and the next one is rejected instead.)
- *
- * NOTE: Rejected messages are not necessarily returned to the sender!  They
- * are returned or discarded according to the "destination droppable" setting
- * specified for the message by the sender.
- *
- * Returns 0 on success, errno otherwise
- */
-
-static int release(struct socket *sock)
-{
-	struct sock *sk = sock->sk;
-	struct tipc_port *tport;
-	struct sk_buff *buf;
-	int res;
-
-	/*
-	 * Exit if socket isn't fully initialized (occurs when a failed accept()
-	 * releases a pre-allocated child socket that was never used)
-	 */
-
-	if (sk == NULL)
-		return 0;
-
-	tport = tipc_sk_port(sk);
-	lock_sock(sk);
-
-	/*
-	 * Reject all unreceived messages, except on an active connection
-	 * (which disconnects locally & sends a 'FIN+' to peer)
-	 */
-
-	while (sock->state != SS_DISCONNECTING) {
-		buf = __skb_dequeue(&sk->sk_receive_queue);
-		if (buf == NULL)
-			break;
-		atomic_dec(&tipc_queue_size);
-		if (TIPC_SKB_CB(buf)->handle != msg_data(buf_msg(buf)))
-			buf_discard(buf);
-		else {
-			if ((sock->state == SS_CONNECTING) ||
-			    (sock->state == SS_CONNECTED)) {
-				sock->state = SS_DISCONNECTING;
-				tipc_disconnect(tport->ref);
-			}
-			tipc_reject_msg(buf, TIPC_ERR_NO_PORT);
-		}
-	}
-
-	/*
-	 * Delete TIPC port; this ensures no more messages are queued
-	 * (also disconnects an active connection & sends a 'FIN-' to peer)
-	 */
-
-	res = tipc_deleteport(tport->ref);
-
-	/* Discard any remaining (connection-based) messages in receive queue */
-
-	discard_rx_queue(sk);
-
-	/* Reject any messages that accumulated in backlog queue */
-
-	sock->state = SS_DISCONNECTING;
-	release_sock(sk);
-
-	sock_put(sk);
-	sock->sk = NULL;
-
-	atomic_dec(&tipc_user_count);
-	return res;
-}
-
-/**
- * bind - associate or disassocate TIPC name(s) with a socket
- * @sock: socket structure
- * @uaddr: socket address describing name(s) and desired operation
- * @uaddr_len: size of socket address data structure
- *
- * Name and name sequence binding is indicated using a positive scope value;
- * a negative scope value unbinds the specified name.  Specifying no name
- * (i.e. a socket address length of 0) unbinds all names from the socket.
- *
- * Returns 0 on success, errno otherwise
- *
- * NOTE: This routine doesn't need to take the socket lock since it doesn't
- *       access any non-constant socket information.
- */
-
-static int bind(struct socket *sock, struct sockaddr *uaddr, int uaddr_len)
-{
-	struct sockaddr_tipc *addr = (struct sockaddr_tipc *)uaddr;
-	u32 portref = tipc_sk_port(sock->sk)->ref;
-
-	if (unlikely(!uaddr_len))
-		return tipc_withdraw(portref, 0, NULL);
-
-	if (uaddr_len < sizeof(struct sockaddr_tipc))
-		return -EINVAL;
-	if (addr->family != AF_TIPC)
-		return -EAFNOSUPPORT;
-
-	if (addr->addrtype == TIPC_ADDR_NAME)
-		addr->addr.nameseq.upper = addr->addr.nameseq.lower;
-	else if (addr->addrtype != TIPC_ADDR_NAMESEQ)
-		return -EAFNOSUPPORT;
-
-	return (addr->scope > 0) ?
-		tipc_publish(portref, addr->scope, &addr->addr.nameseq) :
-		tipc_withdraw(portref, -addr->scope, &addr->addr.nameseq);
-}
-
-/**
- * get_name - get port ID of socket or peer socket
- * @sock: socket structure
- * @uaddr: area for returned socket address
- * @uaddr_len: area for returned length of socket address
- * @peer: 0 = own ID, 1 = current peer ID, 2 = current/former peer ID
- *
- * Returns 0 on success, errno otherwise
- *
- * NOTE: This routine doesn't need to take the socket lock since it only
- *       accesses socket information that is unchanging (or which changes in
- * 	 a completely predictable manner).
- */
-
-static int get_name(struct socket *sock, struct sockaddr *uaddr,
-		    int *uaddr_len, int peer)
-{
-	struct sockaddr_tipc *addr = (struct sockaddr_tipc *)uaddr;
-	struct tipc_sock *tsock = tipc_sk(sock->sk);
-
-	if (peer) {
-		if ((sock->state != SS_CONNECTED) &&
-			((peer != 2) || (sock->state != SS_DISCONNECTING)))
-			return -ENOTCONN;
-		addr->addr.id.ref = tsock->peer_name.ref;
-		addr->addr.id.node = tsock->peer_name.node;
-	} else {
-		tipc_ownidentity(tsock->p->ref, &addr->addr.id);
-	}
-
-	*uaddr_len = sizeof(*addr);
-	addr->addrtype = TIPC_ADDR_ID;
-	addr->family = AF_TIPC;
-	addr->scope = 0;
-	addr->addr.name.domain = 0;
-
-	return 0;
-}
-
-/**
- * poll - read and possibly block on pollmask
- * @file: file structure associated with the socket
- * @sock: socket for which to calculate the poll bits
- * @wait: ???
- *
- * Returns pollmask value
- *
- * COMMENTARY:
- * It appears that the usual socket locking mechanisms are not useful here
- * since the pollmask info is potentially out-of-date the moment this routine
- * exits.  TCP and other protocols seem to rely on higher level poll routines
- * to handle any preventable race conditions, so TIPC will do the same ...
- *
- * TIPC sets the returned events as follows:
- * a) POLLRDNORM and POLLIN are set if the socket's receive queue is non-empty
- *    or if a connection-oriented socket is does not have an active connection
- *    (i.e. a read operation will not block).
- * b) POLLOUT is set except when a socket's connection has been terminated
- *    (i.e. a write operation will not block).
- * c) POLLHUP is set when a socket's connection has been terminated.
- *
- * IMPORTANT: The fact that a read or write operation will not block does NOT
- * imply that the operation will succeed!
- */
-
-static unsigned int poll(struct file *file, struct socket *sock,
-			 poll_table *wait)
-{
-	struct sock *sk = sock->sk;
-	u32 mask;
-
-	poll_wait(file, sk->sk_sleep, wait);
-
-	if (!skb_queue_empty(&sk->sk_receive_queue) ||
-	    (sock->state == SS_UNCONNECTED) ||
-	    (sock->state == SS_DISCONNECTING))
-		mask = (POLLRDNORM | POLLIN);
-	else
-		mask = 0;
-
-	if (sock->state == SS_DISCONNECTING)
-		mask |= POLLHUP;
-	else
-		mask |= POLLOUT;
-
-	return mask;
-}
-
-/**
- * dest_name_check - verify user is permitted to send to specified port name
- * @dest: destination address
- * @m: descriptor for message to be sent
- *
- * Prevents restricted configuration commands from being issued by
- * unauthorized users.
- *
- * Returns 0 if permission is granted, otherwise errno
- */
-
-static int dest_name_check(struct sockaddr_tipc *dest, struct msghdr *m)
-{
-	struct tipc_cfg_msg_hdr hdr;
-
-	if (likely(dest->addr.name.name.type >= TIPC_RESERVED_TYPES))
-		return 0;
-	if (likely(dest->addr.name.name.type == TIPC_TOP_SRV))
-		return 0;
-	if (likely(dest->addr.name.name.type != TIPC_CFG_SRV))
-		return -EACCES;
-
-	if (copy_from_user(&hdr, m->msg_iov[0].iov_base, sizeof(hdr)))
-		return -EFAULT;
-	if ((ntohs(hdr.tcm_type) & 0xC000) && (!capable(CAP_NET_ADMIN)))
-		return -EACCES;
-
-	return 0;
-}
-
-/**
- * send_msg - send message in connectionless manner
- * @iocb: if NULL, indicates that socket lock is already held
- * @sock: socket structure
- * @m: message to send
- * @total_len: length of message
- *
- * Message must have an destination specified explicitly.
- * Used for SOCK_RDM and SOCK_DGRAM messages,
- * and for 'SYN' messages on SOCK_SEQPACKET and SOCK_STREAM connections.
- * (Note: 'SYN+' is prohibited on SOCK_STREAM.)
- *
- * Returns the number of bytes sent on success, or errno otherwise
- */
-
-static int send_msg(struct kiocb *iocb, struct socket *sock,
-		    struct msghdr *m, size_t total_len)
-{
-	struct sock *sk = sock->sk;
-	struct tipc_port *tport = tipc_sk_port(sk);
-	struct sockaddr_tipc *dest = (struct sockaddr_tipc *)m->msg_name;
-	int needs_conn;
-	int res = -EINVAL;
-
-	if (unlikely(!dest))
-		return -EDESTADDRREQ;
-	if (unlikely((m->msg_namelen < sizeof(*dest)) ||
-		     (dest->family != AF_TIPC)))
-		return -EINVAL;
-
-	if (iocb)
-		lock_sock(sk);
-
-	needs_conn = (sock->state != SS_READY);
-	if (unlikely(needs_conn)) {
-		if (sock->state == SS_LISTENING) {
-			res = -EPIPE;
-			goto exit;
-		}
-		if (sock->state != SS_UNCONNECTED) {
-			res = -EISCONN;
-			goto exit;
-		}
-		if ((tport->published) ||
-		    ((sock->type == SOCK_STREAM) && (total_len != 0))) {
-			res = -EOPNOTSUPP;
-			goto exit;
-		}
-		if (dest->addrtype == TIPC_ADDR_NAME) {
-			tport->conn_type = dest->addr.name.name.type;
-			tport->conn_instance = dest->addr.name.name.instance;
-		}
-
-		/* Abort any pending connection attempts (very unlikely) */
-
-		reject_rx_queue(sk);
-	}
-
-	do {
-		if (dest->addrtype == TIPC_ADDR_NAME) {
-			if ((res = dest_name_check(dest, m)))
-				break;
-			res = tipc_send2name(tport->ref,
-					     &dest->addr.name.name,
-					     dest->addr.name.domain,
-					     m->msg_iovlen,
-					     m->msg_iov);
-		}
-		else if (dest->addrtype == TIPC_ADDR_ID) {
-			res = tipc_send2port(tport->ref,
-					     &dest->addr.id,
-					     m->msg_iovlen,
-					     m->msg_iov);
-		}
-		else if (dest->addrtype == TIPC_ADDR_MCAST) {
-			if (needs_conn) {
-				res = -EOPNOTSUPP;
-				break;
-			}
-			if ((res = dest_name_check(dest, m)))
-				break;
-			res = tipc_multicast(tport->ref,
-					     &dest->addr.nameseq,
-					     0,
-					     m->msg_iovlen,
-					     m->msg_iov);
-		}
-		if (likely(res != -ELINKCONG)) {
-			if (needs_conn && (res >= 0)) {
-				sock->state = SS_CONNECTING;
-			}
-			break;
-		}
-		if (m->msg_flags & MSG_DONTWAIT) {
-			res = -EWOULDBLOCK;
-			break;
-		}
-		release_sock(sk);
-		res = wait_event_interruptible(*sk->sk_sleep,
-					       !tport->congested);
-		lock_sock(sk);
-		if (res)
-			break;
-	} while (1);
-
-exit:
-	if (iocb)
-		release_sock(sk);
-	return res;
-}
-
-/**
- * send_packet - send a connection-oriented message
- * @iocb: if NULL, indicates that socket lock is already held
- * @sock: socket structure
- * @m: message to send
- * @total_len: length of message
- *
- * Used for SOCK_SEQPACKET messages and SOCK_STREAM data.
- *
- * Returns the number of bytes sent on success, or errno otherwise
- */
-
-static int send_packet(struct kiocb *iocb, struct socket *sock,
-		       struct msghdr *m, size_t total_len)
-{
-	struct sock *sk = sock->sk;
-	struct tipc_port *tport = tipc_sk_port(sk);
-	struct sockaddr_tipc *dest = (struct sockaddr_tipc *)m->msg_name;
-	int res;
-
-	/* Handle implied connection establishment */
-
-	if (unlikely(dest))
-		return send_msg(iocb, sock, m, total_len);
-
-	if (iocb)
-		lock_sock(sk);
-
-	do {
-		if (unlikely(sock->state != SS_CONNECTED)) {
-			if (sock->state == SS_DISCONNECTING)
-				res = -EPIPE;
-			else
-				res = -ENOTCONN;
-			break;
-		}
-
-		res = tipc_send(tport->ref, m->msg_iovlen, m->msg_iov);
-		if (likely(res != -ELINKCONG)) {
-			break;
-		}
-		if (m->msg_flags & MSG_DONTWAIT) {
-			res = -EWOULDBLOCK;
-			break;
-		}
-		release_sock(sk);
-		res = wait_event_interruptible(*sk->sk_sleep,
-			(!tport->congested || !tport->connected));
-		lock_sock(sk);
-		if (res)
-			break;
-	} while (1);
-
-	if (iocb)
-		release_sock(sk);
-	return res;
-}
-
-/**
- * send_stream - send stream-oriented data
- * @iocb: (unused)
- * @sock: socket structure
- * @m: data to send
- * @total_len: total length of data to be sent
- *
- * Used for SOCK_STREAM data.
- *
- * Returns the number of bytes sent on success (or partial success),
- * or errno if no data sent
- */
-
-static int send_stream(struct kiocb *iocb, struct socket *sock,
-		       struct msghdr *m, size_t total_len)
-{
-	struct sock *sk = sock->sk;
-	struct tipc_port *tport = tipc_sk_port(sk);
-	struct msghdr my_msg;
-	struct iovec my_iov;
-	struct iovec *curr_iov;
-	int curr_iovlen;
-	char __user *curr_start;
-	u32 hdr_size;
-	int curr_left;
-	int bytes_to_send;
-	int bytes_sent;
-	int res;
-
-	lock_sock(sk);
-
-	/* Handle special cases where there is no connection */
-
-	if (unlikely(sock->state != SS_CONNECTED)) {
-		if (sock->state == SS_UNCONNECTED) {
-			res = send_packet(NULL, sock, m, total_len);
-			goto exit;
-		} else if (sock->state == SS_DISCONNECTING) {
-			res = -EPIPE;
-			goto exit;
-		} else {
-			res = -ENOTCONN;
-			goto exit;
-		}
-	}
-
-	if (unlikely(m->msg_name)) {
-		res = -EISCONN;
-		goto exit;
-	}
-
-	/*
-	 * Send each iovec entry using one or more messages
-	 *
-	 * Note: This algorithm is good for the most likely case
-	 * (i.e. one large iovec entry), but could be improved to pass sets
-	 * of small iovec entries into send_packet().
-	 */
-
-	curr_iov = m->msg_iov;
-	curr_iovlen = m->msg_iovlen;
-	my_msg.msg_iov = &my_iov;
-	my_msg.msg_iovlen = 1;
-	my_msg.msg_flags = m->msg_flags;
-	my_msg.msg_name = NULL;
-	bytes_sent = 0;
-
-	hdr_size = msg_hdr_sz(&tport->phdr);
-
-	while (curr_iovlen--) {
-		curr_start = curr_iov->iov_base;
-		curr_left = curr_iov->iov_len;
-
-		while (curr_left) {
-			bytes_to_send = tport->max_pkt - hdr_size;
-			if (bytes_to_send > TIPC_MAX_USER_MSG_SIZE)
-				bytes_to_send = TIPC_MAX_USER_MSG_SIZE;
-			if (curr_left < bytes_to_send)
-				bytes_to_send = curr_left;
-			my_iov.iov_base = curr_start;
-			my_iov.iov_len = bytes_to_send;
-			if ((res = send_packet(NULL, sock, &my_msg, 0)) < 0) {
-				if (bytes_sent)
-					res = bytes_sent;
-				goto exit;
-			}
-			curr_left -= bytes_to_send;
-			curr_start += bytes_to_send;
-			bytes_sent += bytes_to_send;
-		}
-
-		curr_iov++;
-	}
-	res = bytes_sent;
-exit:
-	release_sock(sk);
-	return res;
-}
-
-/**
- * auto_connect - complete connection setup to a remote port
- * @sock: socket structure
- * @msg: peer's response message
- *
- * Returns 0 on success, errno otherwise
- */
-
-static int auto_connect(struct socket *sock, struct tipc_msg *msg)
-{
-	struct tipc_sock *tsock = tipc_sk(sock->sk);
-
-	if (msg_errcode(msg)) {
-		sock->state = SS_DISCONNECTING;
-		return -ECONNREFUSED;
-	}
-
-	tsock->peer_name.ref = msg_origport(msg);
-	tsock->peer_name.node = msg_orignode(msg);
-	tipc_connect2port(tsock->p->ref, &tsock->peer_name);
-	tipc_set_portimportance(tsock->p->ref, msg_importance(msg));
-	sock->state = SS_CONNECTED;
-	return 0;
-}
-
-/**
- * set_orig_addr - capture sender's address for received message
- * @m: descriptor for message info
- * @msg: received message header
- *
- * Note: Address is not captured if not requested by receiver.
- */
-
-static void set_orig_addr(struct msghdr *m, struct tipc_msg *msg)
-{
-	struct sockaddr_tipc *addr = (struct sockaddr_tipc *)m->msg_name;
-
-	if (addr) {
-		addr->family = AF_TIPC;
-		addr->addrtype = TIPC_ADDR_ID;
-		addr->addr.id.ref = msg_origport(msg);
-		addr->addr.id.node = msg_orignode(msg);
-		addr->addr.name.domain = 0;   	/* could leave uninitialized */
-		addr->scope = 0;   		/* could leave uninitialized */
-		m->msg_namelen = sizeof(struct sockaddr_tipc);
-	}
-}
-
-/**
- * anc_data_recv - optionally capture ancillary data for received message
- * @m: descriptor for message info
- * @msg: received message header
- * @tport: TIPC port associated with message
- *
- * Note: Ancillary data is not captured if not requested by receiver.
- *
- * Returns 0 if successful, otherwise errno
- */
-
-static int anc_data_recv(struct msghdr *m, struct tipc_msg *msg,
-				struct tipc_port *tport)
-{
-	u32 anc_data[3];
-	u32 err;
-	u32 dest_type;
-	int has_name;
-	int res;
-
-	if (likely(m->msg_controllen == 0))
-		return 0;
-
-	/* Optionally capture errored message object(s) */
-
-	err = msg ? msg_errcode(msg) : 0;
-	if (unlikely(err)) {
-		anc_data[0] = err;
-		anc_data[1] = msg_data_sz(msg);
-		if ((res = put_cmsg(m, SOL_TIPC, TIPC_ERRINFO, 8, anc_data)))
-			return res;
-		if (anc_data[1] &&
-		    (res = put_cmsg(m, SOL_TIPC, TIPC_RETDATA, anc_data[1],
-				    msg_data(msg))))
-			return res;
-	}
-
-	/* Optionally capture message destination object */
-
-	dest_type = msg ? msg_type(msg) : TIPC_DIRECT_MSG;
-	switch (dest_type) {
-	case TIPC_NAMED_MSG:
-		has_name = 1;
-		anc_data[0] = msg_nametype(msg);
-		anc_data[1] = msg_namelower(msg);
-		anc_data[2] = msg_namelower(msg);
-		break;
-	case TIPC_MCAST_MSG:
-		has_name = 1;
-		anc_data[0] = msg_nametype(msg);
-		anc_data[1] = msg_namelower(msg);
-		anc_data[2] = msg_nameupper(msg);
-		break;
-	case TIPC_CONN_MSG:
-		has_name = (tport->conn_type != 0);
-		anc_data[0] = tport->conn_type;
-		anc_data[1] = tport->conn_instance;
-		anc_data[2] = tport->conn_instance;
-		break;
-	default:
-		has_name = 0;
-	}
-	if (has_name &&
-	    (res = put_cmsg(m, SOL_TIPC, TIPC_DESTNAME, 12, anc_data)))
-		return res;
-
-	return 0;
-}
-
-/**
- * recv_msg - receive packet-oriented message
- * @iocb: (unused)
- * @m: descriptor for message info
- * @buf_len: total size of user buffer area
- * @flags: receive flags
- *
- * Used for SOCK_DGRAM, SOCK_RDM, and SOCK_SEQPACKET messages.
- * If the complete message doesn't fit in user area, truncate it.
- *
- * Returns size of returned message data, errno otherwise
- */
-
-static int recv_msg(struct kiocb *iocb, struct socket *sock,
-		    struct msghdr *m, size_t buf_len, int flags)
-{
-	struct sock *sk = sock->sk;
-	struct tipc_port *tport = tipc_sk_port(sk);
-	struct sk_buff *buf;
-	struct tipc_msg *msg;
-	unsigned int sz;
-	u32 err;
-	int res;
-
-	/* Catch invalid receive requests */
-
-	if (m->msg_iovlen != 1)
-		return -EOPNOTSUPP;   /* Don't do multiple iovec entries yet */
-
-	if (unlikely(!buf_len))
-		return -EINVAL;
-
-	lock_sock(sk);
-
-	if (unlikely(sock->state == SS_UNCONNECTED)) {
-		res = -ENOTCONN;
-		goto exit;
-	}
-
-restart:
-
-	/* Look for a message in receive queue; wait if necessary */
-
-	while (skb_queue_empty(&sk->sk_receive_queue)) {
-		if (sock->state == SS_DISCONNECTING) {
-			res = -ENOTCONN;
-			goto exit;
-		}
-		if (flags & MSG_DONTWAIT) {
-			res = -EWOULDBLOCK;
-			goto exit;
-		}
-		release_sock(sk);
-		res = wait_event_interruptible(*sk->sk_sleep,
-			(!skb_queue_empty(&sk->sk_receive_queue) ||
-			 (sock->state == SS_DISCONNECTING)));
-		lock_sock(sk);
-		if (res)
-			goto exit;
-	}
-
-	/* Look at first message in receive queue */
-
-	buf = skb_peek(&sk->sk_receive_queue);
-	msg = buf_msg(buf);
-	sz = msg_data_sz(msg);
-	err = msg_errcode(msg);
-
-	/* Complete connection setup for an implied connect */
-
-	if (unlikely(sock->state == SS_CONNECTING)) {
-		res = auto_connect(sock, msg);
-		if (res)
-			goto exit;
-	}
-
-	/* Discard an empty non-errored message & try again */
-
-	if ((!sz) && (!err)) {
-		advance_rx_queue(sk);
-		goto restart;
-	}
-
-	/* Capture sender's address (optional) */
-
-	set_orig_addr(m, msg);
-
-	/* Capture ancillary data (optional) */
-
-	res = anc_data_recv(m, msg, tport);
-	if (res)
-		goto exit;
-
-	/* Capture message data (if valid) & compute return value (always) */
-
-	if (!err) {
-		if (unlikely(buf_len < sz)) {
-			sz = buf_len;
-			m->msg_flags |= MSG_TRUNC;
-		}
-		if (unlikely(copy_to_user(m->msg_iov->iov_base, msg_data(msg),
-					  sz))) {
-			res = -EFAULT;
-			goto exit;
-		}
-		res = sz;
-	} else {
-		if ((sock->state == SS_READY) ||
-		    ((err == TIPC_CONN_SHUTDOWN) || m->msg_control))
-			res = 0;
-		else
-			res = -ECONNRESET;
-	}
-
-	/* Consume received message (optional) */
-
-	if (likely(!(flags & MSG_PEEK))) {
-		if ((sock->state != SS_READY) &&
-		    (++tport->conn_unacked >= TIPC_FLOW_CONTROL_WIN))
-			tipc_acknowledge(tport->ref, tport->conn_unacked);
-		advance_rx_queue(sk);
-	}
-exit:
-	release_sock(sk);
-	return res;
-}
-
-/**
- * recv_stream - receive stream-oriented data
- * @iocb: (unused)
- * @m: descriptor for message info
- * @buf_len: total size of user buffer area
- * @flags: receive flags
- *
- * Used for SOCK_STREAM messages only.  If not enough data is available
- * will optionally wait for more; never truncates data.
- *
- * Returns size of returned message data, errno otherwise
- */
-
-static int recv_stream(struct kiocb *iocb, struct socket *sock,
-		       struct msghdr *m, size_t buf_len, int flags)
-{
-	struct sock *sk = sock->sk;
-	struct tipc_port *tport = tipc_sk_port(sk);
-	struct sk_buff *buf;
-	struct tipc_msg *msg;
-	unsigned int sz;
-	int sz_to_copy;
-	int sz_copied = 0;
-	int needed;
-	char __user *crs = m->msg_iov->iov_base;
-	unsigned char *buf_crs;
-	u32 err;
-	int res = 0;
-
-	/* Catch invalid receive attempts */
-
-	if (m->msg_iovlen != 1)
-		return -EOPNOTSUPP;   /* Don't do multiple iovec entries yet */
-
-	if (unlikely(!buf_len))
-		return -EINVAL;
-
-	lock_sock(sk);
-
-	if (unlikely((sock->state == SS_UNCONNECTED) ||
-		     (sock->state == SS_CONNECTING))) {
-		res = -ENOTCONN;
-		goto exit;
-	}
-
-restart:
-
-	/* Look for a message in receive queue; wait if necessary */
-
-	while (skb_queue_empty(&sk->sk_receive_queue)) {
-		if (sock->state == SS_DISCONNECTING) {
-			res = -ENOTCONN;
-			goto exit;
-		}
-		if (flags & MSG_DONTWAIT) {
-			res = -EWOULDBLOCK;
-			goto exit;
-		}
-		release_sock(sk);
-		res = wait_event_interruptible(*sk->sk_sleep,
-			(!skb_queue_empty(&sk->sk_receive_queue) ||
-			 (sock->state == SS_DISCONNECTING)));
-		lock_sock(sk);
-		if (res)
-			goto exit;
-	}
-
-	/* Look at first message in receive queue */
-
-	buf = skb_peek(&sk->sk_receive_queue);
-	msg = buf_msg(buf);
-	sz = msg_data_sz(msg);
-	err = msg_errcode(msg);
-
-	/* Discard an empty non-errored message & try again */
-
-	if ((!sz) && (!err)) {
-		advance_rx_queue(sk);
-		goto restart;
-	}
-
-	/* Optionally capture sender's address & ancillary data of first msg */
-
-	if (sz_copied == 0) {
-		set_orig_addr(m, msg);
-		res = anc_data_recv(m, msg, tport);
-		if (res)
-			goto exit;
-	}
-
-	/* Capture message data (if valid) & compute return value (always) */
-
-	if (!err) {
-		buf_crs = (unsigned char *)(TIPC_SKB_CB(buf)->handle);
-		sz = (unsigned char *)msg + msg_size(msg) - buf_crs;
-
-		needed = (buf_len - sz_copied);
-		sz_to_copy = (sz <= needed) ? sz : needed;
-		if (unlikely(copy_to_user(crs, buf_crs, sz_to_copy))) {
-			res = -EFAULT;
-			goto exit;
-		}
-		sz_copied += sz_to_copy;
-
-		if (sz_to_copy < sz) {
-			if (!(flags & MSG_PEEK))
-				TIPC_SKB_CB(buf)->handle = buf_crs + sz_to_copy;
-			goto exit;
-		}
-
-		crs += sz_to_copy;
-	} else {
-		if (sz_copied != 0)
-			goto exit; /* can't add error msg to valid data */
-
-		if ((err == TIPC_CONN_SHUTDOWN) || m->msg_control)
-			res = 0;
-		else
-			res = -ECONNRESET;
-	}
-
-	/* Consume received message (optional) */
-
-	if (likely(!(flags & MSG_PEEK))) {
-		if (unlikely(++tport->conn_unacked >= TIPC_FLOW_CONTROL_WIN))
-			tipc_acknowledge(tport->ref, tport->conn_unacked);
-		advance_rx_queue(sk);
-	}
-
-	/* Loop around if more data is required */
-
-	if ((sz_copied < buf_len)    /* didn't get all requested data */
-	    && (!skb_queue_empty(&sk->sk_receive_queue) ||
-		(flags & MSG_WAITALL))
-				     /* ... and more is ready or required */
-	    && (!(flags & MSG_PEEK)) /* ... and aren't just peeking at data */
-	    && (!err)                /* ... and haven't reached a FIN */
-	    )
-		goto restart;
-
-exit:
-	release_sock(sk);
-	return sz_copied ? sz_copied : res;
-}
-
-/**
- * rx_queue_full - determine if receive queue can accept another message
- * @msg: message to be added to queue
- * @queue_size: current size of queue
- * @base: nominal maximum size of queue
- *
- * Returns 1 if queue is unable to accept message, 0 otherwise
- */
-
-static int rx_queue_full(struct tipc_msg *msg, u32 queue_size, u32 base)
-{
-	u32 threshold;
-	u32 imp = msg_importance(msg);
-
-	if (imp == TIPC_LOW_IMPORTANCE)
-		threshold = base;
-	else if (imp == TIPC_MEDIUM_IMPORTANCE)
-		threshold = base * 2;
-	else if (imp == TIPC_HIGH_IMPORTANCE)
-		threshold = base * 100;
-	else
-		return 0;
-
-	if (msg_connected(msg))
-		threshold *= 4;
-
-	return (queue_size >= threshold);
-}
-
-/**
- * filter_rcv - validate incoming message
- * @sk: socket
- * @buf: message
- *
- * Enqueues message on receive queue if acceptable; optionally handles
- * disconnect indication for a connected socket.
- *
- * Called with socket lock already taken; port lock may also be taken.
- *
- * Returns TIPC error status code (TIPC_OK if message is not to be rejected)
- */
-
-static u32 filter_rcv(struct sock *sk, struct sk_buff *buf)
-{
-	struct socket *sock = sk->sk_socket;
-	struct tipc_msg *msg = buf_msg(buf);
-	u32 recv_q_len;
-
-	/* Reject message if it is wrong sort of message for socket */
-
-	/*
-	 * WOULD IT BE BETTER TO JUST DISCARD THESE MESSAGES INSTEAD?
-	 * "NO PORT" ISN'T REALLY THE RIGHT ERROR CODE, AND THERE MAY
-	 * BE SECURITY IMPLICATIONS INHERENT IN REJECTING INVALID TRAFFIC
-	 */
-
-	if (sock->state == SS_READY) {
-		if (msg_connected(msg)) {
-			msg_dbg(msg, "dispatch filter 1\n");
-			return TIPC_ERR_NO_PORT;
-		}
-	} else {
-		if (msg_mcast(msg)) {
-			msg_dbg(msg, "dispatch filter 2\n");
-			return TIPC_ERR_NO_PORT;
-		}
-		if (sock->state == SS_CONNECTED) {
-			if (!msg_connected(msg)) {
-				msg_dbg(msg, "dispatch filter 3\n");
-				return TIPC_ERR_NO_PORT;
-			}
-		}
-		else if (sock->state == SS_CONNECTING) {
-			if (!msg_connected(msg) && (msg_errcode(msg) == 0)) {
-				msg_dbg(msg, "dispatch filter 4\n");
-				return TIPC_ERR_NO_PORT;
-			}
-		}
-		else if (sock->state == SS_LISTENING) {
-			if (msg_connected(msg) || msg_errcode(msg)) {
-				msg_dbg(msg, "dispatch filter 5\n");
-				return TIPC_ERR_NO_PORT;
-			}
-		}
-		else if (sock->state == SS_DISCONNECTING) {
-			msg_dbg(msg, "dispatch filter 6\n");
-			return TIPC_ERR_NO_PORT;
-		}
-		else /* (sock->state == SS_UNCONNECTED) */ {
-			if (msg_connected(msg) || msg_errcode(msg)) {
-				msg_dbg(msg, "dispatch filter 7\n");
-				return TIPC_ERR_NO_PORT;
-			}
-		}
-	}
-
-	/* Reject message if there isn't room to queue it */
-
-	recv_q_len = (u32)atomic_read(&tipc_queue_size);
-	if (unlikely(recv_q_len >= OVERLOAD_LIMIT_BASE)) {
-		if (rx_queue_full(msg, recv_q_len, OVERLOAD_LIMIT_BASE))
-			return TIPC_ERR_OVERLOAD;
-	}
-	recv_q_len = skb_queue_len(&sk->sk_receive_queue);
-	if (unlikely(recv_q_len >= (OVERLOAD_LIMIT_BASE / 2))) {
-		if (rx_queue_full(msg, recv_q_len, OVERLOAD_LIMIT_BASE / 2))
-			return TIPC_ERR_OVERLOAD;
-	}
-
-	/* Enqueue message (finally!) */
-
-	msg_dbg(msg, "<DISP<: ");
-	TIPC_SKB_CB(buf)->handle = msg_data(msg);
-	atomic_inc(&tipc_queue_size);
-	__skb_queue_tail(&sk->sk_receive_queue, buf);
-
-	/* Initiate connection termination for an incoming 'FIN' */
-
-	if (unlikely(msg_errcode(msg) && (sock->state == SS_CONNECTED))) {
-		sock->state = SS_DISCONNECTING;
-		tipc_disconnect_port(tipc_sk_port(sk));
-	}
-
-	if (waitqueue_active(sk->sk_sleep))
-		wake_up_interruptible(sk->sk_sleep);
-	return TIPC_OK;
-}
-
-/**
- * backlog_rcv - handle incoming message from backlog queue
- * @sk: socket
- * @buf: message
- *
- * Caller must hold socket lock, but not port lock.
- *
- * Returns 0
- */
-
-static int backlog_rcv(struct sock *sk, struct sk_buff *buf)
-{
-	u32 res;
-
-	res = filter_rcv(sk, buf);
-	if (res)
-		tipc_reject_msg(buf, res);
-	return 0;
-}
-
-/**
- * dispatch - handle incoming message
- * @tport: TIPC port that received message
- * @buf: message
- *
- * Called with port lock already taken.
- *
- * Returns TIPC error status code (TIPC_OK if message is not to be rejected)
- */
-
-static u32 dispatch(struct tipc_port *tport, struct sk_buff *buf)
-{
-	struct sock *sk = (struct sock *)tport->usr_handle;
-	u32 res;
-
-	/*
-	 * Process message if socket is unlocked; otherwise add to backlog queue
-	 *
-	 * This code is based on sk_receive_skb(), but must be distinct from it
-	 * since a TIPC-specific filter/reject mechanism is utilized
-	 */
-
-	bh_lock_sock(sk);
-	if (!sock_owned_by_user(sk)) {
-		res = filter_rcv(sk, buf);
-	} else {
-		sk_add_backlog(sk, buf);
-		res = TIPC_OK;
-	}
-	bh_unlock_sock(sk);
-
-	return res;
-}
-
-/**
- * wakeupdispatch - wake up port after congestion
- * @tport: port to wakeup
- *
- * Called with port lock already taken.
- */
-
-static void wakeupdispatch(struct tipc_port *tport)
-{
-	struct sock *sk = (struct sock *)tport->usr_handle;
-
-	if (waitqueue_active(sk->sk_sleep))
-		wake_up_interruptible(sk->sk_sleep);
-}
-
-/**
- * connect - establish a connection to another TIPC port
- * @sock: socket structure
- * @dest: socket address for destination port
- * @destlen: size of socket address data structure
- * @flags: file-related flags associated with socket
- *
- * Returns 0 on success, errno otherwise
- */
-
-static int connect(struct socket *sock, struct sockaddr *dest, int destlen,
-		   int flags)
-{
-	struct sock *sk = sock->sk;
-	struct sockaddr_tipc *dst = (struct sockaddr_tipc *)dest;
-	struct msghdr m = {NULL,};
-	struct sk_buff *buf;
-	struct tipc_msg *msg;
-	int res;
-
-	lock_sock(sk);
-
-	/* For now, TIPC does not allow use of connect() with DGRAM/RDM types */
-
-	if (sock->state == SS_READY) {
-		res = -EOPNOTSUPP;
-		goto exit;
-	}
-
-	/* For now, TIPC does not support the non-blocking form of connect() */
-
-	if (flags & O_NONBLOCK) {
-		res = -EWOULDBLOCK;
-		goto exit;
-	}
-
-	/* Issue Posix-compliant error code if socket is in the wrong state */
-
-	if (sock->state == SS_LISTENING) {
-		res = -EOPNOTSUPP;
-		goto exit;
-	}
-	if (sock->state == SS_CONNECTING) {
-		res = -EALREADY;
-		goto exit;
-	}
-	if (sock->state != SS_UNCONNECTED) {
-		res = -EISCONN;
-		goto exit;
-	}
-
-	/*
-	 * Reject connection attempt using multicast address
-	 *
-	 * Note: send_msg() validates the rest of the address fields,
-	 *       so there's no need to do it here
-	 */
-
-	if (dst->addrtype == TIPC_ADDR_MCAST) {
-		res = -EINVAL;
-		goto exit;
-	}
-
-	/* Reject any messages already in receive queue (very unlikely) */
-
-	reject_rx_queue(sk);
-
-	/* Send a 'SYN-' to destination */
-
-	m.msg_name = dest;
-	m.msg_namelen = destlen;
-	res = send_msg(NULL, sock, &m, 0);
-	if (res < 0) {
-		goto exit;
-	}
-
-	/* Wait until an 'ACK' or 'RST' arrives, or a timeout occurs */
-
-	release_sock(sk);
-	res = wait_event_interruptible_timeout(*sk->sk_sleep,
-			(!skb_queue_empty(&sk->sk_receive_queue) ||
-			(sock->state != SS_CONNECTING)),
-			sk->sk_rcvtimeo);
-	lock_sock(sk);
-
-	if (res > 0) {
-		buf = skb_peek(&sk->sk_receive_queue);
-		if (buf != NULL) {
-			msg = buf_msg(buf);
-			res = auto_connect(sock, msg);
-			if (!res) {
-				if (!msg_data_sz(msg))
-					advance_rx_queue(sk);
-			}
-		} else {
-			if (sock->state == SS_CONNECTED) {
-				res = -EISCONN;
-			} else {
-				res = -ECONNREFUSED;
-			}
-		}
-	} else {
-		if (res == 0)
-			res = -ETIMEDOUT;
-		else
-			; /* leave "res" unchanged */
-		sock->state = SS_DISCONNECTING;
-	}
-
-exit:
-	release_sock(sk);
-	return res;
-}
-
-/**
- * listen - allow socket to listen for incoming connections
- * @sock: socket structure
- * @len: (unused)
- *
- * Returns 0 on success, errno otherwise
- */
-
-static int listen(struct socket *sock, int len)
-{
-	struct sock *sk = sock->sk;
-	int res;
-
-	lock_sock(sk);
-
-	if (sock->state == SS_READY)
-		res = -EOPNOTSUPP;
-	else if (sock->state != SS_UNCONNECTED)
-		res = -EINVAL;
-	else {
-		sock->state = SS_LISTENING;
-		res = 0;
-	}
-
-	release_sock(sk);
-	return res;
-}
-
-/**
- * accept - wait for connection request
- * @sock: listening socket
- * @newsock: new socket that is to be connected
- * @flags: file-related flags associated with socket
- *
- * Returns 0 on success, errno otherwise
- */
-
-static int accept(struct socket *sock, struct socket *new_sock, int flags)
-{
-	struct sock *sk = sock->sk;
-	struct sk_buff *buf;
-	int res;
-
-	lock_sock(sk);
-
-	if (sock->state == SS_READY) {
-		res = -EOPNOTSUPP;
-		goto exit;
-	}
-	if (sock->state != SS_LISTENING) {
-		res = -EINVAL;
-		goto exit;
-	}
-
-	while (skb_queue_empty(&sk->sk_receive_queue)) {
-		if (flags & O_NONBLOCK) {
-			res = -EWOULDBLOCK;
-			goto exit;
-		}
-		release_sock(sk);
-		res = wait_event_interruptible(*sk->sk_sleep,
-				(!skb_queue_empty(&sk->sk_receive_queue)));
-		lock_sock(sk);
-		if (res)
-			goto exit;
-	}
-
-	buf = skb_peek(&sk->sk_receive_queue);
-
-	res = tipc_create(sock_net(sock->sk), new_sock, 0);
-	if (!res) {
-		struct sock *new_sk = new_sock->sk;
-		struct tipc_sock *new_tsock = tipc_sk(new_sk);
-		struct tipc_port *new_tport = new_tsock->p;
-		u32 new_ref = new_tport->ref;
-		struct tipc_msg *msg = buf_msg(buf);
-
-		lock_sock(new_sk);
-
-		/*
-		 * Reject any stray messages received by new socket
-		 * before the socket lock was taken (very, very unlikely)
-		 */
-
-		reject_rx_queue(new_sk);
-
-		/* Connect new socket to it's peer */
-
-		new_tsock->peer_name.ref = msg_origport(msg);
-		new_tsock->peer_name.node = msg_orignode(msg);
-		tipc_connect2port(new_ref, &new_tsock->peer_name);
-		new_sock->state = SS_CONNECTED;
-
-		tipc_set_portimportance(new_ref, msg_importance(msg));
-		if (msg_named(msg)) {
-			new_tport->conn_type = msg_nametype(msg);
-			new_tport->conn_instance = msg_nameinst(msg);
-		}
-
-		/*
-		 * Respond to 'SYN-' by discarding it & returning 'ACK'-.
-		 * Respond to 'SYN+' by queuing it on new socket.
-		 */
-
-		msg_dbg(msg,"<ACC<: ");
-		if (!msg_data_sz(msg)) {
-			struct msghdr m = {NULL,};
-
-			advance_rx_queue(sk);
-			send_packet(NULL, new_sock, &m, 0);
-		} else {
-			__skb_dequeue(&sk->sk_receive_queue);
-			__skb_queue_head(&new_sk->sk_receive_queue, buf);
-		}
-		release_sock(new_sk);
-	}
-exit:
-	release_sock(sk);
-	return res;
-}
-
-/**
- * shutdown - shutdown socket connection
- * @sock: socket structure
- * @how: direction to close (must be SHUT_RDWR)
- *
- * Terminates connection (if necessary), then purges socket's receive queue.
- *
- * Returns 0 on success, errno otherwise
- */
-
-static int shutdown(struct socket *sock, int how)
-{
-	struct sock *sk = sock->sk;
-	struct tipc_port *tport = tipc_sk_port(sk);
-	struct sk_buff *buf;
-	int res;
-
-	if (how != SHUT_RDWR)
-		return -EINVAL;
-
-	lock_sock(sk);
-
-	switch (sock->state) {
-	case SS_CONNECTING:
-	case SS_CONNECTED:
-
-		/* Disconnect and send a 'FIN+' or 'FIN-' message to peer */
-restart:
-		buf = __skb_dequeue(&sk->sk_receive_queue);
-		if (buf) {
-			atomic_dec(&tipc_queue_size);
-			if (TIPC_SKB_CB(buf)->handle != msg_data(buf_msg(buf))) {
-				buf_discard(buf);
-				goto restart;
-			}
-			tipc_disconnect(tport->ref);
-			tipc_reject_msg(buf, TIPC_CONN_SHUTDOWN);
-		} else {
-			tipc_shutdown(tport->ref);
-		}
-
-		sock->state = SS_DISCONNECTING;
-
-		/* fall through */
-
-	case SS_DISCONNECTING:
-
-		/* Discard any unreceived messages; wake up sleeping tasks */
-
-		discard_rx_queue(sk);
-		if (waitqueue_active(sk->sk_sleep))
-			wake_up_interruptible(sk->sk_sleep);
-		res = 0;
-		break;
-
-	default:
-		res = -ENOTCONN;
-	}
-
-	release_sock(sk);
-	return res;
-}
-
-/**
- * setsockopt - set socket option
- * @sock: socket structure
- * @lvl: option level
- * @opt: option identifier
- * @ov: pointer to new option value
- * @ol: length of option value
- *
- * For stream sockets only, accepts and ignores all IPPROTO_TCP options
- * (to ease compatibility).
- *
- * Returns 0 on success, errno otherwise
- */
-
-static int setsockopt(struct socket *sock,
-		      int lvl, int opt, char __user *ov, int ol)
-{
-	struct sock *sk = sock->sk;
-	struct tipc_port *tport = tipc_sk_port(sk);
-	u32 value;
-	int res;
-
-	if ((lvl == IPPROTO_TCP) && (sock->type == SOCK_STREAM))
-		return 0;
-	if (lvl != SOL_TIPC)
-		return -ENOPROTOOPT;
-	if (ol < sizeof(value))
-		return -EINVAL;
-	if ((res = get_user(value, (u32 __user *)ov)))
-		return res;
-
-	lock_sock(sk);
-
-	switch (opt) {
-	case TIPC_IMPORTANCE:
-		res = tipc_set_portimportance(tport->ref, value);
-		break;
-	case TIPC_SRC_DROPPABLE:
-		if (sock->type != SOCK_STREAM)
-			res = tipc_set_portunreliable(tport->ref, value);
-		else
-			res = -ENOPROTOOPT;
-		break;
-	case TIPC_DEST_DROPPABLE:
-		res = tipc_set_portunreturnable(tport->ref, value);
-		break;
-	case TIPC_CONN_TIMEOUT:
-		sk->sk_rcvtimeo = msecs_to_jiffies(value);
-		/* no need to set "res", since already 0 at this point */
-		break;
-	default:
-		res = -EINVAL;
-	}
-
-	release_sock(sk);
-
-	return res;
-}
-
-/**
- * getsockopt - get socket option
- * @sock: socket structure
- * @lvl: option level
- * @opt: option identifier
- * @ov: receptacle for option value
- * @ol: receptacle for length of option value
- *
- * For stream sockets only, returns 0 length result for all IPPROTO_TCP options
- * (to ease compatibility).
- *
- * Returns 0 on success, errno otherwise
- */
-
-static int getsockopt(struct socket *sock,
-		      int lvl, int opt, char __user *ov, int __user *ol)
-{
-	struct sock *sk = sock->sk;
-	struct tipc_port *tport = tipc_sk_port(sk);
-	int len;
-	u32 value;
-	int res;
-
-	if ((lvl == IPPROTO_TCP) && (sock->type == SOCK_STREAM))
-		return put_user(0, ol);
-	if (lvl != SOL_TIPC)
-		return -ENOPROTOOPT;
-	if ((res = get_user(len, ol)))
-		return res;
-
-	lock_sock(sk);
-
-	switch (opt) {
-	case TIPC_IMPORTANCE:
-		res = tipc_portimportance(tport->ref, &value);
-		break;
-	case TIPC_SRC_DROPPABLE:
-		res = tipc_portunreliable(tport->ref, &value);
-		break;
-	case TIPC_DEST_DROPPABLE:
-		res = tipc_portunreturnable(tport->ref, &value);
-		break;
-	case TIPC_CONN_TIMEOUT:
-		value = jiffies_to_msecs(sk->sk_rcvtimeo);
-		/* no need to set "res", since already 0 at this point */
-		break;
-	default:
-		res = -EINVAL;
-	}
-
-	release_sock(sk);
-
-	if (res) {
-		/* "get" failed */
-	}
-	else if (len < sizeof(value)) {
-		res = -EINVAL;
-	}
-	else if (copy_to_user(ov, &value, sizeof(value))) {
-		res = -EFAULT;
-	}
-	else {
-		res = put_user(sizeof(value), ol);
-	}
-
-	return res;
-}
-
-/**
- * Protocol switches for the various types of TIPC sockets
- */
-
-static const struct proto_ops msg_ops = {
-	.owner 		= THIS_MODULE,
-	.family		= AF_TIPC,
-	.release	= release,
-	.bind		= bind,
-	.connect	= connect,
-	.socketpair	= sock_no_socketpair,
-	.accept		= accept,
-	.getname	= get_name,
-	.poll		= poll,
-	.ioctl		= sock_no_ioctl,
-	.listen		= listen,
-	.shutdown	= shutdown,
-	.setsockopt	= setsockopt,
-	.getsockopt	= getsockopt,
-	.sendmsg	= send_msg,
-	.recvmsg	= recv_msg,
-	.mmap		= sock_no_mmap,
-	.sendpage	= sock_no_sendpage
-};
-
-static const struct proto_ops packet_ops = {
-	.owner 		= THIS_MODULE,
-	.family		= AF_TIPC,
-	.release	= release,
-	.bind		= bind,
-	.connect	= connect,
-	.socketpair	= sock_no_socketpair,
-	.accept		= accept,
-	.getname	= get_name,
-	.poll		= poll,
-	.ioctl		= sock_no_ioctl,
-	.listen		= listen,
-	.shutdown	= shutdown,
-	.setsockopt	= setsockopt,
-	.getsockopt	= getsockopt,
-	.sendmsg	= send_packet,
-	.recvmsg	= recv_msg,
-	.mmap		= sock_no_mmap,
-	.sendpage	= sock_no_sendpage
-};
-
-static const struct proto_ops stream_ops = {
-	.owner 		= THIS_MODULE,
-	.family		= AF_TIPC,
-	.release	= release,
-	.bind		= bind,
-	.connect	= connect,
-	.socketpair	= sock_no_socketpair,
-	.accept		= accept,
-	.getname	= get_name,
-	.poll		= poll,
-	.ioctl		= sock_no_ioctl,
-	.listen		= listen,
-	.shutdown	= shutdown,
-	.setsockopt	= setsockopt,
-	.getsockopt	= getsockopt,
-	.sendmsg	= send_stream,
-	.recvmsg	= recv_stream,
-	.mmap		= sock_no_mmap,
-	.sendpage	= sock_no_sendpage
-};
-
-static const struct net_proto_family tipc_family_ops = {
-	.owner 		= THIS_MODULE,
-	.family		= AF_TIPC,
-	.create		= tipc_create
-};
-
-static struct proto tipc_proto = {
-	.name		= "TIPC",
-	.owner		= THIS_MODULE,
-	.obj_size	= sizeof(struct tipc_sock)
-};
-
-/**
- * tipc_socket_init - initialize TIPC socket interface
- *
- * Returns 0 on success, errno otherwise
- */
-int tipc_socket_init(void)
-{
-	int res;
-
-	res = proto_register(&tipc_proto, 1);
-	if (res) {
-		err("Failed to register TIPC protocol type\n");
-		goto out;
-	}
-
-	res = sock_register(&tipc_family_ops);
-	if (res) {
-		err("Failed to register TIPC socket type\n");
-		proto_unregister(&tipc_proto);
-		goto out;
-	}
-
-	sockets_enabled = 1;
- out:
-	return res;
-}
-
-/**
- * tipc_socket_stop - stop TIPC socket interface
- */
-
-void tipc_socket_stop(void)
-{
-	if (!sockets_enabled)
-		return;
-
-	sockets_enabled = 0;
-	sock_unregister(tipc_family_ops.family);
-	proto_unregister(&tipc_proto);
-}
-
--- net/tipc/bearer.c
+++ /dev/null
@@ -1,705 +0,0 @@
-/*
- * net/tipc/bearer.c: TIPC bearer code
- *
- * Copyright (c) 1996-2006, Ericsson AB
- * Copyright (c) 2004-2006, Wind River Systems
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the names of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "core.h"
-#include "config.h"
-#include "dbg.h"
-#include "bearer.h"
-#include "link.h"
-#include "port.h"
-#include "discover.h"
-#include "bcast.h"
-
-#define MAX_ADDR_STR 32
-
-static struct media *media_list = NULL;
-static u32 media_count = 0;
-
-struct bearer *tipc_bearers = NULL;
-
-/**
- * media_name_valid - validate media name
- *
- * Returns 1 if media name is valid, otherwise 0.
- */
-
-static int media_name_valid(const char *name)
-{
-	u32 len;
-
-	len = strlen(name);
-	if ((len + 1) > TIPC_MAX_MEDIA_NAME)
-		return 0;
-	return (strspn(name, tipc_alphabet) == len);
-}
-
-/**
- * media_find - locates specified media object by name
- */
-
-static struct media *media_find(const char *name)
-{
-	struct media *m_ptr;
-	u32 i;
-
-	for (i = 0, m_ptr = media_list; i < media_count; i++, m_ptr++) {
-		if (!strcmp(m_ptr->name, name))
-			return m_ptr;
-	}
-	return NULL;
-}
-
-/**
- * tipc_register_media - register a media type
- *
- * Bearers for this media type must be activated separately at a later stage.
- */
-
-int  tipc_register_media(u32 media_type,
-			 char *name,
-			 int (*enable)(struct tipc_bearer *),
-			 void (*disable)(struct tipc_bearer *),
-			 int (*send_msg)(struct sk_buff *,
-					 struct tipc_bearer *,
-					 struct tipc_media_addr *),
-			 char *(*addr2str)(struct tipc_media_addr *a,
-					   char *str_buf, int str_size),
-			 struct tipc_media_addr *bcast_addr,
-			 const u32 bearer_priority,
-			 const u32 link_tolerance,  /* [ms] */
-			 const u32 send_window_limit)
-{
-	struct media *m_ptr;
-	u32 media_id;
-	u32 i;
-	int res = -EINVAL;
-
-	write_lock_bh(&tipc_net_lock);
-	if (!media_list)
-		goto exit;
-
-	if (!media_name_valid(name)) {
-		warn("Media <%s> rejected, illegal name\n", name);
-		goto exit;
-	}
-	if (!bcast_addr) {
-		warn("Media <%s> rejected, no broadcast address\n", name);
-		goto exit;
-	}
-	if ((bearer_priority < TIPC_MIN_LINK_PRI) &&
-	    (bearer_priority > TIPC_MAX_LINK_PRI)) {
-		warn("Media <%s> rejected, illegal priority (%u)\n", name,
-		     bearer_priority);
-		goto exit;
-	}
-	if ((link_tolerance < TIPC_MIN_LINK_TOL) ||
-	    (link_tolerance > TIPC_MAX_LINK_TOL)) {
-		warn("Media <%s> rejected, illegal tolerance (%u)\n", name,
-		     link_tolerance);
-		goto exit;
-	}
-
-	media_id = media_count++;
-	if (media_id >= MAX_MEDIA) {
-		warn("Media <%s> rejected, media limit reached (%u)\n", name,
-		     MAX_MEDIA);
-		media_count--;
-		goto exit;
-	}
-	for (i = 0; i < media_id; i++) {
-		if (media_list[i].type_id == media_type) {
-			warn("Media <%s> rejected, duplicate type (%u)\n", name,
-			     media_type);
-			media_count--;
-			goto exit;
-		}
-		if (!strcmp(name, media_list[i].name)) {
-			warn("Media <%s> rejected, duplicate name\n", name);
-			media_count--;
-			goto exit;
-		}
-	}
-
-	m_ptr = &media_list[media_id];
-	m_ptr->type_id = media_type;
-	m_ptr->send_msg = send_msg;
-	m_ptr->enable_bearer = enable;
-	m_ptr->disable_bearer = disable;
-	m_ptr->addr2str = addr2str;
-	memcpy(&m_ptr->bcast_addr, bcast_addr, sizeof(*bcast_addr));
-	m_ptr->bcast = 1;
-	strcpy(m_ptr->name, name);
-	m_ptr->priority = bearer_priority;
-	m_ptr->tolerance = link_tolerance;
-	m_ptr->window = send_window_limit;
-	dbg("Media <%s> registered\n", name);
-	res = 0;
-exit:
-	write_unlock_bh(&tipc_net_lock);
-	return res;
-}
-
-/**
- * tipc_media_addr_printf - record media address in print buffer
- */
-
-void tipc_media_addr_printf(struct print_buf *pb, struct tipc_media_addr *a)
-{
-	struct media *m_ptr;
-	u32 media_type;
-	u32 i;
-
-	media_type = ntohl(a->type);
-	for (i = 0, m_ptr = media_list; i < media_count; i++, m_ptr++) {
-		if (m_ptr->type_id == media_type)
-			break;
-	}
-
-	if ((i < media_count) && (m_ptr->addr2str != NULL)) {
-		char addr_str[MAX_ADDR_STR];
-
-		tipc_printf(pb, "%s(%s)", m_ptr->name,
-			    m_ptr->addr2str(a, addr_str, sizeof(addr_str)));
-	} else {
-		unchar *addr = (unchar *)&a->dev_addr;
-
-		tipc_printf(pb, "UNKNOWN(%u)", media_type);
-		for (i = 0; i < (sizeof(*a) - sizeof(a->type)); i++) {
-			tipc_printf(pb, "-%02x", addr[i]);
-		}
-	}
-}
-
-/**
- * tipc_media_get_names - record names of registered media in buffer
- */
-
-struct sk_buff *tipc_media_get_names(void)
-{
-	struct sk_buff *buf;
-	struct media *m_ptr;
-	int i;
-
-	buf = tipc_cfg_reply_alloc(MAX_MEDIA * TLV_SPACE(TIPC_MAX_MEDIA_NAME));
-	if (!buf)
-		return NULL;
-
-	read_lock_bh(&tipc_net_lock);
-	for (i = 0, m_ptr = media_list; i < media_count; i++, m_ptr++) {
-		tipc_cfg_append_tlv(buf, TIPC_TLV_MEDIA_NAME, m_ptr->name,
-				    strlen(m_ptr->name) + 1);
-	}
-	read_unlock_bh(&tipc_net_lock);
-	return buf;
-}
-
-/**
- * bearer_name_validate - validate & (optionally) deconstruct bearer name
- * @name - ptr to bearer name string
- * @name_parts - ptr to area for bearer name components (or NULL if not needed)
- *
- * Returns 1 if bearer name is valid, otherwise 0.
- */
-
-static int bearer_name_validate(const char *name,
-				struct bearer_name *name_parts)
-{
-	char name_copy[TIPC_MAX_BEARER_NAME];
-	char *media_name;
-	char *if_name;
-	u32 media_len;
-	u32 if_len;
-
-	/* copy bearer name & ensure length is OK */
-
-	name_copy[TIPC_MAX_BEARER_NAME - 1] = 0;
-	/* need above in case non-Posix strncpy() doesn't pad with nulls */
-	strncpy(name_copy, name, TIPC_MAX_BEARER_NAME);
-	if (name_copy[TIPC_MAX_BEARER_NAME - 1] != 0)
-		return 0;
-
-	/* ensure all component parts of bearer name are present */
-
-	media_name = name_copy;
-	if ((if_name = strchr(media_name, ':')) == NULL)
-		return 0;
-	*(if_name++) = 0;
-	media_len = if_name - media_name;
-	if_len = strlen(if_name) + 1;
-
-	/* validate component parts of bearer name */
-
-	if ((media_len <= 1) || (media_len > TIPC_MAX_MEDIA_NAME) ||
-	    (if_len <= 1) || (if_len > TIPC_MAX_IF_NAME) ||
-	    (strspn(media_name, tipc_alphabet) != (media_len - 1)) ||
-	    (strspn(if_name, tipc_alphabet) != (if_len - 1)))
-		return 0;
-
-	/* return bearer name components, if necessary */
-
-	if (name_parts) {
-		strcpy(name_parts->media_name, media_name);
-		strcpy(name_parts->if_name, if_name);
-	}
-	return 1;
-}
-
-/**
- * bearer_find - locates bearer object with matching bearer name
- */
-
-static struct bearer *bearer_find(const char *name)
-{
-	struct bearer *b_ptr;
-	u32 i;
-
-	if (tipc_mode != TIPC_NET_MODE)
-		return NULL;
-
-	for (i = 0, b_ptr = tipc_bearers; i < MAX_BEARERS; i++, b_ptr++) {
-		if (b_ptr->active && (!strcmp(b_ptr->publ.name, name)))
-			return b_ptr;
-	}
-	return NULL;
-}
-
-/**
- * tipc_bearer_find_interface - locates bearer object with matching interface name
- */
-
-struct bearer *tipc_bearer_find_interface(const char *if_name)
-{
-	struct bearer *b_ptr;
-	char *b_if_name;
-	u32 i;
-
-	for (i = 0, b_ptr = tipc_bearers; i < MAX_BEARERS; i++, b_ptr++) {
-		if (!b_ptr->active)
-			continue;
-		b_if_name = strchr(b_ptr->publ.name, ':') + 1;
-		if (!strcmp(b_if_name, if_name))
-			return b_ptr;
-	}
-	return NULL;
-}
-
-/**
- * tipc_bearer_get_names - record names of bearers in buffer
- */
-
-struct sk_buff *tipc_bearer_get_names(void)
-{
-	struct sk_buff *buf;
-	struct media *m_ptr;
-	struct bearer *b_ptr;
-	int i, j;
-
-	buf = tipc_cfg_reply_alloc(MAX_BEARERS * TLV_SPACE(TIPC_MAX_BEARER_NAME));
-	if (!buf)
-		return NULL;
-
-	read_lock_bh(&tipc_net_lock);
-	for (i = 0, m_ptr = media_list; i < media_count; i++, m_ptr++) {
-		for (j = 0; j < MAX_BEARERS; j++) {
-			b_ptr = &tipc_bearers[j];
-			if (b_ptr->active && (b_ptr->media == m_ptr)) {
-				tipc_cfg_append_tlv(buf, TIPC_TLV_BEARER_NAME,
-						    b_ptr->publ.name,
-						    strlen(b_ptr->publ.name) + 1);
-			}
-		}
-	}
-	read_unlock_bh(&tipc_net_lock);
-	return buf;
-}
-
-void tipc_bearer_add_dest(struct bearer *b_ptr, u32 dest)
-{
-	tipc_nmap_add(&b_ptr->nodes, dest);
-	tipc_disc_update_link_req(b_ptr->link_req);
-	tipc_bcbearer_sort();
-}
-
-void tipc_bearer_remove_dest(struct bearer *b_ptr, u32 dest)
-{
-	tipc_nmap_remove(&b_ptr->nodes, dest);
-	tipc_disc_update_link_req(b_ptr->link_req);
-	tipc_bcbearer_sort();
-}
-
-/*
- * bearer_push(): Resolve bearer congestion. Force the waiting
- * links to push out their unsent packets, one packet per link
- * per iteration, until all packets are gone or congestion reoccurs.
- * 'tipc_net_lock' is read_locked when this function is called
- * bearer.lock must be taken before calling
- * Returns binary true(1) ore false(0)
- */
-static int bearer_push(struct bearer *b_ptr)
-{
-	u32 res = 0;
-	struct link *ln, *tln;
-
-	if (b_ptr->publ.blocked)
-		return 0;
-
-	while (!list_empty(&b_ptr->cong_links) && (res != PUSH_FAILED)) {
-		list_for_each_entry_safe(ln, tln, &b_ptr->cong_links, link_list) {
-			res = tipc_link_push_packet(ln);
-			if (res == PUSH_FAILED)
-				break;
-			if (res == PUSH_FINISHED)
-				list_move_tail(&ln->link_list, &b_ptr->links);
-		}
-	}
-	return list_empty(&b_ptr->cong_links);
-}
-
-void tipc_bearer_lock_push(struct bearer *b_ptr)
-{
-	int res;
-
-	spin_lock_bh(&b_ptr->publ.lock);
-	res = bearer_push(b_ptr);
-	spin_unlock_bh(&b_ptr->publ.lock);
-	if (res)
-		tipc_bcbearer_push();
-}
-
-
-/*
- * Interrupt enabling new requests after bearer congestion or blocking:
- * See bearer_send().
- */
-void tipc_continue(struct tipc_bearer *tb_ptr)
-{
-	struct bearer *b_ptr = (struct bearer *)tb_ptr;
-
-	spin_lock_bh(&b_ptr->publ.lock);
-	b_ptr->continue_count++;
-	if (!list_empty(&b_ptr->cong_links))
-		tipc_k_signal((Handler)tipc_bearer_lock_push, (unsigned long)b_ptr);
-	b_ptr->publ.blocked = 0;
-	spin_unlock_bh(&b_ptr->publ.lock);
-}
-
-/*
- * Schedule link for sending of messages after the bearer
- * has been deblocked by 'continue()'. This method is called
- * when somebody tries to send a message via this link while
- * the bearer is congested. 'tipc_net_lock' is in read_lock here
- * bearer.lock is busy
- */
-
-static void tipc_bearer_schedule_unlocked(struct bearer *b_ptr, struct link *l_ptr)
-{
-	list_move_tail(&l_ptr->link_list, &b_ptr->cong_links);
-}
-
-/*
- * Schedule link for sending of messages after the bearer
- * has been deblocked by 'continue()'. This method is called
- * when somebody tries to send a message via this link while
- * the bearer is congested. 'tipc_net_lock' is in read_lock here,
- * bearer.lock is free
- */
-
-void tipc_bearer_schedule(struct bearer *b_ptr, struct link *l_ptr)
-{
-	spin_lock_bh(&b_ptr->publ.lock);
-	tipc_bearer_schedule_unlocked(b_ptr, l_ptr);
-	spin_unlock_bh(&b_ptr->publ.lock);
-}
-
-
-/*
- * tipc_bearer_resolve_congestion(): Check if there is bearer congestion,
- * and if there is, try to resolve it before returning.
- * 'tipc_net_lock' is read_locked when this function is called
- */
-int tipc_bearer_resolve_congestion(struct bearer *b_ptr, struct link *l_ptr)
-{
-	int res = 1;
-
-	if (list_empty(&b_ptr->cong_links))
-		return 1;
-	spin_lock_bh(&b_ptr->publ.lock);
-	if (!bearer_push(b_ptr)) {
-		tipc_bearer_schedule_unlocked(b_ptr, l_ptr);
-		res = 0;
-	}
-	spin_unlock_bh(&b_ptr->publ.lock);
-	return res;
-}
-
-
-/**
- * tipc_enable_bearer - enable bearer with the given name
- */
-
-int tipc_enable_bearer(const char *name, u32 bcast_scope, u32 priority)
-{
-	struct bearer *b_ptr;
-	struct media *m_ptr;
-	struct bearer_name b_name;
-	char addr_string[16];
-	u32 bearer_id;
-	u32 with_this_prio;
-	u32 i;
-	int res = -EINVAL;
-
-	if (tipc_mode != TIPC_NET_MODE) {
-		warn("Bearer <%s> rejected, not supported in standalone mode\n",
-		     name);
-		return -ENOPROTOOPT;
-	}
-	if (!bearer_name_validate(name, &b_name)) {
-		warn("Bearer <%s> rejected, illegal name\n", name);
-		return -EINVAL;
-	}
-	if (!tipc_addr_domain_valid(bcast_scope) ||
-	    !in_scope(bcast_scope, tipc_own_addr)) {
-		warn("Bearer <%s> rejected, illegal broadcast scope\n", name);
-		return -EINVAL;
-	}
-	if ((priority < TIPC_MIN_LINK_PRI ||
-	     priority > TIPC_MAX_LINK_PRI) &&
-	    (priority != TIPC_MEDIA_LINK_PRI)) {
-		warn("Bearer <%s> rejected, illegal priority\n", name);
-		return -EINVAL;
-	}
-
-	write_lock_bh(&tipc_net_lock);
-
-	m_ptr = media_find(b_name.media_name);
-	if (!m_ptr) {
-		warn("Bearer <%s> rejected, media <%s> not registered\n", name,
-		     b_name.media_name);
-		goto failed;
-	}
-
-	if (priority == TIPC_MEDIA_LINK_PRI)
-		priority = m_ptr->priority;
-
-restart:
-	bearer_id = MAX_BEARERS;
-	with_this_prio = 1;
-	for (i = MAX_BEARERS; i-- != 0; ) {
-		if (!tipc_bearers[i].active) {
-			bearer_id = i;
-			continue;
-		}
-		if (!strcmp(name, tipc_bearers[i].publ.name)) {
-			warn("Bearer <%s> rejected, already enabled\n", name);
-			goto failed;
-		}
-		if ((tipc_bearers[i].priority == priority) &&
-		    (++with_this_prio > 2)) {
-			if (priority-- == 0) {
-				warn("Bearer <%s> rejected, duplicate priority\n",
-				     name);
-				goto failed;
-			}
-			warn("Bearer <%s> priority adjustment required %u->%u\n",
-			     name, priority + 1, priority);
-			goto restart;
-		}
-	}
-	if (bearer_id >= MAX_BEARERS) {
-		warn("Bearer <%s> rejected, bearer limit reached (%u)\n",
-		     name, MAX_BEARERS);
-		goto failed;
-	}
-
-	b_ptr = &tipc_bearers[bearer_id];
-	memset(b_ptr, 0, sizeof(struct bearer));
-
-	strcpy(b_ptr->publ.name, name);
-	res = m_ptr->enable_bearer(&b_ptr->publ);
-	if (res) {
-		warn("Bearer <%s> rejected, enable failure (%d)\n", name, -res);
-		goto failed;
-	}
-
-	b_ptr->identity = bearer_id;
-	b_ptr->media = m_ptr;
-	b_ptr->net_plane = bearer_id + 'A';
-	b_ptr->active = 1;
-	b_ptr->detect_scope = bcast_scope;
-	b_ptr->priority = priority;
-	INIT_LIST_HEAD(&b_ptr->cong_links);
-	INIT_LIST_HEAD(&b_ptr->links);
-	if (m_ptr->bcast) {
-		b_ptr->link_req = tipc_disc_init_link_req(b_ptr, &m_ptr->bcast_addr,
-							  bcast_scope, 2);
-	}
-	spin_lock_init(&b_ptr->publ.lock);
-	write_unlock_bh(&tipc_net_lock);
-	info("Enabled bearer <%s>, discovery domain %s, priority %u\n",
-	     name, addr_string_fill(addr_string, bcast_scope), priority);
-	return 0;
-failed:
-	write_unlock_bh(&tipc_net_lock);
-	return res;
-}
-
-/**
- * tipc_block_bearer(): Block the bearer with the given name,
- *                      and reset all its links
- */
-
-int tipc_block_bearer(const char *name)
-{
-	struct bearer *b_ptr = NULL;
-	struct link *l_ptr;
-	struct link *temp_l_ptr;
-
-	read_lock_bh(&tipc_net_lock);
-	b_ptr = bearer_find(name);
-	if (!b_ptr) {
-		warn("Attempt to block unknown bearer <%s>\n", name);
-		read_unlock_bh(&tipc_net_lock);
-		return -EINVAL;
-	}
-
-	info("Blocking bearer <%s>\n", name);
-	spin_lock_bh(&b_ptr->publ.lock);
-	b_ptr->publ.blocked = 1;
-	list_for_each_entry_safe(l_ptr, temp_l_ptr, &b_ptr->links, link_list) {
-		struct tipc_node *n_ptr = l_ptr->owner;
-
-		spin_lock_bh(&n_ptr->lock);
-		tipc_link_reset(l_ptr);
-		spin_unlock_bh(&n_ptr->lock);
-	}
-	spin_unlock_bh(&b_ptr->publ.lock);
-	read_unlock_bh(&tipc_net_lock);
-	return 0;
-}
-
-/**
- * bearer_disable -
- *
- * Note: This routine assumes caller holds tipc_net_lock.
- */
-
-static int bearer_disable(const char *name)
-{
-	struct bearer *b_ptr;
-	struct link *l_ptr;
-	struct link *temp_l_ptr;
-
-	b_ptr = bearer_find(name);
-	if (!b_ptr) {
-		warn("Attempt to disable unknown bearer <%s>\n", name);
-		return -EINVAL;
-	}
-
-	info("Disabling bearer <%s>\n", name);
-	tipc_disc_stop_link_req(b_ptr->link_req);
-	spin_lock_bh(&b_ptr->publ.lock);
-	b_ptr->link_req = NULL;
-	b_ptr->publ.blocked = 1;
-	if (b_ptr->media->disable_bearer) {
-		spin_unlock_bh(&b_ptr->publ.lock);
-		write_unlock_bh(&tipc_net_lock);
-		b_ptr->media->disable_bearer(&b_ptr->publ);
-		write_lock_bh(&tipc_net_lock);
-		spin_lock_bh(&b_ptr->publ.lock);
-	}
-	list_for_each_entry_safe(l_ptr, temp_l_ptr, &b_ptr->links, link_list) {
-		tipc_link_delete(l_ptr);
-	}
-	spin_unlock_bh(&b_ptr->publ.lock);
-	memset(b_ptr, 0, sizeof(struct bearer));
-	return 0;
-}
-
-int tipc_disable_bearer(const char *name)
-{
-	int res;
-
-	write_lock_bh(&tipc_net_lock);
-	res = bearer_disable(name);
-	write_unlock_bh(&tipc_net_lock);
-	return res;
-}
-
-
-
-int tipc_bearer_init(void)
-{
-	int res;
-
-	write_lock_bh(&tipc_net_lock);
-	tipc_bearers = kcalloc(MAX_BEARERS, sizeof(struct bearer), GFP_ATOMIC);
-	media_list = kcalloc(MAX_MEDIA, sizeof(struct media), GFP_ATOMIC);
-	if (tipc_bearers && media_list) {
-		res = 0;
-	} else {
-		kfree(tipc_bearers);
-		kfree(media_list);
-		tipc_bearers = NULL;
-		media_list = NULL;
-		res = -ENOMEM;
-	}
-	write_unlock_bh(&tipc_net_lock);
-	return res;
-}
-
-void tipc_bearer_stop(void)
-{
-	u32 i;
-
-	if (!tipc_bearers)
-		return;
-
-	for (i = 0; i < MAX_BEARERS; i++) {
-		if (tipc_bearers[i].active)
-			tipc_bearers[i].publ.blocked = 1;
-	}
-	for (i = 0; i < MAX_BEARERS; i++) {
-		if (tipc_bearers[i].active)
-			bearer_disable(tipc_bearers[i].publ.name);
-	}
-	kfree(tipc_bearers);
-	kfree(media_list);
-	tipc_bearers = NULL;
-	media_list = NULL;
-	media_count = 0;
-}
-
-
--- net/tipc/netlink.c
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * net/tipc/netlink.c: TIPC configuration handling
- *
- * Copyright (c) 2005-2006, Ericsson AB
- * Copyright (c) 2005-2007, Wind River Systems
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the names of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "core.h"
-#include "config.h"
-#include <net/genetlink.h>
-
-static int handle_cmd(struct sk_buff *skb, struct genl_info *info)
-{
-	struct sk_buff *rep_buf;
-	struct nlmsghdr *rep_nlh;
-	struct nlmsghdr *req_nlh = info->nlhdr;
-	struct tipc_genlmsghdr *req_userhdr = info->userhdr;
-	int hdr_space = NLMSG_SPACE(GENL_HDRLEN + TIPC_GENL_HDRLEN);
-	u16 cmd;
-
-	if ((req_userhdr->cmd & 0xC000) && (!capable(CAP_NET_ADMIN)))
-		cmd = TIPC_CMD_NOT_NET_ADMIN;
-	else
-		cmd = req_userhdr->cmd;
-
-	rep_buf = tipc_cfg_do_cmd(req_userhdr->dest, cmd,
-			NLMSG_DATA(req_nlh) + GENL_HDRLEN + TIPC_GENL_HDRLEN,
-			NLMSG_PAYLOAD(req_nlh, GENL_HDRLEN + TIPC_GENL_HDRLEN),
-			hdr_space);
-
-	if (rep_buf) {
-		skb_push(rep_buf, hdr_space);
-		rep_nlh = nlmsg_hdr(rep_buf);
-		memcpy(rep_nlh, req_nlh, hdr_space);
-		rep_nlh->nlmsg_len = rep_buf->len;
-		genlmsg_unicast(rep_buf, NETLINK_CB(skb).pid);
-	}
-
-	return 0;
-}
-
-static struct genl_family family = {
-	.id		= GENL_ID_GENERATE,
-	.name		= TIPC_GENL_NAME,
-	.version	= TIPC_GENL_VERSION,
-	.hdrsize	= TIPC_GENL_HDRLEN,
-	.maxattr	= 0,
-};
-
-static struct genl_ops ops = {
-	.cmd		= TIPC_GENL_CMD,
-	.doit		= handle_cmd,
-};
-
-static int family_registered = 0;
-
-int tipc_netlink_start(void)
-{
-
-
-	if (genl_register_family(&family))
-		goto err;
-
-	family_registered = 1;
-
-	if (genl_register_ops(&family, &ops))
-		goto err_unregister;
-
-	return 0;
-
- err_unregister:
-	genl_unregister_family(&family);
-	family_registered = 0;
- err:
-	err("Failed to register netlink interface\n");
-	return -EFAULT;
-}
-
-void tipc_netlink_stop(void)
-{
-	if (family_registered) {
-		genl_unregister_family(&family);
-		family_registered = 0;
-	}
-}
--- net/tipc/eth_media.c
+++ /dev/null
@@ -1,313 +0,0 @@
-/*
- * net/tipc/eth_media.c: Ethernet bearer support for TIPC
- *
- * Copyright (c) 2001-2007, Ericsson AB
- * Copyright (c) 2005-2007, Wind River Systems
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the names of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <net/tipc/tipc.h>
-#include <net/tipc/tipc_bearer.h>
-#include <net/tipc/tipc_msg.h>
-#include <linux/netdevice.h>
-#include <net/net_namespace.h>
-
-#define MAX_ETH_BEARERS		2
-#define ETH_LINK_PRIORITY	TIPC_DEF_LINK_PRI
-#define ETH_LINK_TOLERANCE	TIPC_DEF_LINK_TOL
-#define ETH_LINK_WINDOW		TIPC_DEF_LINK_WIN
-
-/**
- * struct eth_bearer - Ethernet bearer data structure
- * @bearer: ptr to associated "generic" bearer structure
- * @dev: ptr to associated Ethernet network device
- * @tipc_packet_type: used in binding TIPC to Ethernet driver
- */
-
-struct eth_bearer {
-	struct tipc_bearer *bearer;
-	struct net_device *dev;
-	struct packet_type tipc_packet_type;
-};
-
-static struct eth_bearer eth_bearers[MAX_ETH_BEARERS];
-static int eth_started = 0;
-static struct notifier_block notifier;
-
-/**
- * send_msg - send a TIPC message out over an Ethernet interface
- */
-
-static int send_msg(struct sk_buff *buf, struct tipc_bearer *tb_ptr,
-		    struct tipc_media_addr *dest)
-{
-	struct sk_buff *clone;
-	struct net_device *dev;
-
-	clone = skb_clone(buf, GFP_ATOMIC);
-	if (clone) {
-		skb_reset_network_header(clone);
-		dev = ((struct eth_bearer *)(tb_ptr->usr_handle))->dev;
-		clone->dev = dev;
-		dev_hard_header(clone, dev, ETH_P_TIPC,
-				 &dest->dev_addr.eth_addr,
-				 dev->dev_addr, clone->len);
-		dev_queue_xmit(clone);
-	}
-	return 0;
-}
-
-/**
- * recv_msg - handle incoming TIPC message from an Ethernet interface
- *
- * Accept only packets explicitly sent to this node, or broadcast packets;
- * ignores packets sent using Ethernet multicast, and traffic sent to other
- * nodes (which can happen if interface is running in promiscuous mode).
- * Routine truncates any Ethernet padding/CRC appended to the message,
- * and ensures message size matches actual length
- */
-
-static int recv_msg(struct sk_buff *buf, struct net_device *dev,
-		    struct packet_type *pt, struct net_device *orig_dev)
-{
-	struct eth_bearer *eb_ptr = (struct eth_bearer *)pt->af_packet_priv;
-	u32 size;
-
-	if (!net_eq(dev_net(dev), &init_net)) {
-		kfree_skb(buf);
-		return 0;
-	}
-
-	if (likely(eb_ptr->bearer)) {
-		if (likely(buf->pkt_type <= PACKET_BROADCAST)) {
-			size = msg_size((struct tipc_msg *)buf->data);
-			skb_trim(buf, size);
-			if (likely(buf->len == size)) {
-				buf->next = NULL;
-				tipc_recv_msg(buf, eb_ptr->bearer);
-				return 0;
-			}
-		}
-	}
-	kfree_skb(buf);
-	return 0;
-}
-
-/**
- * enable_bearer - attach TIPC bearer to an Ethernet interface
- */
-
-static int enable_bearer(struct tipc_bearer *tb_ptr)
-{
-	struct net_device *dev = NULL;
-	struct net_device *pdev = NULL;
-	struct eth_bearer *eb_ptr = &eth_bearers[0];
-	struct eth_bearer *stop = &eth_bearers[MAX_ETH_BEARERS];
-	char *driver_name = strchr((const char *)tb_ptr->name, ':') + 1;
-
-	/* Find device with specified name */
-
-	for_each_netdev(&init_net, pdev){
-		if (!strncmp(pdev->name, driver_name, IFNAMSIZ)) {
-			dev = pdev;
-			break;
-		}
-	}
-	if (!dev)
-		return -ENODEV;
-
-	/* Find Ethernet bearer for device (or create one) */
-
-	for (;(eb_ptr != stop) && eb_ptr->dev && (eb_ptr->dev != dev); eb_ptr++);
-	if (eb_ptr == stop)
-		return -EDQUOT;
-	if (!eb_ptr->dev) {
-		eb_ptr->dev = dev;
-		eb_ptr->tipc_packet_type.type = htons(ETH_P_TIPC);
-		eb_ptr->tipc_packet_type.dev = dev;
-		eb_ptr->tipc_packet_type.func = recv_msg;
-		eb_ptr->tipc_packet_type.af_packet_priv = eb_ptr;
-		INIT_LIST_HEAD(&(eb_ptr->tipc_packet_type.list));
-		dev_hold(dev);
-		dev_add_pack(&eb_ptr->tipc_packet_type);
-	}
-
-	/* Associate TIPC bearer with Ethernet bearer */
-
-	eb_ptr->bearer = tb_ptr;
-	tb_ptr->usr_handle = (void *)eb_ptr;
-	tb_ptr->mtu = dev->mtu;
-	tb_ptr->blocked = 0;
-	tb_ptr->addr.type = htonl(TIPC_MEDIA_TYPE_ETH);
-	memcpy(&tb_ptr->addr.dev_addr, &dev->dev_addr, ETH_ALEN);
-	return 0;
-}
-
-/**
- * disable_bearer - detach TIPC bearer from an Ethernet interface
- *
- * We really should do dev_remove_pack() here, but this function can not be
- * called at tasklet level. => Use eth_bearer->bearer as a flag to throw away
- * incoming buffers, & postpone dev_remove_pack() to eth_media_stop() on exit.
- */
-
-static void disable_bearer(struct tipc_bearer *tb_ptr)
-{
-	((struct eth_bearer *)tb_ptr->usr_handle)->bearer = NULL;
-}
-
-/**
- * recv_notification - handle device updates from OS
- *
- * Change the state of the Ethernet bearer (if any) associated with the
- * specified device.
- */
-
-static int recv_notification(struct notifier_block *nb, unsigned long evt,
-			     void *dv)
-{
-	struct net_device *dev = (struct net_device *)dv;
-	struct eth_bearer *eb_ptr = &eth_bearers[0];
-	struct eth_bearer *stop = &eth_bearers[MAX_ETH_BEARERS];
-
-	if (!net_eq(dev_net(dev), &init_net))
-		return NOTIFY_DONE;
-
-	while ((eb_ptr->dev != dev)) {
-		if (++eb_ptr == stop)
-			return NOTIFY_DONE;	/* couldn't find device */
-	}
-	if (!eb_ptr->bearer)
-		return NOTIFY_DONE;		/* bearer had been disabled */
-
-	eb_ptr->bearer->mtu = dev->mtu;
-
-	switch (evt) {
-	case NETDEV_CHANGE:
-		if (netif_carrier_ok(dev))
-			tipc_continue(eb_ptr->bearer);
-		else
-			tipc_block_bearer(eb_ptr->bearer->name);
-		break;
-	case NETDEV_UP:
-		tipc_continue(eb_ptr->bearer);
-		break;
-	case NETDEV_DOWN:
-		tipc_block_bearer(eb_ptr->bearer->name);
-		break;
-	case NETDEV_CHANGEMTU:
-	case NETDEV_CHANGEADDR:
-		tipc_block_bearer(eb_ptr->bearer->name);
-		tipc_continue(eb_ptr->bearer);
-		break;
-	case NETDEV_UNREGISTER:
-	case NETDEV_CHANGENAME:
-		tipc_disable_bearer(eb_ptr->bearer->name);
-		break;
-	}
-	return NOTIFY_OK;
-}
-
-/**
- * eth_addr2str - convert Ethernet address to string
- */
-
-static char *eth_addr2str(struct tipc_media_addr *a, char *str_buf, int str_size)
-{
-	unchar *addr = (unchar *)&a->dev_addr;
-
-	if (str_size < 18)
-		*str_buf = '\0';
-	else
-		sprintf(str_buf, "%pM", addr);
-	return str_buf;
-}
-
-/**
- * tipc_eth_media_start - activate Ethernet bearer support
- *
- * Register Ethernet media type with TIPC bearer code.  Also register
- * with OS for notifications about device state changes.
- */
-
-int tipc_eth_media_start(void)
-{
-	struct tipc_media_addr bcast_addr;
-	int res;
-
-	if (eth_started)
-		return -EINVAL;
-
-	bcast_addr.type = htonl(TIPC_MEDIA_TYPE_ETH);
-	memset(&bcast_addr.dev_addr, 0xff, ETH_ALEN);
-
-	memset(eth_bearers, 0, sizeof(eth_bearers));
-
-	res = tipc_register_media(TIPC_MEDIA_TYPE_ETH, "eth",
-				  enable_bearer, disable_bearer, send_msg,
-				  eth_addr2str, &bcast_addr, ETH_LINK_PRIORITY,
-				  ETH_LINK_TOLERANCE, ETH_LINK_WINDOW);
-	if (res)
-		return res;
-
-	notifier.notifier_call = &recv_notification;
-	notifier.priority = 0;
-	res = register_netdevice_notifier(&notifier);
-	if (!res)
-		eth_started = 1;
-	return res;
-}
-
-/**
- * tipc_eth_media_stop - deactivate Ethernet bearer support
- */
-
-void tipc_eth_media_stop(void)
-{
-	int i;
-
-	if (!eth_started)
-		return;
-
-	unregister_netdevice_notifier(&notifier);
-	for (i = 0; i < MAX_ETH_BEARERS ; i++) {
-		if (eth_bearers[i].bearer) {
-			eth_bearers[i].bearer->blocked = 1;
-			eth_bearers[i].bearer = NULL;
-		}
-		if (eth_bearers[i].dev) {
-			dev_remove_pack(&eth_bearers[i].tipc_packet_type);
-			dev_put(eth_bearers[i].dev);
-		}
-	}
-	memset(&eth_bearers, 0, sizeof(eth_bearers));
-	eth_started = 0;
-}
--- drivers/hwmon/Kconfig
+++ drivers/hwmon/Kconfig
@@ -402,12 +402,12 @@
 	  will be called gl520sm.
 
 config SENSORS_CORETEMP
-	tristate "Intel Core (2) Duo/Solo temperature sensor"
+	tristate "Intel Core/Core2/Atom temperature sensor"
 	depends on X86 && EXPERIMENTAL
 	help
 	  If you say yes here you get support for the temperature
-	  sensor inside your CPU. Supported all are all known variants
-	  of Intel Core family.
+	  sensor inside your CPU. Most of the family 6 CPUs
+	  are supported. Check documentation/driver for details.
 
 config SENSORS_IBMAEM
 	tristate "IBM Active Energy Manager temperature/power sensors and control"
--- drivers/hwmon/coretemp.c
+++ drivers/hwmon/coretemp.c
@@ -157,17 +157,24 @@
 	/* The 100C is default for both mobile and non mobile CPUs */
 
 	int tjmax = 100000;
-	int ismobile = 1;
+	int usemsr_ee = 1;
 	int err;
 	u32 eax, edx;
 
 	/* Early chips have no MSR for TjMax */
 
 	if ((c->x86_model == 0xf) && (c->x86_mask < 4)) {
-		ismobile = 0;
+		usemsr_ee = 0;
 	}
 
-	if ((c->x86_model > 0xe) && (ismobile)) {
+	/* Atoms seems to have TjMax at 90C */
+
+	if (c->x86_model == 0x1c) {
+		usemsr_ee = 0;
+		tjmax = 90000;
+	}
+
+	if ((c->x86_model > 0xe) && (usemsr_ee)) {
 
 		/* Now we can detect the mobile CPU using Intel provided table
 		   http://softwarecommunity.intel.com/Wiki/Mobility/720.htm
@@ -179,13 +186,13 @@
 			dev_warn(dev,
 				 "Unable to access MSR 0x17, assuming desktop"
 				 " CPU\n");
-			ismobile = 0;
+			usemsr_ee = 0;
 		} else if (!(eax & 0x10000000)) {
-			ismobile = 0;
+			usemsr_ee = 0;
 		}
 	}
 
-	if (ismobile) {
+	if (usemsr_ee) {
 
 		err = rdmsr_safe_on_cpu(id, 0xee, &eax, &edx);
 		if (err) {
@@ -195,7 +202,9 @@
 		} else if (eax & 0x40000000) {
 			tjmax = 85000;
 		}
-	} else {
+	/* if we dont use msr EE it means we are desktop CPU (with exeception
+	   of Atom) */
+	} else if (tjmax == 100000) {
 		dev_warn(dev, "Using relative temperature scale!\n");
 	}
 
@@ -248,9 +257,9 @@
 	platform_set_drvdata(pdev, data);
 
 	/* read the still undocumented IA32_TEMPERATURE_TARGET it exists
-	   on older CPUs but not in this register */
+	   on older CPUs but not in this register, Atoms don't have it either */
 
-	if (c->x86_model > 0xe) {
+	if ((c->x86_model > 0xe) && (c->x86_model != 0x1c)) {
 		err = rdmsr_safe_on_cpu(data->id, 0x1a2, &eax, &edx);
 		if (err) {
 			dev_warn(&pdev->dev, "Unable to read"
@@ -413,11 +422,11 @@
 	for_each_online_cpu(i) {
 		struct cpuinfo_x86 *c = &cpu_data(i);
 
-		/* check if family 6, models 0xe, 0xf, 0x16, 0x17, 0x1A */
+		/* check if family 6, models 0xe, 0xf, 0x16, 0x17, 0x1A, 0x1c */
 		if ((c->cpuid_level < 0) || (c->x86 != 0x6) ||
 		    !((c->x86_model == 0xe) || (c->x86_model == 0xf) ||
 			(c->x86_model == 0x16) || (c->x86_model == 0x17) ||
-			(c->x86_model == 0x1A))) {
+			(c->x86_model == 0x1A) || (c->x86_model == 0x1c))) {
 
 			/* supported CPU not found, but report the unknown
 			   family 6 CPU */
--- drivers/staging/android/binder.c
+++ drivers/staging/android/binder.c
@@ -2362,7 +2362,7 @@
 
 		if (t->from) {
 			struct task_struct *sender = t->from->proc->tsk;
-			tr.sender_pid = task_tgid_nr_ns(sender, current->nsproxy->pid_ns);
+			tr.sender_pid = task_tgid_nr_ns(sender, task_active_pid_ns(current));
 		} else {
 			tr.sender_pid = 0;
 		}
