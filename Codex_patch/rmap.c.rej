--- mm/rmap.c
+++ mm/rmap.c
@@ -52,10 +52,18 @@
 #include <linux/migrate.h>
 
 #include <asm/tlbflush.h>
+#ifdef CONFIG_KRG_MM
+#include <kerrighed/page_table_tree.h>
+#include <kddm/object.h>
+#include <kddm/kddm_types.h>
+#endif
 
 #include "internal.h"
 
-static struct kmem_cache *anon_vma_cachep;
+#ifndef CONFIG_KRG_MM
+static
+#endif
+struct kmem_cache *anon_vma_cachep;
 
 static inline struct anon_vma *anon_vma_alloc(void)
 {
@@ -191,7 +199,11 @@
  * Getting a lock on a stable anon_vma from a page off the LRU is
  * tricky: page_lock_anon_vma rely on RCU to guard against the races.
  */
+#ifdef CONFIG_KRG_MM
+struct anon_vma *page_lock_anon_vma(struct page *page)
+#else
 static struct anon_vma *page_lock_anon_vma(struct page *page)
+#endif
 {
 	struct anon_vma *anon_vma;
 	unsigned long anon_mapping;
@@ -211,7 +223,11 @@
 	return NULL;
 }
 
+#ifdef CONFIG_KRG_MM
+void page_unlock_anon_vma(struct anon_vma *anon_vma)
+#else
 static void page_unlock_anon_vma(struct anon_vma *anon_vma)
+#endif
 {
 	spin_unlock(&anon_vma->lock);
 	rcu_read_unlock();
@@ -763,8 +788,13 @@
  * Subfunctions of try_to_unmap: try_to_unmap_one called
  * repeatedly from either try_to_unmap_anon or try_to_unmap_file.
  */
+#ifdef CONFIG_KRG_MM
+int try_to_unmap_one(struct page *page, struct vm_area_struct *vma,
+		     int migration)
+#else
 static int try_to_unmap_one(struct page *page, struct vm_area_struct *vma,
 				int migration)
+#endif
 {
 	struct mm_struct *mm = vma->vm_mm;
 	unsigned long address;
@@ -884,6 +963,16 @@
 		}
 		set_pte_at(mm, address, pte, swp_entry_to_pte(entry));
 		BUG_ON(pte_file(*pte));
+#ifdef CONFIG_KRG_MM
+		wait_lock_kddm_page(page);
+		if (obj_entry && mm->anon_vma_kddm_id) {
+			obj_entry->object = (void*) mk_swap_pte_page(pte);
+			set_swap_pte_obj_entry(pte, obj_entry);
+			if (atomic_dec_and_test(&page->_kddm_count))
+				page->obj_entry = NULL;
+		}
+		unlock_kddm_page(page);
+#endif
 	} else if (PAGE_MIGRATION && migration) {
 		/* Establish migration entry for a file page */
 		swp_entry_t entry;
@@ -892,6 +981,10 @@
 	} else
 		dec_mm_counter(mm, file_rss);
 
+#ifdef CONFIG_KRG_MM
+	if (obj_entry)
+		CLEAR_OBJECT_LOCKED(obj_entry);
+#endif
 
 	page_remove_rmap(page);
 	page_cache_release(page);
