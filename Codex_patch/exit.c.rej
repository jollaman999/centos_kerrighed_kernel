--- kernel/exit.c
+++ kernel/exit.c
@@ -49,6 +49,24 @@
 #include <linux/fs_struct.h>
 #include <linux/init_task.h>
 #include <trace/sched.h>
+#ifdef CONFIG_KRG_KDDM
+#include <kddm/kddm_info.h>
+#endif
+#ifdef CONFIG_KRG_HOTPLUG
+#include <kerrighed/namespace.h>
+#endif
+#ifdef CONFIG_KRG_PROC
+#include <kerrighed/task.h>
+#include <kerrighed/krginit.h>
+#include <kerrighed/krg_exit.h>
+#endif
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/signal.h>
+#include <kerrighed/children.h>
+#endif
+#ifdef CONFIG_KRG_SCHED
+#include <kerrighed/scheduler/info.h>
+#endif
 
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
@@ -95,6 +116,13 @@
 	spin_lock(&sighand->siglock);
 
 	posix_cpu_timers_exit(tsk);
+#ifdef CONFIG_KRG_EPM
+	if (tsk->exit_state == EXIT_MIGRATION) {
+		BUG_ON(atomic_read(&sig->count) > 1);
+		posix_cpu_timers_exit_group(tsk);
+		sig->curr_target = NULL;
+	} else
+#endif
 	if (atomic_dec_and_test(&sig->count))
 		posix_cpu_timers_exit_group(tsk);
 	else {
@@ -143,16 +171,30 @@
 	tsk->sighand = NULL;
 	spin_unlock(&sighand->siglock);
 
+#ifdef CONFIG_KRG_EPM
+	if (tsk->exit_state == EXIT_MIGRATION)
+		krg_sighand_unpin(sighand);
+	else
+#endif
 	__cleanup_sighand(sighand);
 	clear_tsk_thread_flag(tsk,TIF_SIGPENDING);
 	if (sig) {
 		flush_sigqueue(&sig->shared_pending);
+#ifdef CONFIG_KRG_EPM
+		if (tsk->exit_state != EXIT_MIGRATION)
+#endif
 		taskstats_tgid_free(sig);
 		/*
 		 * Make sure ->signal can't go away under rq->lock,
 		 * see account_group_exec_runtime().
 		 */
 		task_rq_unlock_wait(tsk);
+#ifdef CONFIG_KRG_EPM
+		if (tsk->exit_state == EXIT_MIGRATION) {
+			krg_signal_unpin(sig);
+			return;
+		}
+#endif
 		__cleanup_signal(sig);
 	}
 }
@@ -396,6 +499,17 @@
  */
 static void reparent_to_kthreadd(void)
 {
+#ifdef CONFIG_KRG_EPM
+	struct children_kddm_object *parent_children_obj = NULL;
+	pid_t parent_tgid;
+
+	down_read(&kerrighed_init_sem);
+
+	if (rcu_dereference(current->parent_children_obj))
+		parent_children_obj = krg_parent_children_writelock(
+					current,
+					&parent_tgid);
+#endif /* CONFIG_KRG_EPM */
 	write_lock_irq(&tasklist_lock);
 
 	ptrace_unlink(current);
@@ -848,10 +974,17 @@
 static void forget_original_parent(struct task_struct *father)
 {
 	struct task_struct *p, *n, *reaper;
+#ifdef CONFIG_KRG_EPM
+	struct children_kddm_object *children_obj = NULL;
+#endif
 	LIST_HEAD(dead_children);
 
 	exit_ptrace(father);
 
+#ifdef CONFIG_KRG_EPM
+	if (rcu_dereference(father->children_obj))
+		children_obj = __krg_children_writelock(father);
+#endif
 	write_lock_irq(&tasklist_lock);
 	reaper = find_new_reaper(father);
 
@@ -912,6 +1064,9 @@
 	forget_original_parent(tsk);
 	exit_task_namespaces(tsk);
 
+#ifdef CONFIG_KRG_PROC
+	krg_cookie = krg_prepare_exit_notify(tsk);
+#endif /* CONFIG_KRG_PROC */
 	write_lock_irq(&tasklist_lock);
 	if (group_dead)
 		kill_orphaned_pgrp(tsk->group_leader, NULL);
@@ -1138,11 +1361,20 @@
 		module_put(tsk->binfmt->module);
 
 	proc_exit_connector(tsk);
+#ifdef CONFIG_KRG_EPM
+	if (!notify)
+		exit_migration(tsk);
+	else
+#endif
 	exit_notify(tsk, group_dead);
 #ifdef CONFIG_NUMA
 	mpol_put(tsk->mempolicy);
 	tsk->mempolicy = NULL;
 #endif
+#ifdef CONFIG_KRG_KDDM
+	if (tsk->kddm_info)
+		kmem_cache_free(kddm_info_cachep, tsk->kddm_info);
+#endif
 #ifdef CONFIG_FUTEX
 	/*
 	 * This must happen late, after the PID is not
@@ -1326,7 +1577,10 @@
  * the lock and this task is uninteresting.  If we return nonzero, we have
  * released the lock and the system call should return.
  */
-static int wait_task_zombie(struct task_struct *p, int options,
+#ifndef CONFIG_KRG_EPM
+static
+#endif
+int wait_task_zombie(struct task_struct *p, int options,
 			    struct siginfo __user *infop,
 			    int __user *stat_addr, struct rusage __user *ru)
 {
@@ -1377,6 +1641,10 @@
 
 	traced = ptrace_reparented(p);
 
+#ifdef CONFIG_KRG_EPM
+	/* remote call iff p->parent == baby_sitter */
+	if (p->parent != baby_sitter)
+#endif
 	if (likely(!traced)) {
 		struct signal_struct *psig;
 		struct signal_struct *sig;
@@ -1478,6 +1750,17 @@
 		retval = pid;
 
 	if (traced) {
+#ifdef CONFIG_KRG_EPM
+		struct children_kddm_object *parent_children_obj = NULL;
+		pid_t real_parent_tgid;
+		/* p may be set to NULL while we still need it */
+		struct task_struct *saved_p = p;
+
+		if (rcu_dereference(saved_p->parent_children_obj))
+			parent_children_obj =
+				krg_parent_children_writelock(saved_p,
+							      &real_parent_tgid);
+#endif
 		write_lock_irq(&tasklist_lock);
 		/* We dropped tasklist, ptracer could die and untrace */
 		ptrace_unlink(p);
@@ -1775,9 +2073,16 @@
 	return 0;
 }
 
+#ifdef CONFIG_KRG_EPM
+static
+long do_wait(enum pid_type type, struct pid *pid, pid_t upid, int options,
+	     struct siginfo __user *infop, int __user *stat_addr,
+	     struct rusage __user *ru)
+#else
 static long do_wait(enum pid_type type, struct pid *pid, int options,
 		    struct siginfo __user *infop, int __user *stat_addr,
 		    struct rusage __user *ru)
+#endif
 {
 	DECLARE_WAITQUEUE(wait, current);
 	struct task_struct *tsk;
@@ -1785,6 +2090,9 @@
 
 	trace_sched_process_wait(pid);
 
+#ifdef CONFIG_KRG_PROC
+	down_read(&kerrighed_init_sem);
+#endif
 	add_wait_queue(&current->signal->wait_chldexit,&wait);
 repeat:
 	/*
@@ -1793,9 +2101,16 @@
 	 * match our criteria, even if we are not able to reap it yet.
 	 */
 	retval = -ECHILD;
+#ifdef CONFIG_KRG_EPM
+	if (!current->children_obj)
+#endif
 	if ((type < PIDTYPE_MAX) && (!pid || hlist_empty(&pid->tasks[type])))
 		goto end;
 
+#ifdef CONFIG_KRG_EPM
+	if (current->children_obj)
+		__krg_children_readlock(current);
+#endif
 	current->state = TASK_INTERRUPTIBLE;
 	read_lock(&tasklist_lock);
 	tsk = current;
@@ -1821,11 +2136,28 @@
 		BUG_ON(tsk->signal != current->signal);
 	} while (tsk != current);
 	read_unlock(&tasklist_lock);
+#ifdef CONFIG_KRG_EPM
+	if (current->children_obj) {
+		/* Try all children, even remote ones but don't wait yet */
+		/* Releases children lock */
+		int tsk_result = krg_do_wait(current->children_obj, &retval,
+					     type, upid, options,
+					     infop, stat_addr, ru);
+		if (tsk_result)
+			retval = tsk_result;
+	}
+#endif
 
 	if (!retval && !(options & WNOHANG)) {
 		retval = -ERESTARTSYS;
 		if (!signal_pending(current)) {
+#ifdef CONFIG_KRG_PROC
+			up_read(&kerrighed_init_sem);
+#endif
 			schedule();
+#ifdef CONFIG_KRG_PROC
+			down_read(&kerrighed_init_sem);
+#endif
 			goto repeat;
 		}
 	}
@@ -1833,6 +2165,9 @@
 end:
 	current->state = TASK_RUNNING;
 	remove_wait_queue(&current->signal->wait_chldexit,&wait);
+#ifdef CONFIG_KRG_PROC
+	up_read(&kerrighed_init_sem);
+#endif
 	if (infop) {
 		if (retval > 0)
 			retval = 0;
@@ -1891,7 +2226,11 @@
 
 	if (type < PIDTYPE_MAX)
 		pid = find_get_pid(upid);
+#ifdef CONFIG_KRG_EPM
+	ret = do_wait(type, pid, upid, options, infop, NULL, ru);
+#else
 	ret = do_wait(type, pid, options, infop, NULL, ru);
+#endif
 	put_pid(pid);
 
 	/* avoid REGPARM breakage on x86: */
@@ -1923,7 +2262,17 @@
 		pid = find_get_pid(upid);
 	}
 
+#ifdef CONFIG_KRG_EPM
+	if (type == PIDTYPE_PGID) {
+		if (upid == 0)
+			upid = pid_vnr(pid);
+		else /* upid < 0 */
+			upid = -upid;
+	}
+	ret = do_wait(type, pid, upid, options | WEXITED, NULL, stat_addr, ru);
+#else
 	ret = do_wait(type, pid, options | WEXITED, NULL, stat_addr, ru);
+#endif
 	put_pid(pid);
 
 	/* avoid REGPARM breakage on x86: */
