--- ipc/util.c
+++ ipc/util.c
@@ -398,14 +537,35 @@
 	if (ids->in_use >= size)
 		return -ENOSPC;
 
+#ifdef CONFIG_KRG_IPC
+	if (requested_id != -1)
+		return ipc_reserveid(ids, new, requested_id);
+#endif
+
+#ifdef CONFIG_KRG_IPC
+	mutex_init(&new->mutex);
+#else
 	spin_lock_init(&new->lock);
+#endif
 	new->deleted = 0;
 	rcu_read_lock();
+#ifdef CONFIG_KRG_IPC
+	mutex_lock(&new->mutex);
+#else
 	spin_lock(&new->lock);
+#endif
 
+#ifdef CONFIG_KRG_IPC
+	err = krg_idr_get_new(ids, new, &id);
+#else
 	err = idr_get_new(&ids->ipcs_idr, new, &id);
+#endif
 	if (err) {
+#ifdef CONFIG_KRG_IPC
+		mutex_unlock(&new->mutex);
+#else
 		spin_unlock(&new->lock);
+#endif
 		rcu_read_unlock();
 		return err;
 	}
@@ -888,8 +1109,11 @@
  *
  * The ipc object is locked on exit.
  */
-
+#ifdef CONFIG_KRG_IPC
+struct kern_ipc_perm *local_ipc_lock(struct ipc_ids *ids, int id)
+#else
 struct kern_ipc_perm *ipc_lock(struct ipc_ids *ids, int id)
+#endif
 {
 	struct kern_ipc_perm *out;
 	int lid = ipcid_to_idx(id);
@@ -900,14 +1124,21 @@
 		rcu_read_unlock();
 		return ERR_PTR(-EINVAL);
 	}
-
+#ifdef CONFIG_KRG_IPC
+	mutex_lock(&out->mutex);
+#else
 	spin_lock(&out->lock);
+#endif
 	
 	/* ipc_rmid() may have already freed the ID while ipc_lock
 	 * was spinning: here verify that the structure is still valid
 	 */
 	if (out->deleted) {
+#ifdef CONFIG_KRG_IPC
+		mutex_unlock(&out->mutex);
+#else
 		spin_unlock(&out->lock);
+#endif
 		rcu_read_unlock();
 		return ERR_PTR(-EINVAL);
 	}
